{
  "openapi" : "3.0.1",
  "info" : {
    "title" : "Client API",
    "description" : "The client-server API provides a simple lightweight API to let clients send messages, control rooms and synchronise conversation history. It is designed to support both lightweight clients which store no state and lazy-load data from the server as required - as well as heavyweight clients which maintain a full local persistent copy of server state.",
    "contact" : {
      "name" : "Anatoly Sablin",
      "email" : "sablintolya@gmail.com"
    },
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "version" : "0.5.0"
  },
  "security" : [ {
    "accessToken" : [ ]
  } ],
  "paths" : {
    "/_matrix/client/r0/register" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Register for an account on this homeserver.",
        "operationId" : "register",
        "parameters" : [ {
          "name" : "kind",
          "in" : "query",
          "description" : "The kind of account to register.",
          "schema" : {
            "type" : "string",
            "default" : "user",
            "enum" : [ "guest", "user" ]
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RegisterRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The account has been registered",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LoginResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/register/available" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Checks to see if a username is available, and valid, for the server.",
        "description" : "he server should check to ensure that, at the time of the request, the username requested is available for use.This includes verifying that an application service has not claimed the username and that the username fits the server'sdesired requirements (for example, a server could dictate that it does not permit usernames with underscores).Matrix clients may wish to use this API prior to attempting registration, however the clients must also be awarethat using this API does not normally reserve the username. This can mean that the username becomes unavailablebetween checking its availability and attempting to register it.",
        "operationId" : "available",
        "parameters" : [ {
          "name" : "username",
          "in" : "query",
          "description" : "The username to check the availability of",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The username is available.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AvailableResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid or the username is not available",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/password" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Changes the password for an account on this homeserver.",
        "description" : "This API endpoint uses the User-Interactive Authentication API. An access token should be submitted to this endpoint if the client has an active session. The homeserver may change the flows available depending on whether a valid access token is provided.",
        "operationId" : "password",
        "requestBody" : {
          "description" : "password.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PasswordRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The password has been changed.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        }, {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/deactivate" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Deactivate the user's account, removing all ability for the user to login again.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.An access token should be submitted to this endpoint if the client has an active session.The homeserver may change the flows available depending on whether a valid access token is provided.",
        "operationId" : "deactivate",
        "requestBody" : {
          "description" : "request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeactivateRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The account has been deactivated.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DeactivateResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/register/email/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Request email token.",
        "description" : "Proxies the identity server API validate/email/emailRequestToken, but first checks that the given email address is not already associated with an account on this Home Server. Note that, for consistency, this API takes JSON objects, though the Identity Server API takes x-www-form-urlencoded parameters. See the Identity Server API for further information.",
        "operationId" : "emailRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EmailRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An email has been sent to the specified address.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not permit the address to be bound.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/register/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Request msisdn token.",
        "description" : "Proxies the Identity Service API validate/msisdn/requestToken, but first checks that the given phone number is not already associated with an account on this homeserver. See the Identity Service API for further information.",
        "operationId" : "msisdnRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MsisdnRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An SMS message has been sent to the specified phone number.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not permit the address to be bound.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/password/email/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Proxies the identity server API validate/email/requestToken, but first checks that the given email address is associated with an account on this Home Server.",
        "description" : "This API should be used to request validation tokens when authenticating for the account/password endpoint. This API's parameters and response are identical to that of the HS API /register/email/requestToken except that M_THREEPID_NOT_FOUND may be returned if no account matching the given email address could be found. The server may instead send an email to the given address prompting the user to create an account. M_THREEPID_IN_USE may not be returned.",
        "operationId" : "passwordEmailRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EmailRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An email was sent to the given address",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "The referenced third party identifier is not recognised by the homeserver, or the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/password/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Proxies the identity server API validate/email/requestToken, but first checks that the given email address is associated with an account on this Home Server.",
        "description" : "This API should be used to request validation tokens when authenticating for the account/password endpoint. This API's parameters and response are identical to that of the HS API /register/email/requestToken except that M_THREEPID_NOT_FOUND may be returned if no account matching the given email address could be found. The server may instead send an email to the given address prompting the user to create an account. M_THREEPID_IN_USE may not be returned.",
        "operationId" : "passwordMsisdnRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MsisdnRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An SMS message was sent to the given phone number.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "The referenced third party identifier is not recognised by the homeserver, or the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/3pid" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Gets a list of the third party identifiers that the homeserver has associated with the user's account",
        "description" : "This is not the same as the list of third party identifiers bound to the user's Matrix ID in Identity Servers. Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user's account password.",
        "operationId" : "getThreePid",
        "responses" : {
          "200" : {
            "description" : "The lookup was successful",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ThreePidResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Adds contact information to the user's account",
        "operationId" : "updateThreePid",
        "requestBody" : {
          "description" : "New contact information.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ThreePidRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The addition was successful.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The credentials could not be verified with the identity server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/3pid/delete" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Removes a third party identifier from the user's account.",
        "description" : "This might not cause an unbind of the identifier from the identity server.",
        "operationId" : "deleteThreePid",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/Delete3PidRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The homeserver has disassociated the third party identifier from the user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DeactivateResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/3pid/email/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Proxies the identity server API validate/email/requestToken",
        "description" : "Proxies the identity server API validate/email/requestToken, but first checks that the given email address is not already associated with an account on this Home Server. This API should be used to request validation tokens when adding an email address to an account. This API's parameters and response is identical to that of the HS API  /register/email/requestToken endpoint.",
        "operationId" : "threePidEmailRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EmailRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An email was sent to the given address",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "The third party identifier is already in use on the homeserver, or the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/3pid/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Proxies the identity server API validate/email/requestToken",
        "description" : "roxies the identity server API validate/email/requestToken, but first checks that the given email address is not already associated with an account on this Home Server. This API should be used to request validation tokens when adding an email address to an account. This API's parameters and response is identical to that of the HS API  /register/email/requestToken endpoint.",
        "operationId" : "threePidMsisdnRequestToken",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MsisdnRequestToken"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An SMS message was sent to the given phone number.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "The third party identifier is already in use on the homeserver, or the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/account/whoami" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Gets information about the owner of a given access token",
        "description" : "Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace  by giving a user_id query parameter. In this situation, the server should verify that the given user_id is registered by the appservice, and return it in the response body.",
        "operationId" : "whoami",
        "responses" : {
          "200" : {
            "description" : "The token belongs to a known user",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/WhoamiResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The token is not recognised.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The appservice cannot masquerade as the user or has not registered them.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/admin/whois/{userId}" : {
      "get" : {
        "tags" : [ "Server administration" ],
        "summary" : "This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.",
        "operationId" : "whois",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The use to look up",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The lookup was successful.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AdminResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/login" : {
      "get" : {
        "tags" : [ "Session management" ],
        "summary" : "Gets the homeserver's supported login types to authenticate users.",
        "description" : "Clients should pick one of these and supply it as the type when logging in.",
        "operationId" : "supportedLoginTypes",
        "responses" : {
          "200" : {
            "description" : "The login types the homeserver supports.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SupportedLoginResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Session management" ],
        "summary" : "Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests",
        "description" : "If the client does not supply a device_id, the server must auto-generate one. The returned access token must be associated with the device_id supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device",
        "operationId" : "login",
        "requestBody" : {
          "description" : "login request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/LoginRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The user has been authenticated",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LoginResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid. For example, the login type may not be recognised",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The login attempt failed. For example, the password may have been incorrect.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/logout" : {
      "post" : {
        "tags" : [ "Session management" ],
        "summary" : "Invalidates an existing access token, so that it can no longer be used for authorization.",
        "operationId" : "logout",
        "responses" : {
          "200" : {
            "description" : "The access token used in the request was succesfully invalidated",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/logout/all" : {
      "post" : {
        "tags" : [ "Session management" ],
        "summary" : "Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request",
        "description" : "This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.",
        "operationId" : "logoutAll",
        "responses" : {
          "200" : {
            "description" : "The user's access tokens were succesfully invalidated",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Gets information about the server's supported feature set and other relevant capabilities.",
        "operationId" : "capabilities",
        "responses" : {
          "200" : {
            "description" : "The capabilities of the server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CapabilitiesResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/account_data/{type}" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Set some account_data for the client on a given room.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room account_data.",
        "operationId" : "getRoomConfig",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to get account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to get account_data on.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to set. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "User data" ],
        "summary" : "Set some account_data for the client on a given room.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room account_data.",
        "operationId" : "addRoomConfig",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to set account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to set account_data on.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to set. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Account data",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "object",
                "additionalProperties" : {
                  "type" : "object"
                }
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/account_data/{type}" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Set some account_data for the client.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level account_data.",
        "operationId" : "getConfig",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to get account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to get. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "User data" ],
        "summary" : "Set some account_data for the client.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level account_data.",
        "operationId" : "addConfig",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to set account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to set. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Account data",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "object",
                "additionalProperties" : {
                  "type" : "object"
                }
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/media/r0/config" : {
      "get" : {
        "tags" : [ "Media" ],
        "summary" : "his endpoint allows clients to retrieve the configuration of the content repository, suchas upload limitations.",
        "description" : "Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available. NOTE: Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.",
        "operationId" : "config",
        "responses" : {
          "200" : {
            "description" : "The public content repository configuration for the matrix server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ContentConfig"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/media/r0/upload" : {
      "post" : {
        "tags" : [ "Media" ],
        "summary" : "Upload some content to the content repository.",
        "operationId" : "upload",
        "parameters" : [ {
          "name" : "filename",
          "in" : "query",
          "description" : "The name of the file being uploaded.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "Content-Type",
          "in" : "header",
          "description" : "The content type of the file being uploaded",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "The file content",
          "content" : {
            "*/*" : {
              "schema" : {
                "type" : "object"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The MXC URI for the uploaded content.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ContentUri"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/media/r0/download/{serverName}/{mediaId}" : {
      "get" : {
        "tags" : [ "Media" ],
        "summary" : "Download content from the content repository.",
        "operationId" : "download",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component).",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded."
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/octet-stream" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/media/r0/download/{serverName}/{mediaId}/{fileName}" : {
      "get" : {
        "tags" : [ "Media" ],
        "summary" : "Download content from the content repository as a given filename.",
        "operationId" : "downloadFile",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component).",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "fileName",
          "in" : "path",
          "description" : "The filename to give in the Content-Disposition.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded."
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/octet-stream" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/media/r0/thumbnail/{serverName}/{mediaId}" : {
      "get" : {
        "tags" : [ "Media" ],
        "summary" : "Download a thumbnail of the content from the content repository.",
        "operationId" : "thumbnail",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component)",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "width",
          "in" : "query",
          "description" : "The desired width of the thumbnail. The actual thumbnail may not match the size specified.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "height",
          "in" : "query",
          "description" : "The desired height of the thumbnail. The actual thumbnail may not match the size specified.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "method",
          "in" : "query",
          "description" : "The desired resizing method.",
          "schema" : {
            "type" : "string",
            "enum" : [ "crop", "scale" ]
          }
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded."
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/octet-stream" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/media/r0/preview_url" : {
      "get" : {
        "tags" : [ "Media" ],
        "summary" : "Get information about a PATH for a client.",
        "operationId" : "previewUrl",
        "parameters" : [ {
          "name" : "url",
          "in" : "query",
          "description" : "The PATH to get a preview of.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "ts",
          "in" : "query",
          "description" : "The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/events/{eventId}" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Get a single event based on event_id.",
        "description" : "You must have permission to retrieve this event e.g. by being a member in the room for this event. This endpoint was deprecated in r0 of this specification. Clients should instead call the /rooms/{roomId}/event/{eventId} API or the /rooms/{roomId}/context/{eventId} API.",
        "operationId" : "event",
        "parameters" : [ {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The full event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Event"
                }
              }
            }
          },
          "404" : {
            "description" : "The event was not found or you do not have permission to read this event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated" : true,
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/initialSync" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Get a copy of the current state and the most recent messages in a room.",
        "description" : "This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the /sync API. See the migration guide.",
        "operationId" : "roomInitialSync",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the data.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The current state of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DeprecatedRoomInfo"
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated" : true,
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/initialSync" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "This returns the full state for this user, with an optional limit on the number of messages per room to return.",
        "description" : "This endpoint was deprecated in r0 of this specification. Clients should instead call the /sync API with no since parameter. See the migration guide.",
        "operationId" : "initialSync",
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "archived",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user's current state.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DeprecatedInitialSyncResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no avatar URL for this user or this user does not exist.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "deprecated" : true,
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/devices/{deviceId}" : {
      "get" : {
        "tags" : [ "Device management" ],
        "summary" : "Gets information on a single device, by device id.",
        "operationId" : "device",
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to retrieve",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Device information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Device"
                }
              }
            }
          },
          "404" : {
            "description" : "The current user has no device with the given ID.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Device management" ],
        "summary" : "Updates the metadata on the given device.",
        "operationId" : "updateDevice",
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to update.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "The new display name for this device. If not given, the display name is unchanged.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeviceUpdateRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The device was successfully updated.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "The current user has no device with the given ID.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Device management" ],
        "summary" : "Deletes the given device, and invalidates any access token associated with it.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.",
        "operationId" : "deleteDevice",
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to delete",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Additional authentication information for the user-interactive authentication API.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeviceDeleteRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The device was successfully removed, or had been removed previously.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/delete_devices" : {
      "post" : {
        "tags" : [ "Device management" ],
        "summary" : "Deletes the given devices, and invalidates any access token associated with them.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.",
        "operationId" : "deleteDevices",
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DevicesDeleteRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The devices were successfully removed, or had been removed previously.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/devices" : {
      "get" : {
        "tags" : [ "Device management" ],
        "summary" : "Gets information about all devices for the current user.",
        "operationId" : "devices",
        "responses" : {
          "200" : {
            "description" : "A list of all registered devices for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DevicesResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/query" : {
      "post" : {
        "tags" : [ "End-to-end encryption" ],
        "summary" : "Returns the current devices and identity keys for the given users.",
        "operationId" : "query",
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QueryRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The device information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QueryResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/claim" : {
      "post" : {
        "tags" : [ "End-to-end encryption" ],
        "summary" : "Claims one-time keys for use in pre-key messages.",
        "operationId" : "claim",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClaimRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The claimed keys.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClaimResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/upload" : {
      "post" : {
        "tags" : [ "End-to-end encryption" ],
        "summary" : "Publishes end-to-end encryption keys for the device.",
        "operationId" : "uploadKey",
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UploadRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The provided keys were sucessfully uploaded.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/UploadResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/changes" : {
      "get" : {
        "tags" : [ "End-to-end encryption" ],
        "summary" : "Gets a list of users who have updated their device identity keys since a previous sync token.",
        "description" : "The server should include in the results any users who currently share a room with the calling user (ie, both users have membership state join); and added new device identity keys or removed an existing device with identity keys, between from and to.",
        "operationId" : "changes",
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "The desired start point of the list. Should be the next_batch field from a response to an earlier call to /sync. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The desired end point of the list. Should be the next_batch field from a recent call to /sync - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of users who updated their devices.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ChangesResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/members" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Get the list of members for this room.",
        "operationId" : "members",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the member events for.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of members of the room. If you are joined to the room then this will be the current members of the room. If you have left the room then this will be the members of the room when you left.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MembersResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/event/{eventId}" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Get a single event based on roomId/eventId. You must have permission to retrieve this event e.g. by being a member in the room for this event.",
        "operationId" : "roomEvent",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The ID of the room the event is in.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The full event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Event"
                }
              }
            }
          },
          "404" : {
            "description" : "The event was not found or you do not have permission to read this event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/messages" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "This API returns a list of message and state events for a room.",
        "description" : "It uses pagination query parameters to paginate history in the room.",
        "operationId" : "messages",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get events from.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "from",
          "in" : "query",
          "description" : "The token to start returning events from. This token can be obtained from a prev_batch token returned for each room by the sync API, or from a start or end token returned by a previous request to this endpoint.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The token to stop returning events at. This token can be obtained from a prev_batch token returned for each room by the sync endpoint, or from a start or end token returned by a previous request to this endpoint.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dir",
          "in" : "query",
          "description" : "The direction to return events from.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "b", "f" ]
          }
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The maximum number of events to return.",
          "schema" : {
            "type" : "integer",
            "format" : "int32",
            "default" : 10
          }
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "A JSON RoomEventFilter to filter returned events with.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of messages with a new token to request more.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Page"
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Get the state events for the current state of a room.",
        "operationId" : "roomState",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to look up the state for.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The current state of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/Event"
                  }
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/joined_members" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "This API returns a map of MXIDs to member info objects for members of the room.",
        "description" : "The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS's users must be in the room. This API is primarily for Application Services and should be faster to respond than/members as it can be implemented more efficiently on the server.",
        "operationId" : "joinedMembers",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the members of.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A map of MXID to room member objects.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/JoinedMembersResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.",
        "operationId" : "roomEventWithTypeAndState",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to look up the state in.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of state to look up.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "stateKey",
          "in" : "path",
          "description" : "The key of the state to look up.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The content of the state event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EventContent"
                }
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "The room has no state with the given type or key.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Room participation" ],
        "summary" : "State events can be sent using this endpoint.",
        "description" : "These events will be overwritten if (room id), (event type) and (state key) all match. Requests to this endpoint cannot use transaction IDs like other PUT paths because they cannot be differentiated from the state_key. Furthermore, POST is unsupported on state paths. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event.See Room Events for the m.event specification.",
        "operationId" : "sendEventWithTypeAndState",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to set the state in.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "stateKey",
          "in" : "path",
          "description" : "The state_key for the state to send. Defaults to the empty string.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "event",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EventContent"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SendEventResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The sender doesn't have permission to send the event into the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state/{eventType}" : {
      "put" : {
        "tags" : [ "Room participation" ],
        "summary" : "State events can be sent using this endpoint.",
        "description" : "This endpoint is equivalent to calling /rooms/{roomId}/state/{eventType}/{stateKey} with an empty stateKey. Previous state events with matching (roomId) and (eventType), and empty (stateKey), will be overwritten. Requests to this endpoint cannot use transaction IDs like other PUT paths because they cannot be differentiated from the state_key. Furthermore, POST is unsupported on state paths. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See Room Events for the m.event specification.",
        "operationId" : "sendEventWithType",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to set the state in.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Event",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EventContent"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SendEventResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The sender doesn't have permission to send the event into the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/send/{eventType}/{txnId}" : {
      "put" : {
        "tags" : [ "Room participation" ],
        "summary" : "This endpoint is used to send a message event to a room.",
        "description" : "Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See Room Events for the m. event specification.",
        "operationId" : "sendEvent",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to send the event to.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Event",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/EventContent"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SendEventResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/redact/{eventId}/{txnId}" : {
      "put" : {
        "tags" : [ "Room participation" ],
        "summary" : "Strips all information out of an event which isn't critical to the integrity of the server-side representation of the room.",
        "description" : "This cannot be undone. Users may redact their own events, and any user with a power level greater than or equal to the redact power level of the room may redact events there.",
        "operationId" : "redact",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room from which to redact the event.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The ID of the event to redact.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "The reason for the event being redacted.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RedactRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "An ID for the redaction event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SendEventResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/context/{eventId}" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "This API returns a number of events that happened just before and after the specified event.",
        "description" : "This allows clients to get the context surrounding an event.",
        "operationId" : "context",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get events from.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event to get context around.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The maximum number of events to return. Default: 10.",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The events and state surrounding the requested event.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EventContextResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/auth/{auth}/fallback/web" : {
      "get" : {
        "tags" : [ "Session management" ],
        "summary" : "Fallback login endpoint. If a client does not know how to handle a given login type, it can direct the user to a web browser with the URL of a fallback page which will allow the user to complete that login step out-of-band in their web browser.",
        "operationId" : "auth",
        "parameters" : [ {
          "name" : "auth",
          "in" : "path",
          "description" : "The type name of the stage it is attempting.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "session",
          "in" : "query",
          "description" : "the ID of the session given by the homeserver.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "n HTML page which can perform this authentication stage. This page must use the following JavaScript when the authentication has been completed."
          }
        }
      }
    },
    "/_matrix/static/client/login" : {
      "get" : {
        "tags" : [ "Session management" ],
        "summary" : "Fallback login.",
        "operationId" : "staticLogin",
        "responses" : {
          "200" : {
            "description" : "Login page for the fallback login."
          }
        }
      }
    },
    "/_matrix/client/r0/user/{userId}/filter/{filterId}" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Download a filter.",
        "operationId" : "getFilter",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user ID to download a filter for.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "filterId",
          "in" : "path",
          "description" : "The filter ID to download.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The filter definition.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/FilterData"
                }
              }
            }
          },
          "404" : {
            "description" : "Unknown filter.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/filter" : {
      "post" : {
        "tags" : [ "Room participation" ],
        "summary" : "Uploads a new filter definition to the homeserver.",
        "description" : "Returns a filter ID that may be used in future requests to restrict which events are returned to the client.",
        "operationId" : "uploadFilter",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user uploading the filter. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body parameters",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/FilterData"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The filter was created.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/FilterResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/openid/request_token" : {
      "post" : {
        "tags" : [ "OpenID" ],
        "summary" : "Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix.",
        "description" : "The generated token is only valid for exchanging for user information from the federation API for OpenID. The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call /sync, for example.",
        "operationId" : "requestToken",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user to request and OpenID token for. Should be the user who is authenticated for the request.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OpenID token information. This response is nearly compatible with the response documented in the OpenID 1.0 Specification with the only difference being the lack of an id_token. Instead, the Matrix homeserver's name is provided.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OpenIdResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/presence/{userId}/status" : {
      "get" : {
        "tags" : [ "Presence" ],
        "summary" : "Get the given user's presence state.",
        "operationId" : "getPresenceStatus",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence state to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The presence state for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PresenceStatus"
                }
              }
            }
          },
          "403" : {
            "description" : "You are not allowed to see this user's presence status.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no presence state for this user. This user may not exist or isn't exposing presence information to you.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Presence" ],
        "summary" : "This API sets the given user's presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the last_active_ago field. You cannot set the presence state of another user.",
        "operationId" : "setPresenceStatus",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence state to update.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PresenceRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The new presence state was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/profile/{userId}" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Get the combined profile information for this user. This API may be used to fetch the user's own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to displayname or avatar_url.",
        "operationId" : "profile",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose profile information to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The avatar URL for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Profile"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no profile information for this user or this user does not exist.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/profile/{userId}/displayname" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Get the user's display name. This API may be used to fetch the user's own displayname or to query the name of other users; either locally or on remote homeservers.",
        "operationId" : "showDisplayName",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose display name to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The display name for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DisplayName"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no display name for this user or this user does not exist.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "User data" ],
        "summary" : "his API sets the given user's display name. You must have permission to set this user's display name, e.g. you need to have their access_token.",
        "operationId" : "setDisplayName",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose display name to set.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DisplayName"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The display name was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/profile/{userId}/avatar_url" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "Get the user's avatar URL. This API may be used to fetch the user's own avatar URL or to query the URL of other users;  either locally or on remote homeservers.",
        "operationId" : "showAvatarUrl",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose avatar URL to get.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The avatar URL for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AvatarUrl"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no avatar URL for this user or this user does not exist.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "User data" ],
        "summary" : "This API sets the given user's avatar URL. You must have permission to set this user's avatar URL, e.g. you need to have their access_token.",
        "operationId" : "setAvatarUrl",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose avatar URL to set.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/AvatarUrl"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The avatar URL was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint get the actions for the specified push rule.",
        "operationId" : "getActions",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Either global or device/&lt;profile_tag&gt; to specify global rules or device rules for the given profile_tag.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The actions for this push rule.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PushActions"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.",
        "operationId" : "setActions",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PushActions"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The actions for the push rule were set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint gets whether the specified push rule is enabled.",
        "operationId" : "getEnabled",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Either global or device/&lt;profile_tag&gt; to specify global rules or device rules for the given profile_tag.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Whether the push rule is enabled.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PushEnable"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint allows clients to enable or disable the specified push rule.",
        "operationId" : "setEnabled",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PushEnable"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The push rule was enabled or disabled.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushers" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "Gets all currently active pushers for the authenticated user.",
        "operationId" : "showPushers",
        "responses" : {
          "200" : {
            "description" : "The pushers for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PushersResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushers/set" : {
      "post" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.",
        "operationId" : "setPushers",
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PushersRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The pusher was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "One or more of the pusher values were invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "Retrieve all push rulesets for this user. Clients can \"drill-down]\"on the rulesets by suffixing a scope to this path e.g. /pushrules/global/. This will return a subset of this data under the specified key e.g. the global key.",
        "operationId" : "pushRules",
        "responses" : {
          "200" : {
            "description" : "All the push rulesets for this user.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PushRulesResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "Retrieve a single specified push rule.",
        "operationId" : "pushRule",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The specific push rule. This will also include keys specific to the rule itself such as the rule's actions and conditions if set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PushRule"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.",
        "operationId" : "updateRule",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "before",
          "in" : "query",
          "description" : "Use 'before' with a rule_id as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "after",
          "in" : "query",
          "description" : "This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PushUpdateRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The pusher was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "There was a problem configuring this push rule.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This endpoint removes the push rule defined in the path.",
        "operationId" : "deleteRule",
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "override", "underride", "sender", "room", "content" ]
          }
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The push rule was deleted.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/notifications" : {
      "get" : {
        "tags" : [ "Push notifications" ],
        "summary" : "This API is used to paginate through the list of events that the user has been, or would have been notified about.",
        "operationId" : "notifications",
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "Pagination token given to retrieve the next set of events.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "only",
          "in" : "query",
          "description" : "Allows basic filtering of events returned.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "Limit on the number of events to return in this request.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A batch of events is being returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NotificationResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/receipt/{receiptType}/{eventId}" : {
      "post" : {
        "tags" : [ "Room participation" ],
        "summary" : "This API updates the marker for the given receipt type to the event ID specified.",
        "operationId" : "receipt",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room in which to send the event.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "receiptType",
          "in" : "path",
          "description" : "The type of receipt to send.",
          "required" : true,
          "schema" : {
            "type" : "string",
            "enum" : [ "m.read" ]
          }
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to acknowledge up to.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The receipt was sent.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/read_markers" : {
      "post" : {
        "tags" : [ "Read Markers" ],
        "summary" : "Sets the position of the read marker for a given room, and optionally the read receipt's location.",
        "operationId" : "readMarkers",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID to set the read marker in for the user.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReadMarkersRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The read marker, and read receipt if provided, have been updated.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/report/{eventId}" : {
      "post" : {
        "tags" : [ "Reporting content" ],
        "summary" : "Reports an event as inappropriate to the server, which may then notify the appropriate people.",
        "operationId" : "report",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room in which the event being reported is located.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event to report.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReportRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The event has been reported successfully.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/createRoom" : {
      "post" : {
        "tags" : [ "Room creation" ],
        "summary" : "Create a new room with various configuration options.",
        "description" : "The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event.",
        "operationId" : "create",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateRoomRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "Information about the newly created room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RoomId"
                }
              }
            }
          },
          "400" : {
            "description" : "The request is invalid. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/upgrade" : {
      "post" : {
        "tags" : [ "Room directory" ],
        "summary" : "Upgrades the given room to a particular room version, migrating as much data as possible over to the new room. See the room_upgrades module for more information on what this entails.",
        "operationId" : "upgrade",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The ID of the room to upgrade.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "The new version for the room.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewVersion"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "The room was successfully upgraded.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ReplacementRoom"
                }
              }
            }
          },
          "400" : {
            "description" : "The request was invalid. One way this can happen is if the room version requested is not supported by the homeserver.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "The user is not permitted to upgrade the room.\n",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/directory/list/room/{roomId}" : {
      "get" : {
        "tags" : [ "Room discovery" ],
        "summary" : "Gets the visibility of a given room on the server's public room directory.",
        "operationId" : "getVisibility",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The visibility of the room in the directory",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RoomVisibility"
                }
              }
            }
          },
          "404" : {
            "description" : "The room is not known to the server",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "Room discovery" ],
        "summary" : "Sets the visibility of a given room in the server's public room directory.",
        "operationId" : "setVisibility",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RoomVisibility"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The visibility was updated, or no change was needed.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "The room is not known to the server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/leave" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API stops a user participating in a particular room.",
        "description" : "If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join. If the user was invited to the room, but had not joined, this call serves to reject the invite.The user will still be allowed to retrieve history from the room which they were previously allowed to see.",
        "operationId" : "leave",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier to leave.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been left.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/invite" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.",
        "operationId" : "invite",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) to which to invite the user.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/InviteRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The user has been invited to join the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to invite the user to the room. A meaningful errcode and description error text will be returned. ",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/kick" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "Kick a user from the room.",
        "operationId" : "kick",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be kicked.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/KickRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The user has been kicked from the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to kick the user from the room. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/ban" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "Ban a user in the room. If the user is currently in the room, also kick them.",
        "operationId" : "ban",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be banned.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/KickRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The user has been kicked and banned from the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to ban the user from the room. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/directory/room/{roomAlias}" : {
      "get" : {
        "tags" : [ "Room directory" ],
        "summary" : "Requests that the server resolve a room alias to a room ID. The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server's own domain.",
        "operationId" : "resolveAlias",
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The room ID and other information for this alias.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RoomResolveResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "There is no mapped room ID for this room alias.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "Room directory" ],
        "summary" : "Create a new mapping from room alias to room ID.",
        "operationId" : "createAlias",
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias to set",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RoomId"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The mapping was created.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "409" : {
            "description" : "A room alias with that name already exists.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Room directory" ],
        "summary" : "Remove a mapping of room alias to room ID.",
        "operationId" : "deleteAlias",
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias to remove.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The mapping was deleted.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/unban" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.",
        "operationId" : "unban",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be unbanned.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UnbanRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The user has been unbanned from the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to unban the user from the room. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/publicRooms" : {
      "get" : {
        "tags" : [ "Room discovery" ],
        "summary" : "Lists the public rooms on the server. This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.",
        "operationId" : "showPublicRooms",
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "description" : "Limit the number of results returned.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "since",
          "in" : "query",
          "description" : "A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "server",
          "in" : "query",
          "description" : "The server to fetch the public room lists from. Defaults to the local server.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of the rooms on the server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PublicRoomsResponse"
                }
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Room discovery" ],
        "summary" : "Lists the public rooms on the server, with optional filter. This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.",
        "operationId" : "searchPublicRooms",
        "parameters" : [ {
          "name" : "server",
          "in" : "query",
          "description" : "The server to fetch the public room lists from. Defaults to the local server.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PublicRoomsRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "A list of the rooms on the server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PublicRoomsResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/joined_rooms" : {
      "get" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API returns a list of the user's current rooms.",
        "operationId" : "joinedRooms",
        "responses" : {
          "200" : {
            "description" : "A list of the rooms the user is in.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/JoinedRoomsResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/join" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.",
        "operationId" : "joinById",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) to join.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/JoinRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The room has been joined. The joined room ID must be returned in the room_id field.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RoomId"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to join the room. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/join/{roomIdOrAlias}" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.",
        "operationId" : "joinByIdOrAlias",
        "parameters" : [ {
          "name" : "roomIdOrAlias",
          "in" : "path",
          "description" : "The room identifier or alias to join.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "server_name",
          "in" : "query",
          "description" : "The servers to attempt to join the room through. One of the servers must be participating in the room.",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/JoinRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The room has been joined. The joined room ID must be returned in the room_id field.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RoomId"
                }
              }
            }
          },
          "403" : {
            "description" : "You do not have permission to join the room. A meaningful errcode and description error text will be returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/forget" : {
      "post" : {
        "tags" : [ "Room membership" ],
        "summary" : "This API stops a user remembering about a particular room. In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.",
        "operationId" : "forget",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier to forget.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been forgotten.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "The user has not left the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/search" : {
      "post" : {
        "tags" : [ "Search" ],
        "summary" : "Performs a full text search across different categories.",
        "operationId" : "search",
        "parameters" : [ {
          "name" : "next_batch",
          "in" : "query",
          "description" : "The point to return events from. If given, this should be a next_batch result from a previous call to this endpoint.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "Results of the search.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "400" : {
            "description" : "Part of the request was invalid.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/sendToDevice/{eventType}/{txnId}" : {
      "put" : {
        "tags" : [ "Send-to Device messaging" ],
        "summary" : "This endpoint is used to send send-to-device events to a set of client devices.",
        "operationId" : "send",
        "parameters" : [ {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON resuest body",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SendToDeviceRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The message was successfully sent.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/.well-known/matrix/client" : {
      "get" : {
        "tags" : [ "Server administration" ],
        "summary" : "Gets discovery information about the domain.",
        "operationId" : "serverDiscovery",
        "responses" : {
          "200" : {
            "description" : "Server discovery information.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ServerDiscoveryResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "No server discovery information available.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/login/sso/redirect" : {
      "get" : {
        "tags" : [ "Session management" ],
        "summary" : "A web-based Matrix client should instruct the user's browser to navigate to this endpoint in order to log in via CAS.",
        "description" : "The server MUST respond with an HTTP redirect to the CAS interface. The URI MUST include a service parameter giving the path of the /login/cas/ticket endpoint (including the redirectUrl query parameter).",
        "operationId" : "redirect",
        "parameters" : [ {
          "name" : "redirectUrl",
          "in" : "query",
          "description" : "URI to which the user will be redirected after the homeserver has authenticated the user with CAS.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "302" : {
            "description" : "A redirect to the SSO interface",
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/sync" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "Synchronise the client's state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.",
        "operationId" : "sync",
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a \"{\" open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "since",
          "in" : "query",
          "description" : "A point in time to continue a sync from.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "full_state",
          "in" : "query",
          "description" : "Controls whether to include the full state for all rooms the user is a member of.",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "name" : "set_presence",
          "in" : "query",
          "description" : "Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \"offline\" then the client is not marked as being online when it uses this API.",
          "schema" : {
            "type" : "string",
            "enum" : [ "offline" ]
          }
        }, {
          "name" : "timeout",
          "in" : "query",
          "description" : "The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The initial snapshot or delta for the client to use to update their state.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SyncResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/events" : {
      "get" : {
        "tags" : [ "Room participation" ],
        "summary" : "This will listen for new events related to a particular room and return them to the caller. This will block until an event is received, or until the timeout is reached.",
        "operationId" : "events",
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "The token to stream from. This token is either from a previous request to this API or from the initial sync API.",
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "timeout",
          "in" : "query",
          "description" : "The maximum time in milliseconds to wait for an event.",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "room_id",
          "in" : "query",
          "description" : "The room ID for which events should be returned.",
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The events received, which may be none.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Page"
                }
              }
            }
          },
          "400" : {
            "description" : "Bad pagination from parameter.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}" : {
      "put" : {
        "tags" : [ "User data" ],
        "summary" : "Add a tag to the room.",
        "operationId" : "addTag",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to add a tag for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to add a tag to.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "tag",
          "in" : "path",
          "description" : "The tag to add.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "TagInfo data.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TagInfo"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The tag was successfully added.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "User data" ],
        "summary" : "Remove a tag from the room.",
        "operationId" : "deleteTag",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to remove a tag for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to remove a tag from.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "tag",
          "in" : "path",
          "description" : "The tag to remove.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The tag was successfully removed.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags" : {
      "get" : {
        "tags" : [ "User data" ],
        "summary" : "List the tags set by a user on a room.",
        "operationId" : "showTags",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to get tags for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to get tags for.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of tags for the user for the room.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Tags"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/location" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Retrieve an array of third party network locations from a Matrix room alias.",
        "operationId" : "location",
        "parameters" : [ {
          "name" : "alias",
          "in" : "query",
          "description" : "The Matrix room alias to look up",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "At least one portal room was found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ProtocolLocation"
                  }
                }
              }
            }
          },
          "404" : {
            "description" : "No portal rooms were found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/protocol/{protocol}" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Fetches the metadata from the homeserver about a particular third party protocol.",
        "operationId" : "protocol",
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "the name of the protocol",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The protocol was found and metadata returned.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Protocol"
                }
              }
            }
          },
          "404" : {
            "description" : "The protocol is unknown.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/user" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Retrieve an array of third party users from a Matrix User ID.",
        "operationId" : "user",
        "parameters" : [ {
          "name" : "userid",
          "in" : "query",
          "description" : "The Matrix User String to look up",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The Matrix User IDs found with the given parameters.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ProtocolUser"
                  }
                }
              }
            }
          },
          "404" : {
            "description" : "The Matrix User ID was not found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/protocols" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Fetches the overall metadata about protocols supported by the homeserver.Includes both the available protocols and all fields required for queries against each protocol.",
        "operationId" : "protocols",
        "responses" : {
          "200" : {
            "description" : "The protocols supported by the homeserver.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/location/{protocol}" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Requesting this endpoint with a valid protocol name results in a list of successful mapping resultsin a JSON array.",
        "description" : "Each result contains objects to represent the Matrix room or rooms that represent a portal to this third party network. Each has the Matrix room alias string, an identifier for the particular third party network protocol, and an object containing the network-specific fields that comprise this identifier.It should attempt to canonicalise the identifier as much as reasonably possible given the network type.",
        "operationId" : "locationProtocol",
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "The protocol used to communicate to the third party network.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "At least one portal room was found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ProtocolLocation"
                  }
                }
              }
            }
          },
          "404" : {
            "description" : "No portal rooms were found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/user/{protocol}" : {
      "get" : {
        "tags" : [ "Third party protocols" ],
        "summary" : "Retrieve a Matrix User ID linked to a user on the third party service, given a set of user parameters.",
        "operationId" : "userProtocol",
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "The name of the protocol",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The Matrix User IDs found with the given parameters.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ProtocolUser"
                  }
                }
              }
            }
          },
          "404" : {
            "description" : "The Matrix User ID was not found.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/typing/{userId}" : {
      "put" : {
        "tags" : [ "Room participation" ],
        "summary" : "This tells the server that the user is typing for the next N milliseconds where N is the value specified in the timeout key. Alternatively, if typing is false, it tells the server that the user has stopped typing.",
        "operationId" : "typing",
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The user who has started to type.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "userId",
          "in" : "path",
          "description" : "The room in which the user is typing.",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TypingRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The new typing state was set.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user_directory/search" : {
      "post" : {
        "tags" : [ "User data" ],
        "summary" : "Performs a search for users on the homeserver.",
        "description" : "The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search. The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon * the Accept-Language header provided in the request, if present.",
        "operationId" : "searchUsers",
        "requestBody" : {
          "description" : "JSON body request.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SearchRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "The results of the search.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SearchResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    },
    "/_matrix/client/versions" : {
      "get" : {
        "tags" : [ "Server administration" ],
        "summary" : "Gets the versions of the specification supported by the server.",
        "operationId" : "versions",
        "responses" : {
          "200" : {
            "description" : "The versions supported by the server.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/VersionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/_matrix/client/r0/voip/turnServer" : {
      "get" : {
        "tags" : [ "VOIP" ],
        "summary" : "This API provides credentials for the client to use when initiating calls.",
        "operationId" : "turnServer",
        "responses" : {
          "200" : {
            "description" : "The TURN server credentials.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/VoipResponse"
                }
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RateLimitedErrorResponse"
                }
              }
            }
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ]
      }
    }
  },
  "components" : {
    "schemas" : {
      "HomeserverInfo" : {
        "type" : "object",
        "properties" : {
          "base_url" : {
            "type" : "string",
            "description" : "The base URL for the homeserver for client-server connections."
          }
        },
        "description" : "Homeserver information."
      },
      "IdentityServerInfo" : {
        "type" : "object",
        "properties" : {
          "base_url" : {
            "type" : "string",
            "description" : "The base URL for the identity server for client-server connections."
          }
        },
        "description" : "Identity server information."
      },
      "LoginResponse" : {
        "type" : "object",
        "properties" : {
          "user_id" : {
            "type" : "string",
            "description" : "The fully-qualified Matrix ID that has been registered."
          },
          "access_token" : {
            "type" : "string",
            "description" : "An access token for the account. This access token can then be used to authorize other requests."
          },
          "home_server" : {
            "type" : "string",
            "description" : "The hostname of the homeserver on which the account has been registered."
          },
          "well_known" : {
            "$ref" : "#/components/schemas/ServerDiscoveryResponse"
          },
          "device_id" : {
            "type" : "string",
            "description" : "ID of the logged-in device. Will be the same as the corresponding parameter in the request, if one was specified."
          }
        },
        "description" : "JSON body response for the login api."
      },
      "ServerDiscoveryResponse" : {
        "type" : "object",
        "properties" : {
          "m.homeserver" : {
            "$ref" : "#/components/schemas/HomeserverInfo"
          },
          "m.identity_server" : {
            "$ref" : "#/components/schemas/IdentityServerInfo"
          }
        },
        "description" : "Server discovery information."
      },
      "ErrorResponse" : {
        "type" : "object",
        "properties" : {
          "errcode" : {
            "type" : "string"
          },
          "error" : {
            "type" : "string"
          }
        }
      },
      "RateLimitedErrorResponse" : {
        "type" : "object",
        "properties" : {
          "errcode" : {
            "type" : "string"
          },
          "error" : {
            "type" : "string"
          },
          "retry_after_ms" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "AuthenticationData" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Auth type."
          },
          "session" : {
            "type" : "string",
            "description" : "Session."
          },
          "user" : {
            "type" : "string",
            "description" : "user id."
          },
          "password" : {
            "type" : "array",
            "description" : "password.",
            "items" : {
              "type" : "string",
              "description" : "password."
            }
          },
          "medium" : {
            "type" : "string",
            "description" : "3pid address type."
          },
          "address" : {
            "type" : "string",
            "description" : "3pid address."
          },
          "response" : {
            "type" : "string",
            "description" : "Captcha response."
          },
          "token" : {
            "type" : "string",
            "description" : "Auth token."
          },
          "uri" : {
            "type" : "string",
            "description" : "OAuth uri."
          },
          "threepidCreds" : {
            "type" : "array",
            "description" : "3pids credentials.",
            "items" : {
              "$ref" : "#/components/schemas/ThreePidCred"
            }
          },
          "txn_id" : {
            "type" : "string",
            "description" : "transaction id."
          }
        },
        "description" : "Authentication Data."
      },
      "RegisterRequest" : {
        "type" : "object",
        "properties" : {
          "auth" : {
            "$ref" : "#/components/schemas/AuthenticationData"
          },
          "username" : {
            "type" : "string",
            "description" : "The basis for the localpart of the desired Matrix ID. If omitted, the homeserver MUST generate a Matrix ID local part."
          },
          "password" : {
            "type" : "array",
            "description" : "The desired password for the account.",
            "items" : {
              "type" : "string",
              "description" : "The desired password for the account."
            }
          },
          "bind_email" : {
            "type" : "boolean",
            "description" : "If true, the server binds the email used for authentication to the Matrix ID with the ID Server."
          },
          "bind_msisdn" : {
            "type" : "boolean",
            "description" : "If true, the server binds the phone number used for authentication to the Matrix ID with the identity server."
          },
          "device_id" : {
            "type" : "string",
            "description" : "ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified."
          },
          "initial_device_display_name" : {
            "type" : "string",
            "description" : "A display name to assign to the newly-created device. Ignored if device_id corresponds to a known device."
          },
          "inhibit_login" : {
            "type" : "boolean",
            "description" : "If true, an access_token and device_id should not be returned from this call, therefore preventing an automatic login."
          }
        },
        "description" : "Request for register for an account on this homeserver."
      },
      "ThreePidCred" : {
        "required" : [ "client_secret", "id_server", "sid" ],
        "type" : "object",
        "properties" : {
          "sid" : {
            "type" : "string",
            "description" : "The session identifier given by the identity server."
          },
          "client_secret" : {
            "type" : "string",
            "description" : "The client secret used in the session with the identity server."
          },
          "id_server" : {
            "type" : "string",
            "description" : "The identity server to use."
          }
        },
        "description" : "3pid credentials"
      },
      "AvailableResponse" : {
        "type" : "object",
        "properties" : {
          "available" : {
            "type" : "boolean",
            "description" : "A flag to indicate that the username is available. This should always be true when the server replies with 200 OK."
          }
        },
        "description" : "JSON response for available api"
      },
      "EmptyResponse" : {
        "type" : "object",
        "description" : "Empty response"
      },
      "PasswordRequest" : {
        "required" : [ "new_password" ],
        "type" : "object",
        "properties" : {
          "auth" : {
            "$ref" : "#/components/schemas/AuthenticationData"
          },
          "new_password" : {
            "type" : "array",
            "description" : "The new password for the account.",
            "items" : {
              "type" : "string",
              "description" : "The new password for the account."
            }
          }
        },
        "description" : "Request for changes the password for an account on this homeserver."
      },
      "DeactivateResponse" : {
        "required" : [ "id_server_unding_result" ],
        "type" : "object",
        "properties" : {
          "id_server_unding_result" : {
            "type" : "string",
            "description" : "An indicator as to whether or not the homeserver was able to unbind the user's 3PIDs from the identity server(s). success indicates that all identifiers have been unbound from the identity server while no-support indicates that one or more identifiers failed to unbind due to the identity server refusing the request or the homeserver being unable to determine an identity server to unbind from. This must be success if the homeserver has no identifiers to unbind for the user.",
            "enum" : [ "success", "no-support" ]
          }
        },
        "description" : "Deactivate response."
      },
      "DeactivateRequest" : {
        "type" : "object",
        "properties" : {
          "auth" : {
            "$ref" : "#/components/schemas/AuthenticationData"
          },
          "id_server" : {
            "type" : "string",
            "description" : "tThe identity server to unbind all of the user's 3PIDs from. If not provided, the homeserver MUST use the id_server that was originally use to bind each identifier. If the homeserver does not know which id_server that was, it must return an id_server_unbind_result of no-support."
          }
        },
        "description" : "Request for deactivate the user's account, removing all ability for the user to login again."
      },
      "SessionResponse" : {
        "required" : [ "sid" ],
        "type" : "object",
        "properties" : {
          "sid" : {
            "type" : "string",
            "description" : "The session ID. Session IDs are opaque strings generated by the identity server. They must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
          }
        },
        "description" : "The sid generated for this session to the caller, in a JSON object containing the sid key."
      },
      "EmailRequestToken" : {
        "required" : [ "client_secret", "email", "id_server", "send_attempt" ],
        "type" : "object",
        "properties" : {
          "email" : {
            "type" : "string",
            "description" : "The email address to validate"
          },
          "id_server" : {
            "type" : "string",
            "description" : "The hostname of the identity server to communicate with. May optionally include a port."
          },
          "client_secret" : {
            "type" : "string",
            "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
          },
          "send_attempt" : {
            "type" : "integer",
            "description" : "The server will only send an email if the send_attempt is a number greater than the most recent one which it has seen, scoped to that email + client_secret pair. This is to avoid repeatedly sending the same email in the case of request retries between the POSTing user and the identity server.The client should increment this value if they desire a new email(e.g.a reminder) to be sent .",
            "format" : "int64"
          },
          "next_link" : {
            "type" : "string",
            "description" : "When the validation is completed, the identity server will redirect the user to this URL."
          }
        },
        "description" : "Request for the proxies the identity server API validate/email/requestToken."
      },
      "MsisdnRequestToken" : {
        "required" : [ "client_secret", "country", "id_server", "phone_number", "send_attempt" ],
        "type" : "object",
        "properties" : {
          "country" : {
            "type" : "string",
            "description" : "The two-letter uppercase ISO country code that the number in phone_number should be parsed as if it were dialled from."
          },
          "client_secret" : {
            "type" : "string",
            "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
          },
          "phone_number" : {
            "type" : "string",
            "description" : "The phone number to validate."
          },
          "send_attempt" : {
            "type" : "integer",
            "description" : "The server will only send an SMS if the send_attempt is a number greater than the most recent one which it has seen, scoped to that country + phone_number + client_secret triple. This is to avoid repeatedly sending the same SMS in the case of request retries between the POSTing user and the identity server. The client should increment this value if they desire a new SMS (e.g. a reminder) to be sent.",
            "format" : "int64"
          },
          "next_link" : {
            "type" : "string",
            "description" : "When the validation is completed, the identity server will redirect the user to this URL."
          },
          "id_server" : {
            "type" : "string",
            "description" : "The hostname of the identity server to communicate with. May optionally include a port."
          }
        },
        "description" : "Request for the proxies the identity server API validate/msisdn/requestToken."
      },
      "ThirdPartyIdentifier" : {
        "type" : "object",
        "properties" : {
          "medium" : {
            "type" : "string",
            "description" : "The medium of the third party identifier. Must be 'email'"
          },
          "address" : {
            "type" : "string",
            "description" : "The third party identifier address"
          },
          "validated_at" : {
            "type" : "integer",
            "description" : "The timestamp, in milliseconds, when the identifier was validated by the identity server.",
            "format" : "int64"
          },
          "added_at" : {
            "type" : "integer",
            "description" : "The timestamp, in milliseconds, when the homeserver associated the third party identifier with the user.",
            "format" : "int64"
          }
        },
        "description" : "Request for gets a list of the third party identifiers that the homeserver has associated with the user's account."
      },
      "ThreePidResponse" : {
        "type" : "object",
        "properties" : {
          "threepids" : {
            "type" : "array",
            "description" : "All 3pids",
            "items" : {
              "$ref" : "#/components/schemas/ThirdPartyIdentifier"
            }
          }
        },
        "description" : "Response for gets a list of the third party identifiers that the homeserver has associated with the user's account"
      },
      "ThreePidRequest" : {
        "type" : "object",
        "properties" : {
          "bind" : {
            "type" : "boolean",
            "description" : "Whether the homeserver should also bind this third party identifier to the account's Matrix ID with the passed identity server"
          },
          "three_pid_creds" : {
            "$ref" : "#/components/schemas/ThreePidCred"
          }
        },
        "description" : "Request for adds contact information to the user's account"
      },
      "Delete3PidRequest" : {
        "required" : [ "address", "medium" ],
        "type" : "object",
        "properties" : {
          "medium" : {
            "type" : "string",
            "description" : "The medium of the third party identifier being removed"
          },
          "address" : {
            "type" : "string",
            "description" : "The third party address neing removed."
          }
        },
        "description" : "JSON body request to delte 3pid."
      },
      "WhoamiResponse" : {
        "required" : [ "user_id" ],
        "type" : "object",
        "properties" : {
          "user_id" : {
            "type" : "string",
            "description" : "The user id that owns the access token."
          }
        },
        "description" : "Response for gets information about the owner of a given access token"
      },
      "AdminResponse" : {
        "type" : "object",
        "properties" : {
          "devices" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/DeviceInfo"
            },
            "description" : "Each key is an identitfier for one of the user's devices"
          },
          "user_id" : {
            "type" : "string",
            "description" : "he Matrix user ID of the user."
          }
        },
        "description" : "Response for gets information about a particular user."
      },
      "ConnectionInfo" : {
        "type" : "object",
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "Most recently seen IP address of the session."
          },
          "last_seen" : {
            "type" : "integer",
            "description" : "Unix timestamp that the session was last active.",
            "format" : "int64"
          },
          "user_agent" : {
            "type" : "string",
            "description" : "User agent string last seen in the session."
          }
        },
        "description" : "Connection info."
      },
      "DeviceInfo" : {
        "type" : "object",
        "properties" : {
          "sessions" : {
            "type" : "array",
            "description" : "A user's sessions (i.e. what they did with an access token from one login)",
            "items" : {
              "$ref" : "#/components/schemas/SessionInfo"
            }
          }
        },
        "description" : "Device info"
      },
      "SessionInfo" : {
        "type" : "object",
        "properties" : {
          "connections" : {
            "type" : "array",
            "description" : "Information particular connections in the session.",
            "items" : {
              "$ref" : "#/components/schemas/ConnectionInfo"
            }
          }
        },
        "description" : "Session info."
      },
      "LoginType" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Type of the authentication stage."
          }
        },
        "description" : "Login type."
      },
      "SupportedLoginResponse" : {
        "type" : "object",
        "properties" : {
          "flows" : {
            "type" : "array",
            "description" : "Supported login types.",
            "items" : {
              "$ref" : "#/components/schemas/LoginType"
            }
          }
        },
        "description" : "Supported login types."
      },
      "Identifier" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Identifier type.",
            "readOnly" : true
          }
        },
        "description" : "Identifier types."
      },
      "LoginRequest" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "The login type being used"
          },
          "identifier" : {
            "$ref" : "#/components/schemas/Identifier"
          },
          "user" : {
            "type" : "string",
            "description" : "he fully qualified user ID or just local part of the user ID, to log in."
          },
          "medium" : {
            "type" : "string",
            "description" : "When logging in using a third party identifier, the medium of the identifier. Must be 'email'."
          },
          "address" : {
            "type" : "string",
            "description" : "Third party identifier for the user"
          },
          "password" : {
            "type" : "array",
            "description" : "Required when type is m.login.password. The user's password.",
            "items" : {
              "type" : "string",
              "description" : "Required when type is m.login.password. The user's password."
            }
          },
          "token" : {
            "type" : "string",
            "description" : "Required when type is m.login.token. The login token"
          },
          "device_id" : {
            "type" : "string",
            "description" : "ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified"
          },
          "initial_device_display_name" : {
            "type" : "string",
            "description" : "A display name to assign to the newly-created device. Ignored if device_id corresponds to a known device."
          }
        },
        "description" : "Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests"
      },
      "CapabilitiesResponse" : {
        "type" : "object",
        "properties" : {
          "m.change_password" : {
            "$ref" : "#/components/schemas/ChangePasswordCapability"
          },
          "m.room_versions" : {
            "$ref" : "#/components/schemas/RoomVersionsCapability"
          }
        },
        "description" : "Capabilities response."
      },
      "ChangePasswordCapability" : {
        "required" : [ "enabled" ],
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean",
            "description" : "True if the user can change their password, false otherwise."
          }
        },
        "description" : "Capability to indicate if the user can change their password."
      },
      "RoomVersionsCapability" : {
        "required" : [ "available", "default" ],
        "type" : "object",
        "properties" : {
          "available" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "A detailed description of the room versions the server supports."
            },
            "description" : "A detailed description of the room versions the server supports."
          },
          "default" : {
            "type" : "string",
            "description" : "The default room version the server is using for new rooms."
          }
        },
        "description" : "The room versions the server supports."
      },
      "ContentConfig" : {
        "type" : "object",
        "properties" : {
          "m.upload.size" : {
            "type" : "integer",
            "description" : "The maximum size an upload can be in bytes. Clients SHOULD use this as aguide when uploading content. If not listed or null, the size limit should be treated as unknown.",
            "format" : "int64"
          }
        },
        "description" : "Content config."
      },
      "ContentUri" : {
        "type" : "object",
        "properties" : {
          "content_uri" : {
            "type" : "string",
            "description" : "MXC URI."
          }
        },
        "description" : "The MXC URI for the uploaded content"
      },
      "Answer" : {
        "required" : [ "sdp", "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "The type of session description. Must be 'answer'."
          },
          "sdp" : {
            "type" : "string",
            "description" : "The SDP text of the session description."
          }
        },
        "description" : "Answer"
      },
      "Audio" : {
        "required" : [ "url" ],
        "type" : "object",
        "properties" : {
          "info" : {
            "$ref" : "#/components/schemas/AudioInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the audio clip."
          },
          "file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          }
        },
        "description" : "This message represents a single audio clip.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "AudioInfo" : {
        "type" : "object",
        "properties" : {
          "duration" : {
            "type" : "integer",
            "description" : "The duration of the audio in milliseconds.",
            "format" : "int64"
          },
          "mimetype" : {
            "type" : "string",
            "description" : "The mimetype of the audio e.g. audio/aac."
          },
          "size" : {
            "type" : "integer",
            "description" : "The size of the audio clip in bytes.",
            "format" : "int64"
          }
        },
        "description" : "Audio type."
      },
      "CallAnswerContent" : {
        "required" : [ "answer", "call_id", "version" ],
        "type" : "object",
        "properties" : {
          "answer" : {
            "$ref" : "#/components/schemas/Answer"
          },
          "version" : {
            "type" : "integer",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0.",
            "format" : "int64"
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the callee when they wish to answer the call.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "CallCandidatesContent" : {
        "required" : [ "call_id", "candidates", "version" ],
        "type" : "object",
        "properties" : {
          "candidates" : {
            "type" : "array",
            "description" : "Array of objects describing the candidates.",
            "items" : {
              "$ref" : "#/components/schemas/Candidate"
            }
          },
          "version" : {
            "type" : "integer",
            "description" : "The version of the VoIP specification this messages adheres to. This specification is version 0.",
            "format" : "int64"
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by callers after sending an invite and by the callee after answering. Its purpose is to give the other party additional ICE candidates to try using to communicate.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "CallHangupContent" : {
        "required" : [ "call_id", "version" ],
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0.",
            "format" : "int64"
          },
          "reason" : {
            "type" : "string",
            "description" : "Optional error reason for the hangup. This should not be provided when the user naturally ends or rejects the call. When there was an error in the call negotiation, this should be ice_failed for when ICE negotiation fails or invite_timeout for when the other party did not answer in time.",
            "enum" : [ "ice_failed", "invite_timeout" ]
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "Sent by either party to signal their termination of the call. This can be sent either once the call has has been established or before to abort the call.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "CallInviteContent" : {
        "required" : [ "call_id", "lifetime", "offer", "version" ],
        "type" : "object",
        "properties" : {
          "offer" : {
            "$ref" : "#/components/schemas/Offer"
          },
          "version" : {
            "type" : "integer",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0.",
            "format" : "int64"
          },
          "lifetime" : {
            "type" : "integer",
            "description" : "The time in milliseconds that the invite is valid for. Once the invite age exceeds this value, clients should discard it. They should also no longer show the call as awaiting an answer in the UI.",
            "format" : "int64"
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the caller when they wish to establish a call.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "Candidate" : {
        "required" : [ "candidate", "sdpMLineIndex", "sdpMid" ],
        "type" : "object",
        "properties" : {
          "sdpMid" : {
            "type" : "string",
            "description" : "The SDP media type this candidate is intended for."
          },
          "sdpMLineIndex" : {
            "type" : "integer",
            "description" : "The index of the SDP 'm' line this candidate is intended for.",
            "format" : "int64"
          },
          "candidate" : {
            "type" : "string",
            "description" : "The SDP 'a' line of the candidate."
          }
        },
        "description" : "Candidate."
      },
      "CiphertextInfo" : {
        "type" : "object",
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "The encrypted payload."
          },
          "type" : {
            "type" : "integer",
            "description" : "The Olm message type.",
            "format" : "int64"
          }
        },
        "description" : "Cipher text info."
      },
      "DirectContent" : {
        "type" : "object",
        "properties" : {
          "empty" : {
            "type" : "boolean"
          }
        },
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "Emote" : {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is similar to m.text except that the sender is 'performing' the action contained in the body key, similar to /me in IRC. This message should be prefixed by the name of the sender. This message could also be represented in a different colour to distinguish it from regular m.text messages.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "EncryptedFile" : {
        "required" : [ "iv", "key", "url", "v" ],
        "type" : "object",
        "properties" : {
          "url" : {
            "type" : "string",
            "description" : "the URL to the file."
          },
          "key" : {
            "$ref" : "#/components/schemas/JWK"
          },
          "iv" : {
            "type" : "string",
            "description" : " The Initialisation Vector used by AES-CTR, encoded as unpadded base64."
          },
          "hashes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "A map from an algorithm name to a hash of the ciphertext, encoded as unpadded base64. Clients should support the SHA-256 hash, which uses the key sha256."
            },
            "description" : "A map from an algorithm name to a hash of the ciphertext, encoded as unpadded base64. Clients should support the SHA-256 hash, which uses the key sha256."
          },
          "v" : {
            "type" : "string",
            "description" : "Version of the encrypted attachments protocol. Must be v2."
          }
        },
        "description" : "Encrypted file."
      },
      "Event" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "content" : {
            "$ref" : "#/components/schemas/EventContent"
          },
          "type" : {
            "type" : "string",
            "description" : "The type of event. This SHOULD be namespaced similar to Java package naming conventions.",
            "readOnly" : true
          }
        },
        "description" : "Event."
      },
      "EventContent" : {
        "type" : "object",
        "description" : "Parent class of all event contents part in the Event."
      },
      "File" : {
        "required" : [ "filename", "url" ],
        "type" : "object",
        "properties" : {
          "filename" : {
            "type" : "string",
            "description" : "The original filename of the uploaded file."
          },
          "info" : {
            "$ref" : "#/components/schemas/FileInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          }
        },
        "description" : "This message represents a generic file.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "FileInfo" : {
        "type" : "object",
        "properties" : {
          "mimetype" : {
            "type" : "string",
            "description" : "The mimetype of the image, e.g. image/jpeg."
          },
          "size" : {
            "type" : "integer",
            "description" : "Size of the image in bytes.",
            "format" : "int64"
          },
          "thumbnail_url" : {
            "type" : "string",
            "description" : "The URL to a thumbnail of the image."
          },
          "thumbnail_file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          },
          "thumbnail_info" : {
            "$ref" : "#/components/schemas/ThumbnailInfo"
          }
        },
        "description" : "File info."
      },
      "ForwardedRoomKeyContent" : {
        "required" : [ "algorithm", "forwarding_curve25519_key_chain", "room_id", "sender_claimed_ed25519_key", "sender_key", "session_id", "session_key" ],
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "Required. The encryption algorithm the key in this event is to be used with."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "sender_key" : {
            "type" : "string",
            "description" : "Required. The Curve25519 key of the device which initiated the session originally."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          },
          "sender_claimed_ed25519_key" : {
            "type" : "string",
            "description" : "The Ed25519 key of the device which initiated the session originally. It is 'claimed' because the receiving device has no way to tell that the original room_key actually came from a device which owns the private partof this key unless they have done device verification."
          },
          "forwarding_curve25519_key_chain" : {
            "type" : "array",
            "description" : "Chain of Curve25519 keys. It starts out empty, but each time the key is forwarded to another device, the previous sender in the chain is added to the end of the list. For example, if the key is forwarded from A to B to C, this field is empty between A and B, and contains A's Curve25519 key between B and C.",
            "items" : {
              "type" : "string",
              "description" : "Chain of Curve25519 keys. It starts out empty, but each time the key is forwarded to another device, the previous sender in the chain is added to the end of the list. For example, if the key is forwarded from A to B to C, this field is empty between A and B, and contains A's Curve25519 key between B and C."
            }
          }
        },
        "description" : "This event type is used to forward keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "FullyReadContent" : {
        "required" : [ "event_id" ],
        "type" : "object",
        "properties" : {
          "event_id" : {
            "type" : "string",
            "description" : "The event the user's read marker is located at in the room."
          }
        },
        "description" : "The current location of the user's read marker in a room. This event appears in the user's room account data for the room the marker is applicable for.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "IgnoredUserListContent" : {
        "required" : [ "ignored_users" ],
        "type" : "object",
        "properties" : {
          "ignored_users" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "description" : "The map of users to ignore."
            },
            "description" : "The map of users to ignore."
          }
        },
        "description" : "A map of users which are considered ignored is kept in account_data in an event type of m.ignored_user_list.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "Image" : {
        "required" : [ "url" ],
        "type" : "object",
        "properties" : {
          "info" : {
            "$ref" : "#/components/schemas/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          }
        },
        "description" : "This message represents a single image and an optional thumbnail.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "ImageInfo" : {
        "type" : "object",
        "properties" : {
          "mimetype" : {
            "type" : "string",
            "description" : "The mimetype of the image, e.g. image/jpeg."
          },
          "size" : {
            "type" : "integer",
            "description" : "Size of the image in bytes.",
            "format" : "int64"
          },
          "thumbnail_url" : {
            "type" : "string",
            "description" : "The URL to a thumbnail of the image."
          },
          "thumbnail_file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          },
          "thumbnail_info" : {
            "$ref" : "#/components/schemas/ThumbnailInfo"
          },
          "h" : {
            "type" : "integer",
            "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          },
          "w" : {
            "type" : "integer",
            "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          }
        },
        "description" : "Image info."
      },
      "Invite" : {
        "required" : [ "display_name", "signed" ],
        "type" : "object",
        "properties" : {
          "signed" : {
            "$ref" : "#/components/schemas/Signed"
          },
          "display_name" : {
            "type" : "string",
            "description" : "A name which can be displayed to represent the user instead of their third party identifier."
          }
        },
        "description" : "Third-party invites."
      },
      "JWK" : {
        "required" : [ "alg", "ext", "k", "key", "key_opts" ],
        "type" : "object",
        "properties" : {
          "key" : {
            "type" : "string",
            "description" : "Key type. Must be oct."
          },
          "alg" : {
            "type" : "string",
            "description" : "Algorithm, Must be A256CTR."
          },
          "ext" : {
            "type" : "boolean",
            "description" : "Extractable. Must be true. This is a W3C extension."
          },
          "key_opts" : {
            "type" : "array",
            "description" : "Key operations, Must at least contain encrypt and decrypt.",
            "items" : {
              "type" : "string",
              "description" : "Key operations, Must at least contain encrypt and decrypt."
            }
          },
          "k" : {
            "type" : "string",
            "description" : "The key, encoded as urlsafe unpadded base64."
          }
        },
        "description" : "JSON Web Key."
      },
      "Location" : {
        "required" : [ "geo_uri" ],
        "type" : "object",
        "properties" : {
          "info" : {
            "$ref" : "#/components/schemas/LocationInfo"
          },
          "geo_uri" : {
            "type" : "string",
            "description" : "A geo URI representing this location."
          }
        },
        "description" : "This message represents a real-world location.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "LocationInfo" : {
        "type" : "object",
        "properties" : {
          "thumbnail_url" : {
            "type" : "string",
            "description" : "The URL to a thumbnail of the location being represented."
          },
          "thumbnail_file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          },
          "thumbnail_info" : {
            "$ref" : "#/components/schemas/ThumbnailInfo"
          }
        },
        "description" : "Location info."
      },
      "MegolmEncryptedContent" : {
        "required" : [ "algorithm", "ciphertext", "sender_key" ],
        "type" : "object",
        "properties" : {
          "ciphertext" : {
            "type" : "string",
            "description" : "The encrypted content of the event. The encrypted payload itself."
          },
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm used to encrypt this event. The value of this field determines which other properties will be present.",
            "readOnly" : true,
            "enum" : [ "m.olm.v1.curve25519-aes-sha2, m.megolm.v1.aes-sha2" ]
          }
        },
        "description" : "Megolm encrypted message.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomEncryptedContent"
        } ]
      },
      "Notice" : {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "The ``m.notice`` type is primarily intended for responses from automated clients. An ``m.notice`` message must be treated the same way as a regular ``m.text`` message with two exceptions. Firstly, clients should present ``m.notice`` messages to users in a distinct manner, and secondly, ``m.notice`` messages must never be automatically responded to. This helps to prevent infinite-loop situations where two automated clients continuously exchange messages.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "NotificationPowerLevel" : {
        "type" : "object",
        "properties" : {
          "room" : {
            "type" : "string",
            "description" : "The level required to trigger an @room notification. Defaults to 50 if unspecified.",
            "format" : "byte"
          }
        },
        "description" : "Notifications."
      },
      "Offer" : {
        "required" : [ "sdp", "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "The type of session description. Must be 'offer'."
          },
          "sdp" : {
            "type" : "string",
            "description" : "The SDP text of the session description."
          }
        },
        "description" : "Offer"
      },
      "OlmEncryptedContent" : {
        "required" : [ "algorithm", "ciphertext", "sender_key" ],
        "type" : "object",
        "properties" : {
          "ciphertext" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CiphertextInfo"
            },
            "description" : "The encrypted content of the event. A map from the recipient Curve25519 identity key to ciphertext information. For more details, see Messaging Algorithms."
          }
        },
        "description" : "Olm encrypted message.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomEncryptedContent"
        } ]
      },
      "PresenceContent" : {
        "required" : [ "presence" ],
        "type" : "object",
        "properties" : {
          "presence" : {
            "type" : "string",
            "description" : "The presence state for this user.",
            "enum" : [ "online, offline, unavailable" ]
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The current avatar URL for this user, if any."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The current display name for this user, if any."
          },
          "last_active_ago" : {
            "type" : "integer",
            "description" : "The last time since this used performed some action, in milliseconds.",
            "format" : "int64"
          },
          "currently_active" : {
            "type" : "boolean",
            "description" : "Whether the user is currently active."
          },
          "status_msg" : {
            "type" : "string",
            "description" : "An optional description to accompany the presence."
          }
        },
        "description" : "Informs the client of a user's presence state change.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "PreviousRoom" : {
        "required" : [ "event_id", "room_id" ],
        "type" : "object",
        "properties" : {
          "room_id" : {
            "type" : "string",
            "description" : "The ID of the old room."
          },
          "event_id" : {
            "type" : "string",
            "description" : "The event ID of the last known event in the old room."
          }
        },
        "description" : "A reference to the room this room replaces, if the previous room was upgraded."
      },
      "PublicKeys" : {
        "required" : [ "public_key" ],
        "type" : "object",
        "properties" : {
          "key_validity_url" : {
            "type" : "string",
            "description" : "An optional URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'. If this URL is absent, the key must be considered valid indefinitely."
          },
          "public_key" : {
            "type" : "string",
            "description" : "A base-64 encoded ed25519 key with which token may be signed."
          }
        },
        "description" : "Public keys."
      },
      "ReceiptContent" : {
        "type" : "object",
        "properties" : {
          "empty" : {
            "type" : "boolean"
          }
        },
        "additionalProperties" : {
          "$ref" : "#/components/schemas/ReceiptInfo"
        },
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "ReceiptInfo" : {
        "type" : "object",
        "properties" : {
          "m.read" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/ReceiptTs"
            },
            "description" : "A collection of users who have sent m.read receipts for this event."
          }
        },
        "description" : "Receipts."
      },
      "ReceiptTs" : {
        "type" : "object",
        "properties" : {
          "ts" : {
            "type" : "integer",
            "description" : "The timestamp the receipt was sent at.",
            "format" : "int64"
          }
        },
        "description" : "ReceiptContent timestamps."
      },
      "Relates" : {
        "type" : "object",
        "properties" : {
          "m.in_reply_to" : {
            "$ref" : "#/components/schemas/Reply"
          }
        },
        "description" : "Related data."
      },
      "Reply" : {
        "required" : [ "event_id" ],
        "type" : "object",
        "properties" : {
          "event_id" : {
            "type" : "string",
            "description" : "The origin event id."
          }
        },
        "description" : "Reply model."
      },
      "RequestedKeyInfo" : {
        "required" : [ "algorithm", "room_id", "sender_key", "session_id" ],
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "Required. The encryption algorithm the requested key in this event is to be used with."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "sender_key" : {
            "type" : "string",
            "description" : "The Curve25519 key of the device which initiated the session originally."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          }
        },
        "description" : "Requested key info."
      },
      "RoomAliasesContent" : {
        "required" : [ "aliases" ],
        "type" : "object",
        "properties" : {
          "aliases" : {
            "type" : "array",
            "description" : "A list of room aliases.",
            "items" : {
              "type" : "string",
              "description" : "A list of room aliases."
            }
          }
        },
        "description" : "This event is sent by a homeserver directly to inform of changes to the list of aliases it knows about for that room. The state_key for this event is set to the homeserver which owns the room alias. The entire set of known aliases for the room is the union of all the m.room.aliases events, one for each homeserver. Clients should check the validity of any room alias given in this list before presenting it to the user as trusted fact. The lists given by this event should be considered simply as advice on which aliases might exist, for which the client can perform the lookup to confirm whether it receives the correct room ID.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomAvatarContent" : {
        "required" : [ "url" ],
        "type" : "object",
        "properties" : {
          "info" : {
            "$ref" : "#/components/schemas/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the image."
          }
        },
        "description" : "A picture that is associated with the room. This can be displayed alongside the room information.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomCanonicalAliasContent" : {
        "required" : [ "alias" ],
        "type" : "object",
        "properties" : {
          "alias" : {
            "type" : "string",
            "description" : "The canonical alias"
          }
        },
        "description" : "This event is used to inform the room about which alias should be considered the canonical one. This could be for display purposes or as suggestion to users which alias to use to advertise the room. A room with an m.room.canonical_alias event with an absent, null, or empty alias field should be treated the same as a room with no m.room.canonical_alias event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomCreateContent" : {
        "required" : [ "creator" ],
        "type" : "object",
        "properties" : {
          "creator" : {
            "type" : "string",
            "description" : "The user_id of the room creator. This is set by the homeserver."
          },
          "predecessor" : {
            "$ref" : "#/components/schemas/PreviousRoom"
          },
          "m.federate" : {
            "type" : "boolean",
            "description" : "Whether users on other servers can join this room. Defaults to ``true`` if key does not exist."
          },
          "room_version" : {
            "type" : "string",
            "description" : "The version of the room. Defaults to \"1\" if the key does not exist."
          }
        },
        "description" : "This is the first event in a room and cannot be changed. It acts as the root of all other events.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomEncryptedContent" : {
        "required" : [ "algorithm", "sender_key" ],
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm used to encrypt this event. The value of this field determines which other properties will be present.",
            "enum" : [ "m.olm.v1.curve25519-aes-sha2, m.megolm.v1.aes-sha2" ]
          },
          "sender_key" : {
            "type" : "string",
            "description" : "The Curve25519 key of the sender."
          },
          "device_id" : {
            "type" : "string",
            "description" : "The ID of the sending device. Required with Megolm."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session used to encrypt the message. Required with Megolm."
          }
        },
        "description" : "This event type is used when sending encrypted events. It can be used either within a room (in which case it will have all of the Room Event fields), or as a to-device event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomEncryptionContent" : {
        "required" : [ "algorithm" ],
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm to be used to encrypt messages sent in this room. Must be 'm.megolm.v1.aes-sha2'."
          },
          "rotation_period_ms" : {
            "type" : "integer",
            "description" : "How long the session should be used before changing it. 604800000 (a week) is the recommended default.",
            "format" : "int64"
          },
          "rotation_period_msgs" : {
            "type" : "integer",
            "description" : "How many messages should be sent before changing the session. 100 is the recommended default.",
            "format" : "int64"
          }
        },
        "description" : "State Event. Defines how messages sent in this room should be encrypted.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomEvent" : {
        "required" : [ "event_id", "origin_server_ts", "room_id", "sender", "type" ],
        "type" : "object",
        "properties" : {
          "sender" : {
            "type" : "string",
            "description" : "Contains the fully-qualified ID of the user who sent this event."
          },
          "unsigned" : {
            "$ref" : "#/components/schemas/UnsignedEventContent"
          },
          "event_id" : {
            "type" : "string",
            "description" : "The globally unique event identifier."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The ID of the room associated with this event."
          },
          "origin_server_ts" : {
            "type" : "integer",
            "description" : "Timestamp in milliseconds on originating homeserver when this event was sent.",
            "format" : "int64"
          }
        },
        "description" : "Room Event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/Event"
        } ]
      },
      "RoomGuestAccessContent" : {
        "type" : "object",
        "properties" : {
          "guest_access" : {
            "type" : "string",
            "description" : "Whether guests can join the room.",
            "enum" : [ "can_join, forbidden" ]
          }
        },
        "description" : "This event controls whether guest users are allowed to join rooms. If this event is absent, servers should act as if it is present and has the guest_access value \"forbidden\".",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomHistoryVisibilityContent" : {
        "required" : [ "history_visibility" ],
        "type" : "object",
        "properties" : {
          "history_visibility" : {
            "type" : "string",
            "description" : "Who can see the room history.",
            "enum" : [ "invited, joined, shared, world_readable" ]
          }
        },
        "description" : "This event controls whether a user can see the events that happened in a room from before they joined.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomJoinRulesContent" : {
        "type" : "object",
        "properties" : {
          "join_rule" : {
            "type" : "string",
            "description" : "The type of rules used for users wishing to join this room.",
            "enum" : [ "public", "knock", "invite", "private" ]
          }
        },
        "description" : "A room may be ``public`` meaning anyone can join the room without any prior action. Alternatively, it can be ``invite`` meaning that a user who wishes to join the room must first receive an invite to the room from someone already inside of the room. Currently, ``knock`` and ``private`` are reserved keywords which are not implemented.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomKeyContent" : {
        "required" : [ "algorithm", "room_id", "session_id", "session_key" ],
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm the key in this event is to be used with. Must be 'm.megolm.v1.aes-sha2'."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          }
        },
        "description" : "This event type is used to exchange keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomKeyRequestContent" : {
        "required" : [ "action", "request_id", "requesting_device_id" ],
        "type" : "object",
        "properties" : {
          "body" : {
            "$ref" : "#/components/schemas/RequestedKeyInfo"
          },
          "action" : {
            "type" : "string",
            "description" : "Request action.",
            "enum" : [ "request, cancel_request" ]
          },
          "requesting_device_id" : {
            "type" : "string",
            "description" : "ID of the device requesting the key."
          },
          "request_id" : {
            "type" : "string",
            "description" : "A random string uniquely identifying the request for a key. If the key is requested multiple times, it should be reused. It should also reused in order to cancel a request."
          }
        },
        "description" : "This event type is used to request keys for end-to-end encryption. It is sent as an unencrypted to-device event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomMemberContent" : {
        "required" : [ "membership" ],
        "type" : "object",
        "properties" : {
          "membership" : {
            "type" : "string",
            "description" : "The membership state of the user.",
            "enum" : [ "invite, join, knock, leave, ban" ]
          },
          "unsigned" : {
            "$ref" : "#/components/schemas/Unsigned"
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The avatar URL for this user, if any. This is added by the homeserver."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The display name for this user, if any. This is added by the homeserver."
          },
          "third_party_invite" : {
            "$ref" : "#/components/schemas/Invite"
          },
          "is_direct" : {
            "type" : "boolean"
          }
        },
        "description" : "Adjusts the membership state for a user in a room. It is preferable to use the membership APIs (/rooms/<room id>/invite etc) when performing membership actions rather than adjusting the state directly as there are a restricted set of valid transformations. For example, user A cannot force user B to join a room, and trying to force this state change directly will fail.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomMessageContent" : {
        "type" : "object",
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "The textual representation of this message."
          },
          "m.relates_to" : {
            "$ref" : "#/components/schemas/Relates"
          },
          "msgtype" : {
            "type" : "string",
            "description" : "Message type.",
            "readOnly" : true
          }
        },
        "description" : "This event is used when sending messages in a room. Messages are not limited to be text. The ``msgtype`` key outlines the type of message, e.g. text, audio, image, video, etc. The ``body`` key is text and MUST be used with every kind of ``msgtype`` as a fallback mechanism for when a client cannot render a message. This allows clients to display *something* even if it is just plain text.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomNameContent" : {
        "required" : [ "name" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The name of the room. This MUST NOT exceed 255 bytes."
          }
        },
        "description" : "A room has an opaque room ID which is not human-friendly to read. A room alias is human-friendly, but not all rooms have room aliases. The room name is a human-friendly string designed to be displayed to the end-user. The room name is not unique, as multiple rooms can have the same room name set. A room with an m.room.name event with an absent, null, or empty name field should be treated the same as a room with no m.room.name event. An event of this type is automatically created when creating a room using /createRoom with the name key.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomPinnedContent" : {
        "required" : [ "pinned" ],
        "type" : "object",
        "properties" : {
          "pinned" : {
            "type" : "array",
            "description" : "An ordered list of event IDs to pin.",
            "items" : {
              "type" : "string",
              "description" : "An ordered list of event IDs to pin."
            }
          }
        },
        "description" : "This event is used to \"pin\" particular events in a room for other participants to review later. The order of the pinned events is guaranteed and based upon the order supplied in the event. Clients should be aware that the current user may not be able to see some of the events pinned due to visibility settings in the room. Clients are responsible for determining if a particular event in the pinned list is displayable, and have the option to not display it if it cannot be pinned in the client.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomPowerLevelsContent" : {
        "type" : "object",
        "properties" : {
          "ban" : {
            "type" : "string",
            "description" : "The level required to ban a user.",
            "format" : "byte"
          },
          "events" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "The level required to send specific event types. This is a mapping from event type to power level required.",
              "format" : "byte"
            },
            "description" : "The level required to send specific event types. This is a mapping from event type to power level required."
          },
          "invite" : {
            "type" : "string",
            "description" : "The level required to invite a user.",
            "format" : "byte"
          },
          "kick" : {
            "type" : "string",
            "description" : "The level required to kick a user.",
            "format" : "byte"
          },
          "redact" : {
            "type" : "string",
            "description" : "The level required to redact an event.",
            "format" : "byte"
          },
          "users" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "The power levels for specific users. This is a mapping from user_id to power level for that user.",
              "format" : "byte"
            },
            "description" : "The power levels for specific users. This is a mapping from user_id to power level for that user."
          },
          "notifications" : {
            "$ref" : "#/components/schemas/NotificationPowerLevel"
          },
          "events_default" : {
            "type" : "string",
            "description" : "The default level required to send message events. Can be overridden by the events key.",
            "format" : "byte"
          },
          "state_default" : {
            "type" : "string",
            "description" : "The default level required to send state events. Can be overridden by the events key. Defaults to 50 if unspecified, but 0 if there is no m.room.power_levels event at all.",
            "format" : "byte"
          },
          "users_default" : {
            "type" : "string",
            "description" : "The default power level for every user in the room, unless their user_id is mentioned in the users key.",
            "format" : "byte"
          }
        },
        "description" : "This event specifies the minimum level a user must have in order to perform a certain action. It also specifies the levels of each user in the room. If a user_id is in the users list, then that user_id has the associated power level. Otherwise they have the default level users_default. If users_default is not supplied, it is assumed to be 0. If the room contains no m.room.power_levels event, the room's creator has a power level of 100, and all other users have a power level of 0. The level required to send a certain event is governed by events, state_default and events_default. If an event type is specified in events, then the user must have at least the level specified in order to send that event. If the event type is not supplied, it defaults to events_default for Message Events and state_default for State Events. If there is no state_default in the m.room.power_levels event, the state_default is 50. If there is no events_default in the m.room.power_levels event, the events_default is 0. If the room contains no m.room.power_levels event, both the state_default and events_default are 0. The power level required to invite a user to the room, kick a user from the room, ban a user from the room, or redact an event, is defined by invite, kick, ban, and redact, respectively. Each of these levels defaults to 50 if they are not specified in the m.room.power_levels event, or if the room contains no m.room.power_levels event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomRedactionContent" : {
        "type" : "object",
        "properties" : {
          "reason" : {
            "type" : "string",
            "description" : "The reason for the redaction, if any."
          }
        },
        "description" : "Events can be redacted by either room or server admins. Redacting an event means that all keys not required by the protocol are stripped off, allowing admins to remove offensive or illegal content that may have been attached to any event. This cannot be undone, allowing server owners to physically delete the offending data. There is also a concept of a moderator hiding a message event, which can be undone, but cannot be applied to state events. The event that has been redacted is specified in the redacts event level key.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomServerAclContent" : {
        "type" : "object",
        "properties" : {
          "allow" : {
            "type" : "array",
            "description" : "The server names to allow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided, effectively disallowing every server.",
            "items" : {
              "type" : "string",
              "description" : "The server names to allow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided, effectively disallowing every server."
            }
          },
          "deny" : {
            "type" : "array",
            "description" : "The server names to disallow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided.",
            "items" : {
              "type" : "string",
              "description" : "The server names to disallow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided."
            }
          },
          "allow_ip_literals" : {
            "type" : "boolean",
            "description" : "True to allow server names that are IP address literals. False to deny. Defaults to true if missing or otherwise not a boolean. This is strongly recommended to be set to false as servers running with IP literal names are strongly discouraged in order to require legitimate homeservers to be backed by a valid registered domain name."
          }
        },
        "description" : "An event to indicate which servers are permitted to participate in the room. Server ACLs may allow or deny groups of hosts.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomThirdPartyInviteContent" : {
        "required" : [ "display_name", "key_validity_url", "public_key" ],
        "type" : "object",
        "properties" : {
          "display_name" : {
            "type" : "string",
            "description" : "A user-readable string which represents the user who has been invited. This should not contain the user's third party ID, as otherwise when the invite is accepted it would leak the association between the matrix ID and the third party ID."
          },
          "key_validity_url" : {
            "type" : "string",
            "description" : "A URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'."
          },
          "public_key" : {
            "type" : "string",
            "description" : "A base64-encoded ed25519 key with which token must be signed (though a signature from any entry in public_keys is also sufficient). This exists for backwards compatibility."
          },
          "public_keys" : {
            "type" : "array",
            "description" : "Keys with which the token may be signed.",
            "items" : {
              "$ref" : "#/components/schemas/PublicKeys"
            }
          }
        },
        "description" : "Acts as an m.room.member invite event, where there isn't a target user_id to invite. This event contains a token and a public key whose private key must be used to sign the token. Any user who can present that signature may use this invitation to join the target room.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "RoomTopicContent" : {
        "required" : [ "topic" ],
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "description" : "The topic text"
          }
        },
        "description" : "A topic is a short message detailing what is currently being discussed in the room. It can also be used as a way to display extra information about the room, which may not be suitable for the room name. The room topic can also be set when creating a room using /createRoom with the topic key.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "ServerNotice" : {
        "required" : [ "server_notice_type" ],
        "type" : "object",
        "properties" : {
          "server_notice_type" : {
            "type" : "string",
            "description" : "The type of notice being represented."
          },
          "admin_contact" : {
            "type" : "string",
            "description" : "A URI giving a contact method for the server administrator. Required if the notice type is m.server_notice.usage_limit_reached."
          },
          "limit_type" : {
            "type" : "string",
            "description" : "The kind of usage limit the server has exceeded. Required if the notice type is m.server_notice.usage_limit_reached."
          }
        },
        "description" : "Represents a server notice for a user.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "Signed" : {
        "required" : [ "mxid", "signatures", "token" ],
        "type" : "object",
        "properties" : {
          "mxid" : {
            "type" : "string",
            "description" : "The invited matrix user ID. Must be equal to the user_id property of the event."
          },
          "token" : {
            "type" : "string",
            "description" : "The token property of the containing third_party_invite object."
          },
          "signatures" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "string",
                "description" : "A single signature from the verifying server, in the format specified by the Signing Events section of the server-server API."
              },
              "description" : "A single signature from the verifying server, in the format specified by the Signing Events section of the server-server API."
            },
            "description" : "A single signature from the verifying server, in the format specified by the Signing Events section of the server-server API."
          }
        },
        "description" : "Signed part of the invitation request."
      },
      "StateEvent" : {
        "required" : [ "event_id", "origin_server_ts", "room_id", "sender", "state_key", "type" ],
        "type" : "object",
        "properties" : {
          "sender" : {
            "type" : "string",
            "description" : "Contains the fully-qualified ID of the user who sent this event."
          },
          "unsigned" : {
            "$ref" : "#/components/schemas/UnsignedEventContent"
          },
          "event_id" : {
            "type" : "string",
            "description" : "The globally unique event identifier."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The ID of the room associated with this event."
          },
          "origin_server_ts" : {
            "type" : "integer",
            "description" : "Timestamp in milliseconds on originating homeserver when this event was sent.",
            "format" : "int64"
          },
          "prev_content" : {
            "$ref" : "#/components/schemas/EventContent"
          },
          "state_key" : {
            "type" : "string",
            "description" : " A unique key which defines the overwriting semantics for this piece of room state. This value is often a zero-length string. The presence of this key makes this event a State Event. The key MUST NOT start with '_'."
          }
        },
        "description" : "Event.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/Event"
        } ]
      },
      "StickerContent" : {
        "required" : [ "body", "info", "url" ],
        "type" : "object",
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "A textual representation or associated description of the sticker image. This could be the alt text of the original image, or a message to accompany and further describe the sticker."
          },
          "info" : {
            "$ref" : "#/components/schemas/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the sticker image. This must be a valid mxc:// URI."
          }
        },
        "description" : "This message represents a single sticker image.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "TagContent" : {
        "type" : "object",
        "properties" : {
          "tags" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/TagInfo"
            },
            "description" : "The tags on the room and their contents."
          }
        },
        "description" : "Informs the client of tags on a room.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "TagInfo" : {
        "type" : "object",
        "properties" : {
          "order" : {
            "type" : "integer",
            "description" : "A number in a range [0,1] describing a relative position of the room under the given tag.",
            "format" : "int64"
          }
        },
        "description" : "TagContent info."
      },
      "Text" : {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is the most basic message and is used to represent text.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "ThumbnailInfo" : {
        "type" : "object",
        "properties" : {
          "mimetype" : {
            "type" : "string",
            "description" : "The mimetype of the image, e.g. image/jpeg."
          },
          "size" : {
            "type" : "integer",
            "description" : "Size of the image in bytes.",
            "format" : "int64"
          },
          "h" : {
            "type" : "integer",
            "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          },
          "w" : {
            "type" : "integer",
            "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          }
        },
        "description" : "Thumbnail info."
      },
      "TypingContent" : {
        "required" : [ "user_ids" ],
        "type" : "object",
        "properties" : {
          "user_ids" : {
            "type" : "array",
            "description" : "The list of user IDs typing in this room, if any.",
            "items" : {
              "type" : "string",
              "description" : "The list of user IDs typing in this room, if any."
            }
          }
        },
        "description" : "Informs the client of the list of users currently typing.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/EventContent"
        } ]
      },
      "Unsigned" : {
        "type" : "object",
        "properties" : {
          "age" : {
            "type" : "integer",
            "description" : "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.",
            "format" : "int64"
          },
          "redacted_because" : {
            "$ref" : "#/components/schemas/Event"
          },
          "transaction_id" : {
            "type" : "string",
            "description" : "The client-supplied transaction ID, if the client being given the event is the same one which sent it."
          },
          "prev_content" : {
            "$ref" : "#/components/schemas/EventContent"
          },
          "invite_room_state" : {
            "type" : "array",
            "description" : "This contains an array of StrippedState Events. These events provide information on a subset of state events such as the room name.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Unsigned addition data."
      },
      "UnsignedEventContent" : {
        "type" : "object",
        "properties" : {
          "age" : {
            "type" : "integer",
            "description" : "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.",
            "format" : "int64"
          },
          "redacted_because" : {
            "$ref" : "#/components/schemas/Event"
          },
          "transaction_id" : {
            "type" : "string",
            "description" : "The client-supplied transaction ID, if the client being given the event is the same one which sent it."
          },
          "prev_content" : {
            "$ref" : "#/components/schemas/EventContent"
          },
          "invite_room_state" : {
            "type" : "array",
            "description" : "This contains an array of StrippedState Events. These events provide information on a subset of state events such as the room name.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Unsigned addition data."
      },
      "Video" : {
        "required" : [ "url" ],
        "type" : "object",
        "properties" : {
          "info" : {
            "$ref" : "#/components/schemas/VideoInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the video clip."
          },
          "file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          }
        },
        "description" : "This message represents a single video clip.",
        "allOf" : [ {
          "$ref" : "#/components/schemas/RoomMessageContent"
        } ]
      },
      "VideoInfo" : {
        "type" : "object",
        "properties" : {
          "mimetype" : {
            "type" : "string",
            "description" : "The mimetype of the image, e.g. image/jpeg."
          },
          "size" : {
            "type" : "integer",
            "description" : "Size of the image in bytes.",
            "format" : "int64"
          },
          "duration" : {
            "type" : "integer",
            "description" : "The duration of the video in milliseconds.",
            "format" : "int64"
          },
          "thumbnail_url" : {
            "type" : "string",
            "description" : "The URL to a thumbnail of the image."
          },
          "thumbnail_file" : {
            "$ref" : "#/components/schemas/EncryptedFile"
          },
          "thumbnail_info" : {
            "$ref" : "#/components/schemas/ThumbnailInfo"
          },
          "h" : {
            "type" : "integer",
            "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          },
          "w" : {
            "type" : "integer",
            "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file.",
            "format" : "int64"
          }
        },
        "description" : "Video info."
      },
      "DeprecatedRoomInfo" : {
        "type" : "object",
        "properties" : {
          "membership" : {
            "type" : "string",
            "description" : "The user's membership state in this room."
          },
          "invite" : {
            "$ref" : "#/components/schemas/Event"
          },
          "messages" : {
            "$ref" : "#/components/schemas/PageEvent"
          },
          "state" : {
            "type" : "array",
            "description" : "If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "visibility" : {
            "type" : "string",
            "description" : "Whether this room is visible to the /publicRooms API or not."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The ID of this room."
          },
          "account_data" : {
            "type" : "array",
            "description" : "The private data that this user has attached to this room.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Deprecated room info."
      },
      "PageEvent" : {
        "type" : "object",
        "properties" : {
          "start" : {
            "type" : "string",
            "description" : "The token the pagination starts from. If dir=b this will be the token supplied in from."
          },
          "end" : {
            "type" : "string",
            "description" : "The token the pagination ends at. If dir=b this token should be used again to request even earlier events."
          },
          "chunk" : {
            "type" : "array",
            "description" : "A list of room events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "state" : {
            "type" : "array",
            "description" : "A list of state events relevant to showing the chunk. For example, if lazy_load_members is enabled in the filter then this may contain the membership events for the senders of events in the chunk. Unless include_redundant_members is true, the server may remove membership events which would have already been sent to the client in prior calls to this endpoint, assuming the membership of those members has not changed.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Pagination."
      },
      "DeprecatedInitialSyncResponse" : {
        "type" : "object",
        "properties" : {
          "end" : {
            "type" : "string",
            "description" : "A token which correlates to the last value in chunk. This token should be used with the /events API to listen for new events."
          },
          "presence" : {
            "type" : "array",
            "description" : "A list of presence events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "rooms" : {
            "type" : "array",
            "description" : "Rooms info.",
            "items" : {
              "$ref" : "#/components/schemas/DeprecatedRoomInfo"
            }
          },
          "accountData" : {
            "type" : "array",
            "description" : "The global private data create by this user.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "JSON body response of the deprecated initial sync."
      },
      "Device" : {
        "type" : "object",
        "properties" : {
          "device_id" : {
            "type" : "string",
            "description" : "Identifier of this device."
          },
          "display_name" : {
            "type" : "string",
            "description" : "Display name set by the user for this device. Absent if no name has been set."
          },
          "last_seen_ip" : {
            "type" : "string",
            "description" : "The IP address where this device was last seen. (May be a few minutes out of date, for efficiency reasons)"
          },
          "last_seen_ts" : {
            "type" : "integer",
            "description" : "The timestamp (in milliseconds since the unix epoch) when this devices was last seen. (May be a few minutes out of date, for efficiency reasons).",
            "format" : "int64"
          }
        },
        "description" : "Device"
      },
      "DevicesDeleteRequest" : {
        "type" : "object",
        "properties" : {
          "devices" : {
            "type" : "array",
            "description" : "The list of device IDs to delete.",
            "items" : {
              "type" : "string",
              "description" : "The list of device IDs to delete."
            }
          },
          "auth" : {
            "$ref" : "#/components/schemas/AuthenticationData"
          }
        },
        "description" : "JSON body request for bulk devices delete."
      },
      "DeviceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "display_name" : {
            "type" : "string",
            "description" : "The new display name."
          }
        },
        "description" : "The new display name for this device. If not given, the display name is unchanged."
      },
      "DeviceDeleteRequest" : {
        "type" : "object",
        "properties" : {
          "auth" : {
            "$ref" : "#/components/schemas/AuthenticationData"
          }
        },
        "description" : "Additional authentication information for the user-interactive authentication API."
      },
      "DevicesResponse" : {
        "type" : "object",
        "properties" : {
          "devices" : {
            "type" : "array",
            "description" : "A list of all registered devices for this user.",
            "items" : {
              "$ref" : "#/components/schemas/Device"
            }
          }
        },
        "description" : "Information about all devices for the current user."
      },
      "DeviceKeys" : {
        "type" : "object",
        "properties" : {
          "algorithms" : {
            "type" : "array",
            "description" : "The encryption algorithms supported by this device.",
            "items" : {
              "type" : "string",
              "description" : "The encryption algorithms supported by this device."
            }
          },
          "keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "Public identity keys. The names of the properties should be in the format &lt;algorithm&gt;:&lt;device_id&gt;. The keys themselves should be encoded as specified by the key algorithm."
            },
            "description" : "Public identity keys. The names of the properties should be in the format &lt;algorithm&gt;:&lt;device_id&gt;. The keys themselves should be encoded as specified by the key algorithm."
          },
          "signatures" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "string",
                "description" : "Signatures for the device key object. A map from user ID, to a map from (algorithm):(device_id) to the signature."
              },
              "description" : "Signatures for the device key object. A map from user ID, to a map from (algorithm):(device_id) to the signature."
            },
            "description" : "Signatures for the device key object. A map from user ID, to a map from (algorithm):(device_id) to the signature."
          },
          "unsignedDeviceInfo" : {
            "$ref" : "#/components/schemas/UnsignedDeviceInfo"
          },
          "user_id" : {
            "type" : "string",
            "description" : "The ID of the user the device belongs to. Must match the user ID used when logging in."
          },
          "device_id" : {
            "type" : "string",
            "description" : "The ID of the device these keys belong to. Must match the device ID used when logging in."
          }
        },
        "description" : "Device keys."
      },
      "QueryResponse" : {
        "type" : "object",
        "properties" : {
          "failures" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers."
            },
            "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers."
          },
          "device_keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "$ref" : "#/components/schemas/DeviceKeys"
              },
              "description" : "Information on the queried devices. A map from user ID, to a map from device ID to device information. For each device, the information returned will be the same as uploaded via /keys/upload, with the addition of an unsigned property."
            },
            "description" : "Information on the queried devices. A map from user ID, to a map from device ID to device information. For each device, the information returned will be the same as uploaded via /keys/upload, with the addition of an unsigned property."
          }
        },
        "description" : "Query response."
      },
      "UnsignedDeviceInfo" : {
        "type" : "object",
        "properties" : {
          "device_display_name" : {
            "type" : "string",
            "description" : "The display name which the user set on the device."
          }
        },
        "description" : "Unsigned device info."
      },
      "QueryRequest" : {
        "type" : "object",
        "properties" : {
          "timeout" : {
            "type" : "integer",
            "description" : "The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default.",
            "format" : "int64"
          },
          "token" : {
            "type" : "string",
            "description" : "If the client is fetching keys as a result of a device update received in a sync request, this should be the 'since' token of that sync request, or any later sync token. This allows the server to ensure its response contains the keys advertised by the notification in that sync."
          },
          "device_keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "description" : "The keys to be downloaded. A map from user ID, to a list of device IDs, or to an empty list to indicate all devices for the corresponding user.",
              "items" : {
                "type" : "string",
                "description" : "The keys to be downloaded. A map from user ID, to a list of device IDs, or to an empty list to indicate all devices for the corresponding user."
              }
            },
            "description" : "The keys to be downloaded. A map from user ID, to a list of device IDs, or to an empty list to indicate all devices for the corresponding user."
          }
        },
        "description" : "JSON body parameters for Returns the current devices and identity keys for the given users."
      },
      "ClaimResponse" : {
        "type" : "object",
        "properties" : {
          "failures" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers."
            },
            "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers."
          },
          "one_time_keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object",
                "description" : "One-time keys for the queried devices. A map from user ID, to a map from &lt;algorithm&gt;:&lt;key_id&gt; to the key object."
              },
              "description" : "One-time keys for the queried devices. A map from user ID, to a map from &lt;algorithm&gt;:&lt;key_id&gt; to the key object."
            },
            "description" : "One-time keys for the queried devices. A map from user ID, to a map from &lt;algorithm&gt;:&lt;key_id&gt; to the key object."
          }
        },
        "description" : "Claim response format."
      },
      "ClaimRequest" : {
        "type" : "object",
        "properties" : {
          "timeout" : {
            "type" : "integer",
            "description" : "The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default.",
            "format" : "int64"
          },
          "one_time_keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "string",
                "description" : "The keys to be claimed. A map from user ID, to a map from device ID to algorithm name."
              },
              "description" : "The keys to be claimed. A map from user ID, to a map from device ID to algorithm name."
            },
            "description" : "The keys to be claimed. A map from user ID, to a map from device ID to algorithm name."
          }
        },
        "description" : "JSON body parameters for Claims one-time keys for use in pre-key messages."
      },
      "UploadResponse" : {
        "type" : "object",
        "properties" : {
          "one_time_key_counts" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "description" : "For each key algorithm, the number of unclaimed one-time keys of that type currently held on the server for this device.",
              "format" : "int64"
            },
            "description" : "For each key algorithm, the number of unclaimed one-time keys of that type currently held on the server for this device."
          }
        },
        "description" : "Response format."
      },
      "UploadRequest" : {
        "type" : "object",
        "properties" : {
          "device_keys" : {
            "$ref" : "#/components/schemas/DeviceKeys"
          },
          "one_time_keys" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "description" : "One-time public keys for \"pre-key\" messages. The names of the properties should be in the format (algorithm):(key_id). The format of the key is determined by the key algorithm."
            },
            "description" : "One-time public keys for \"pre-key\" messages. The names of the properties should be in the format (algorithm):(key_id). The format of the key is determined by the key algorithm."
          }
        },
        "description" : "JSON body parameters for Publishes end-to-end encryption keys for the device."
      },
      "ChangesResponse" : {
        "type" : "object",
        "properties" : {
          "changed" : {
            "type" : "array",
            "description" : "The Matrix User IDs of all users who updated their device identity keys.",
            "items" : {
              "type" : "string",
              "description" : "The Matrix User IDs of all users who updated their device identity keys."
            }
          },
          "left" : {
            "type" : "array",
            "description" : "The Matrix User IDs of all users who may have left all the end-to-end encrypted rooms they previously shared with the user.",
            "items" : {
              "type" : "string",
              "description" : "The Matrix User IDs of all users who may have left all the end-to-end encrypted rooms they previously shared with the user."
            }
          }
        },
        "description" : "The list of users who updated their devices."
      },
      "MembersResponse" : {
        "type" : "object",
        "properties" : {
          "chunk" : {
            "type" : "array",
            "description" : "Member events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "The list of members for this room."
      },
      "Page" : {
        "type" : "object",
        "properties" : {
          "start" : {
            "type" : "string",
            "description" : "The token the pagination starts from. If dir=b this will be the token supplied in from."
          },
          "end" : {
            "type" : "string",
            "description" : "The token the pagination ends at. If dir=b this token should be used again to request even earlier events."
          },
          "chunk" : {
            "type" : "array",
            "description" : "A list of room events.",
            "items" : {
              "type" : "object",
              "description" : "A list of room events."
            }
          },
          "state" : {
            "type" : "array",
            "description" : "A list of state events relevant to showing the chunk. For example, if lazy_load_members is enabled in the filter then this may contain the membership events for the senders of events in the chunk. Unless include_redundant_members is true, the server may remove membership events which would have already been sent to the client in prior calls to this endpoint, assuming the membership of those members has not changed.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Pagination."
      },
      "JoinedMembersResponse" : {
        "type" : "object",
        "properties" : {
          "joined" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoomMember"
            },
            "description" : "A map from user ID to a RoomMemberContent object."
          }
        },
        "description" : "Joined room members."
      },
      "RoomMember" : {
        "type" : "object",
        "properties" : {
          "display_name" : {
            "type" : "string",
            "description" : "The display name of the user this object is representing."
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The mxc avatar url of the user this object is representing."
          }
        },
        "description" : "Room member."
      },
      "SendEventResponse" : {
        "type" : "object",
        "properties" : {
          "event_id" : {
            "type" : "string",
            "description" : "A unique identifier for the event."
          }
        },
        "description" : "Sent event."
      },
      "RedactRequest" : {
        "type" : "object",
        "properties" : {
          "reason" : {
            "type" : "string",
            "description" : "The reason for the event being redacted."
          }
        },
        "description" : "Request for the redaction."
      },
      "EventContextResponse" : {
        "type" : "object",
        "properties" : {
          "start" : {
            "type" : "string",
            "description" : "A token that can be used to paginate backwards with."
          },
          "end" : {
            "type" : "string",
            "description" : "A token that can be used to paginate forwards with."
          },
          "event" : {
            "$ref" : "#/components/schemas/Event"
          },
          "state" : {
            "$ref" : "#/components/schemas/Event"
          },
          "events_before" : {
            "type" : "array",
            "description" : "A list of room events that happened just before the requested event, in reverse-chronological order.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "events_after" : {
            "type" : "array",
            "description" : "A list of room events that happened just after the requested event, in chronological order.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Events that happened just before and after the specified event."
      },
      "EventFilter" : {
        "type" : "object",
        "properties" : {
          "limit" : {
            "type" : "integer",
            "description" : "The maximum number of events to return.",
            "format" : "int64"
          },
          "senders" : {
            "type" : "array",
            "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
            "items" : {
              "type" : "string",
              "description" : "A list of senders IDs to include. If this list is absent then all senders are included."
            }
          },
          "types" : {
            "type" : "array",
            "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
            }
          },
          "not_senders" : {
            "type" : "array",
            "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
            "items" : {
              "type" : "string",
              "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
            }
          },
          "not_types" : {
            "type" : "array",
            "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters."
            }
          }
        },
        "description" : "Filter."
      },
      "FilterData" : {
        "type" : "object",
        "properties" : {
          "presence" : {
            "$ref" : "#/components/schemas/EventFilter"
          },
          "room" : {
            "$ref" : "#/components/schemas/RoomFilter"
          },
          "event_fields" : {
            "type" : "array",
            "description" : "List of event fields to include. If this list is absent then all fields are included. The entries may include '.' charaters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a ''. A server may include more fields than were requested.",
            "items" : {
              "type" : "string",
              "description" : "List of event fields to include. If this list is absent then all fields are included. The entries may include '.' charaters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a ''. A server may include more fields than were requested."
            }
          },
          "event_format" : {
            "type" : "string",
            "description" : "The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as receieved over federation. The default is 'client'."
          },
          "account_data" : {
            "$ref" : "#/components/schemas/EventFilter"
          }
        },
        "description" : "JSON body request for filter api."
      },
      "RoomEventFilter" : {
        "type" : "object",
        "properties" : {
          "limit" : {
            "type" : "integer",
            "description" : "The maximum number of events to return.",
            "format" : "int64"
          },
          "senders" : {
            "type" : "array",
            "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
            "items" : {
              "type" : "string",
              "description" : "A list of senders IDs to include. If this list is absent then all senders are included."
            }
          },
          "types" : {
            "type" : "array",
            "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
            }
          },
          "rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to include. If this list is absent then all rooms are included.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to include. If this list is absent then all rooms are included."
            }
          },
          "not_senders" : {
            "type" : "array",
            "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
            "items" : {
              "type" : "string",
              "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
            }
          },
          "not_types" : {
            "type" : "array",
            "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters."
            }
          },
          "lazy_load_members" : {
            "type" : "boolean",
            "description" : "If true, the only m.room.member events returned in the state section of the /sync response are those which are definitely necessary for a client to display the sender of the timeline events in that response. If false, m.room.member events are not filtered. By default, servers should suppress duplicate redundant lazy-loaded m.room.member events from being sent to a given client across multiple calls to /sync, given that most clients cache membership events (see include_redundant_members to change this behaviour)."
          },
          "include_redundant_members" : {
            "type" : "boolean",
            "description" : "If true, the state section of the /sync response will always contain the m.room.member events required to display the sender of the timeline events in that response, assuming lazy_load_members is enabled. This means that redundant duplicate member events may be returned across multiple calls to /sync. This is useful for naive clients who never track membership data. If false, duplicate m.room.member events may be suppressed by the server across multiple calls to /sync. If lazy_load_members is false this field is ignored."
          },
          "not_rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
            }
          },
          "contains_url" : {
            "type" : "boolean",
            "description" : "If true, includes only events with a url key in their content. If false, excludes those events."
          }
        },
        "description" : "Room event filter."
      },
      "RoomFilter" : {
        "type" : "object",
        "properties" : {
          "rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ephemeral, state, timeline or account_data.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ephemeral, state, timeline or account_data."
            }
          },
          "ephemeral" : {
            "$ref" : "#/components/schemas/RoomEventFilter"
          },
          "state" : {
            "$ref" : "#/components/schemas/RoomEventFilter"
          },
          "timeline" : {
            "$ref" : "#/components/schemas/RoomEventFilter"
          },
          "not_rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter. This filter is applied before the filters in ephemeral, state, timeline or account_data.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter. This filter is applied before the filters in ephemeral, state, timeline or account_data."
            }
          },
          "include_leave" : {
            "type" : "boolean",
            "description" : "Include rooms that the user has left in the sync, default false."
          },
          "account_data" : {
            "$ref" : "#/components/schemas/RoomEventFilter"
          }
        },
        "description" : "Room filter."
      },
      "FilterResponse" : {
        "type" : "object",
        "properties" : {
          "filter_id" : {
            "type" : "string",
            "description" : "The ID of the filter that was created. Cannot start with a { as this character is used to determine if the filter provided is inline JSON or a previously declared filter by homeservers on some APIs."
          }
        },
        "description" : "JSON body response."
      },
      "OpenIdResponse" : {
        "type" : "object",
        "properties" : {
          "access_token" : {
            "type" : "string",
            "description" : "An access token the consumer may use to verify the identity of the person who generated the token. This is given to the federation API GET /openid/userinfo."
          },
          "token_type" : {
            "type" : "string",
            "description" : "The string Bearer."
          },
          "matrix_server_name" : {
            "type" : "string",
            "description" : "The homeserver domain the consumer should use when attempting to verify the user's identity."
          },
          "expires_in" : {
            "type" : "integer",
            "description" : "The number of seconds before this token expires and a new one must be generated.",
            "format" : "int64"
          }
        },
        "description" : "JSON body response of the OpenID API."
      },
      "PresenceRequest" : {
        "type" : "object",
        "properties" : {
          "presence" : {
            "type" : "string",
            "description" : "The new presence state."
          },
          "status_msg" : {
            "type" : "string",
            "description" : "The status message to attach to this state."
          }
        },
        "description" : "JSON body request for presence api."
      },
      "PresenceStatus" : {
        "type" : "object",
        "properties" : {
          "presence" : {
            "type" : "string",
            "description" : "The new presence state."
          },
          "status_msg" : {
            "type" : "string",
            "description" : "The status message to attach to this state."
          },
          "last_active_ago" : {
            "type" : "integer",
            "description" : "The length of time in milliseconds since an action was performed by this user.",
            "format" : "int64"
          },
          "currently_active" : {
            "type" : "boolean",
            "description" : "Whether the user is currently active."
          }
        },
        "description" : "JSON body request for presence api."
      },
      "Profile" : {
        "type" : "object",
        "properties" : {
          "avatar_url" : {
            "type" : "string",
            "description" : "The user's avatar URL if they have set one, otherwise not present."
          },
          "display_name" : {
            "type" : "string",
            "description" : "The user's display name if they have set one, otherwise not present."
          }
        },
        "description" : "JSON body for profile api (profile)."
      },
      "DisplayName" : {
        "type" : "object",
        "properties" : {
          "displayname" : {
            "type" : "string",
            "description" : "The new display name for this user."
          }
        },
        "description" : "JSON body request for profile api."
      },
      "AvatarUrl" : {
        "type" : "object",
        "properties" : {
          "avatar_url" : {
            "type" : "string",
            "description" : "The new avatar URL for this user."
          }
        },
        "description" : "JSON body request for profile api."
      },
      "PushActions" : {
        "type" : "object",
        "properties" : {
          "actions" : {
            "type" : "array",
            "description" : "The action(s) to perform for this rule.",
            "items" : {
              "type" : "string",
              "description" : "The action(s) to perform for this rule."
            }
          }
        },
        "description" : "JSON body request/response for action push api."
      },
      "PushEnable" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean",
            "description" : "Whether the push rule is enabled or not."
          }
        },
        "description" : "JSON body request/response for enable/disable push api."
      },
      "Pusher" : {
        "type" : "object",
        "properties" : {
          "pushkey" : {
            "type" : "string",
            "description" : "This is a unique identifier for this pusher. See /set for more detail. Max length, 512 bytes."
          },
          "kind" : {
            "type" : "string",
            "description" : "The kind of pusher. \"http\" is a pusher that sends HTTP pokes."
          },
          "lang" : {
            "type" : "string",
            "description" : "The preferred language for receiving notifications (e.g. 'en' or 'en-US')"
          },
          "data" : {
            "$ref" : "#/components/schemas/PusherData"
          },
          "app_id" : {
            "type" : "string",
            "description" : "This is a reverse-DNS style identifier for the application. Max length, 64 chars."
          },
          "app_display_name" : {
            "type" : "string",
            "description" : "A string that will allow the user to identify what application owns this pusher."
          },
          "device_display_name" : {
            "type" : "string",
            "description" : "A string that will allow the user to identify what device owns this pusher."
          },
          "profile_tag" : {
            "type" : "string",
            "description" : "This string determines which set of device specific rules this pusher executes."
          }
        },
        "description" : "Pusher. A pusher is a worker on the homeserver that manages the sending of HTTP notifications for a user. A user can have multiple pushers: one per device."
      },
      "PusherData" : {
        "type" : "object",
        "properties" : {
          "url" : {
            "type" : "string",
            "description" : "Required if kind is http. The URL to use to send notifications to."
          },
          "format" : {
            "type" : "string",
            "description" : "The format to use when sending notifications to the Push Gateway."
          }
        },
        "description" : "Pusher data."
      },
      "PushersResponse" : {
        "type" : "object",
        "properties" : {
          "pushers" : {
            "type" : "array",
            "description" : "An array containing the current pushers for the user.",
            "items" : {
              "$ref" : "#/components/schemas/Pusher"
            }
          }
        },
        "description" : "Pusher list."
      },
      "PushersRequest" : {
        "type" : "object",
        "properties" : {
          "pushkey" : {
            "type" : "string",
            "description" : "This is a unique identifier for this pusher. See /set for more detail. Max length, 512 bytes."
          },
          "kind" : {
            "type" : "string",
            "description" : "The kind of pusher. \"http\" is a pusher that sends HTTP pokes."
          },
          "lang" : {
            "type" : "string",
            "description" : "The preferred language for receiving notifications (e.g. 'en' or 'en-US')"
          },
          "data" : {
            "$ref" : "#/components/schemas/PusherData"
          },
          "append" : {
            "type" : "boolean",
            "description" : "If true, the homeserver should add another pusher with the given pushkey and App ID in addition to any others with different user IDs. Otherwise, the homeserver must remove any other pushers with the same App ID and pushkey for different users. The default is false."
          },
          "app_id" : {
            "type" : "string",
            "description" : "This is a reverse-DNS style identifier for the application. Max length, 64 chars."
          },
          "app_display_name" : {
            "type" : "string",
            "description" : "A string that will allow the user to identify what application owns this pusher."
          },
          "device_display_name" : {
            "type" : "string",
            "description" : "A string that will allow the user to identify what device owns this pusher."
          },
          "profile_tag" : {
            "type" : "string",
            "description" : "This string determines which set of device specific rules this pusher executes."
          }
        },
        "description" : "JSON body request to create a new pusher."
      },
      "PushCondition" : {
        "required" : [ "kind" ],
        "type" : "object",
        "properties" : {
          "kind" : {
            "type" : "string",
            "enum" : [ "event_match, contains_display_name, room_member_count]" ]
          },
          "key" : {
            "type" : "string",
            "description" : "Required for event_match conditions. The dot- separated field of the event to match."
          },
          "pattern" : {
            "type" : "string",
            "description" : "Required for event_match conditions. The glob- style pattern to match against. Patterns with no special glob characters should be treated as having asterisks prepended and appended when testing the condition."
          },
          "is" : {
            "type" : "string",
            "description" : "Required for room_member_count conditions. A decimal integer optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches rooms where the member count is strictly less than the given number and so forth. If no prefix is present, this parameter defaults to==."
          }
        },
        "description" : "Push condition."
      },
      "PushRule" : {
        "type" : "object",
        "properties" : {
          "actions" : {
            "type" : "array",
            "description" : "The actions to perform when this rule is matched.",
            "items" : {
              "type" : "object",
              "description" : "The actions to perform when this rule is matched."
            }
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "Whether the push rule is enabled or not."
          },
          "conditions" : {
            "type" : "array",
            "description" : "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushCondition"
            }
          },
          "pattern" : {
            "type" : "string",
            "description" : "The glob-style pattern to match against. Only applicable to content rules."
          },
          "default" : {
            "type" : "boolean",
            "description" : "Whether this is a default rule, or has been set explicitly."
          },
          "rule_id" : {
            "type" : "string",
            "description" : "The ID of this rule."
          }
        },
        "description" : "Push rule."
      },
      "PushRulesResponse" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Ruleset"
          }
        },
        "description" : "JSON body response for push api."
      },
      "Ruleset" : {
        "type" : "object",
        "properties" : {
          "content" : {
            "type" : "array",
            "description" : "Content rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushRule"
            }
          },
          "override" : {
            "type" : "array",
            "description" : "Override rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushRule"
            }
          },
          "room" : {
            "type" : "array",
            "description" : "Room rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushRule"
            }
          },
          "sender" : {
            "type" : "array",
            "description" : "Sender rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushRule"
            }
          },
          "underride" : {
            "type" : "array",
            "description" : "Underride rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushRule"
            }
          }
        },
        "description" : "Ruleset."
      },
      "PushUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "actions" : {
            "type" : "array",
            "description" : "The action(s) to perform when the conditions for this rule are met.",
            "items" : {
              "type" : "string",
              "description" : "The action(s) to perform when the conditions for this rule are met."
            }
          },
          "conditions" : {
            "type" : "array",
            "description" : "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules.",
            "items" : {
              "$ref" : "#/components/schemas/PushCondition"
            }
          },
          "pattern" : {
            "type" : "string",
            "description" : "Only applicable to content rules. The glob- style pattern to match against."
          }
        },
        "description" : "JSON body request for push update api."
      },
      "Notification" : {
        "type" : "object",
        "properties" : {
          "actions" : {
            "type" : "array",
            "description" : "The action(s) to perform when the conditions for this rule are met. See Push Rules: API.",
            "items" : {
              "type" : "object",
              "description" : "The action(s) to perform when the conditions for this rule are met. See Push Rules: API."
            }
          },
          "event" : {
            "$ref" : "#/components/schemas/Event"
          },
          "read" : {
            "type" : "boolean",
            "description" : "Indicates whether the user has sent a read receipt indicating that they have read this message."
          },
          "ts" : {
            "type" : "integer",
            "description" : "The unix timestamp at which the event notification was sent, in milliseconds.",
            "format" : "int64"
          },
          "profile_tag" : {
            "type" : "string",
            "description" : "The profile tag of the rule that matched this event."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The ID of the room in which the event was posted."
          }
        },
        "description" : "Notification"
      },
      "NotificationResponse" : {
        "type" : "object",
        "properties" : {
          "notifications" : {
            "type" : "array",
            "description" : "The list of events that triggered notifications.",
            "items" : {
              "$ref" : "#/components/schemas/Notification"
            }
          },
          "next_token" : {
            "type" : "string",
            "description" : "The token to supply in the from param of the next /notifications request in order to request more events. If this is absent, there are no more results."
          }
        },
        "description" : "JSON body response for push notifications."
      },
      "ReadMarkersRequest" : {
        "type" : "object",
        "properties" : {
          "m.fully_read" : {
            "type" : "string",
            "description" : "The event ID the read marker should be located at. The event MUST belong to the room."
          },
          "m.read" : {
            "type" : "string",
            "description" : "The event ID to set the read receipt location at. This is equivalent to calling /receipt/m.read/$elsewhere:domain.com and is provided here to save that extra call."
          }
        },
        "description" : "JSON body of the read marker request."
      },
      "ReportRequest" : {
        "type" : "object",
        "properties" : {
          "score" : {
            "type" : "integer",
            "description" : "The score to rate this content as where -100 is most offensive and 0 is inoffensive.",
            "format" : "int32"
          },
          "reason" : {
            "type" : "string",
            "description" : "The reason the content is being reported. May be blank."
          }
        },
        "description" : "JSON Body for report request."
      },
      "RoomId" : {
        "type" : "object",
        "properties" : {
          "room_id" : {
            "type" : "string",
            "description" : "The created room's ID."
          }
        },
        "description" : "JSON body with roomId used in the room apis."
      },
      "CreateRoomRequest" : {
        "type" : "object",
        "properties" : {
          "visibility" : {
            "type" : "string",
            "description" : "A public visibility indicates that the room will be shown in the published room list. A private visibility will hide the room from the published room list. Rooms default to private visibility if this key is not included. NB: This should not be confused with join_rules which also uses the word public.",
            "enum" : [ "public", "private" ]
          },
          "name" : {
            "type" : "string",
            "description" : "If this is included, an m.room.name event will be sent into the room to indicate the name of the room. See Room Events for more information on m.room.name."
          },
          "topic" : {
            "type" : "string",
            "description" : "If this is included, an m.room.topic event will be sent into the room to indicate the topic for the room. See Room Events for more information on m.room.topic."
          },
          "invite" : {
            "type" : "array",
            "description" : "A list of user IDs to invite to the room. This will tell the server to invite everyone in the list to the newly created room.",
            "items" : {
              "type" : "string",
              "description" : "A list of user IDs to invite to the room. This will tell the server to invite everyone in the list to the newly created room."
            }
          },
          "preset" : {
            "type" : "string",
            "description" : "Convenience parameter for setting various default state events based on a preset."
          },
          "room_alias_name" : {
            "type" : "string",
            "description" : "The desired room alias local part. If this is included, a room alias will be created and mapped to the newly created room. The alias will belong on the same homeserver which created the room. For example, if this was set to \"foo\" and sent to the homeserver \"example.com\". The complete room alias would be #foo:example.com."
          },
          "invite_3pid" : {
            "type" : "array",
            "description" : "A list of objects representing third party IDs to invite into the room.",
            "items" : {
              "$ref" : "#/components/schemas/Invite3pid"
            }
          },
          "room_version" : {
            "type" : "string",
            "description" : "The room version to set for the room. If not provided, the homeserver is to use its configured default. If provided, the homeserver will return a 400 error with the errcode M_UNSUPPORTED_ROOM_VERSION if it does not support the room version."
          },
          "creation_content" : {
            "$ref" : "#/components/schemas/RoomCreateContent"
          },
          "initial_event" : {
            "type" : "array",
            "description" : "A list of state events to set in the new room. This allows the user to override the default state events set in the new room. The expected format of the state events are an object with type, state_key and content keys set.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "is_direct" : {
            "type" : "boolean",
            "description" : "This flag makes the server set the is_direct flag on the m.room.member events sent to the users in invite and invite_3pid. See DirectContent Messaging for more information."
          },
          "power_level_content_override" : {
            "$ref" : "#/components/schemas/RoomPowerLevelsContent"
          }
        },
        "description" : "JSON body request for creation api."
      },
      "Invite3pid" : {
        "type" : "object",
        "properties" : {
          "medium" : {
            "type" : "string",
            "description" : "The kind of address being passed in the address field, for example email."
          },
          "address" : {
            "type" : "string",
            "description" : "The invitee's third party identifier."
          },
          "id_server" : {
            "type" : "string",
            "description" : "The hostname+port of the identity server which should be used for third party identifier lookups."
          }
        },
        "description" : "Invite 3pid."
      },
      "ReplacementRoom" : {
        "required" : [ "replacement_room" ],
        "type" : "object",
        "properties" : {
          "replacement_room" : {
            "type" : "string",
            "description" : "The ID of the new room."
          }
        },
        "description" : "The ID of the new room."
      },
      "NewVersion" : {
        "required" : [ "new_version" ],
        "type" : "object",
        "properties" : {
          "new_version" : {
            "type" : "string",
            "description" : "The new version for the room."
          }
        },
        "description" : "The new version for the room."
      },
      "RoomVisibility" : {
        "type" : "object",
        "properties" : {
          "visibility" : {
            "type" : "string",
            "description" : "The visibility of the room in the directory."
          }
        },
        "description" : "JSON body request and response for listing room api."
      },
      "InviteRequest" : {
        "type" : "object",
        "properties" : {
          "medium" : {
            "type" : "string",
            "description" : "The kind of address being passed in the address field, for example email."
          },
          "address" : {
            "type" : "string",
            "description" : "The invitee's third party identifier."
          },
          "user_id" : {
            "type" : "string",
            "description" : "The fully qualified user ID of the invitee."
          },
          "id_server" : {
            "type" : "string",
            "description" : "The hostname+port of the identity server which should be used for third party identifier lookups."
          }
        },
        "description" : "Invite request."
      },
      "KickRequest" : {
        "type" : "object",
        "properties" : {
          "reason" : {
            "type" : "string",
            "description" : "The reason the user has been kicked."
          },
          "user_id" : {
            "type" : "string",
            "description" : "The fully qualified user ID of the user being kicked."
          }
        },
        "description" : "Kick JSON body request."
      },
      "RoomResolveResponse" : {
        "type" : "object",
        "properties" : {
          "servers" : {
            "type" : "array",
            "description" : "A list of servers that are aware of this room alias.",
            "items" : {
              "type" : "string",
              "description" : "A list of servers that are aware of this room alias."
            }
          },
          "room_id" : {
            "type" : "string",
            "description" : "The created room's ID."
          }
        },
        "description" : "JSON body response of the room response api."
      },
      "UnbanRequest" : {
        "type" : "object",
        "properties" : {
          "user_id" : {
            "type" : "string",
            "description" : "The fully qualified user ID of the user being unbanned."
          }
        },
        "description" : "Unban JSON body request."
      },
      "PublicRoomsChunk" : {
        "type" : "object",
        "properties" : {
          "aliases" : {
            "type" : "array",
            "description" : "Aliases of the room. May be empty.",
            "items" : {
              "type" : "string",
              "description" : "Aliases of the room. May be empty."
            }
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the room, if any."
          },
          "topic" : {
            "type" : "string",
            "description" : "The topic of the room, if any."
          },
          "canonical_alias" : {
            "type" : "string",
            "description" : "The canonical alias of the room, if any."
          },
          "num_joined_members" : {
            "type" : "integer",
            "description" : "The number of members joined to the room.",
            "format" : "int64"
          },
          "room_id" : {
            "type" : "string",
            "description" : "The ID of the room."
          },
          "world_readable" : {
            "type" : "boolean",
            "description" : "Whether the room may be viewed by guest users without joining."
          },
          "guest_can_join" : {
            "type" : "boolean",
            "description" : "Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user."
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The URL for the room's avatar, if one is set."
          }
        },
        "description" : "Public rooms chunk."
      },
      "PublicRoomsResponse" : {
        "type" : "object",
        "properties" : {
          "chunk" : {
            "type" : "array",
            "description" : "A paginated chunk of public rooms.",
            "items" : {
              "$ref" : "#/components/schemas/PublicRoomsChunk"
            }
          },
          "next_batch" : {
            "type" : "string",
            "description" : "A pagination token for the response. The absence of this token means there are no more results to fetch and the client should stop paginating."
          },
          "prev_batch" : {
            "type" : "string",
            "description" : "A pagination token that allows fetching previous results. The absence of this token means there are no results before this batch, i.e. this is the first batch."
          },
          "total_room_count_estimate" : {
            "type" : "integer",
            "description" : "An estimate on the total number of public rooms, if the server has an estimate.",
            "format" : "int64"
          }
        },
        "description" : "JSON body request."
      },
      "PublicRoomsFilter" : {
        "type" : "object",
        "properties" : {
          "generic_search_term" : {
            "type" : "string",
            "description" : "A string to search for in the room metadata, e.g. name, topic, canonical alias etc. (Optional)."
          }
        },
        "description" : "Search filter."
      },
      "PublicRoomsRequest" : {
        "type" : "object",
        "properties" : {
          "limit" : {
            "type" : "integer",
            "description" : "Limit the number of results returned.",
            "format" : "int64"
          },
          "since" : {
            "type" : "string",
            "description" : "A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag."
          },
          "filter" : {
            "$ref" : "#/components/schemas/PublicRoomsFilter"
          },
          "include_all_networkd" : {
            "type" : "boolean",
            "description" : "Whether or not to include all known networks/protocols from application services on the homeserver.",
            "default" : false
          },
          "third_party_instance_id" : {
            "type" : "string",
            "description" : "The specific third party network/protocol to request from the homeserver. Can only be used if include_all_networks is false."
          }
        },
        "description" : "JSON body request."
      },
      "JoinedRoomsResponse" : {
        "type" : "object",
        "properties" : {
          "joined_rooms" : {
            "type" : "array",
            "description" : "The ID of each room in which the user has joined membership.",
            "items" : {
              "type" : "string",
              "description" : "The ID of each room in which the user has joined membership."
            }
          }
        },
        "description" : "JSON body resposnse with joined rooms."
      },
      "JoinRequest" : {
        "type" : "object",
        "properties" : {
          "third_party_signed" : {
            "$ref" : "#/components/schemas/ThirdPartySigned"
          }
        },
        "description" : "Join request."
      },
      "ThirdPartySigned" : {
        "type" : "object",
        "properties" : {
          "sender" : {
            "type" : "string",
            "description" : "The Matrix ID of the user who issued the invite."
          },
          "mxid" : {
            "type" : "string",
            "description" : "The Matrix ID of the invitee."
          },
          "token" : {
            "type" : "string",
            "description" : "The state key of the m.third_party_invite event."
          },
          "signatures" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "string",
                "description" : "A signatures object containing a signature of the entire signed object."
              },
              "description" : "A signatures object containing a signature of the entire signed object."
            },
            "description" : "A signatures object containing a signature of the entire signed object."
          }
        },
        "description" : "Third party signed."
      },
      "EventContext" : {
        "type" : "object",
        "properties" : {
          "before_limit" : {
            "type" : "integer",
            "description" : "How many events before the result are returned.",
            "format" : "int64"
          },
          "after_limit" : {
            "type" : "integer",
            "description" : "How many events after the result are returned.",
            "format" : "int64"
          },
          "include_profile" : {
            "type" : "boolean",
            "description" : "Requests that the server returns the historic profile information for the users that sent the events that were returned."
          }
        },
        "description" : "Event context."
      },
      "Filter" : {
        "type" : "object",
        "properties" : {
          "limit" : {
            "type" : "integer",
            "description" : "The maximum number of events to return.",
            "format" : "int64"
          },
          "senders" : {
            "type" : "array",
            "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
            "items" : {
              "type" : "string",
              "description" : "A list of senders IDs to include. If this list is absent then all senders are included."
            }
          },
          "types" : {
            "type" : "array",
            "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
            }
          },
          "rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to include. If this list is absent then all rooms are included.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to include. If this list is absent then all rooms are included."
            }
          },
          "not_senders" : {
            "type" : "array",
            "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
            "items" : {
              "type" : "string",
              "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
            }
          },
          "not_types" : {
            "type" : "array",
            "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
            "items" : {
              "type" : "string",
              "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters."
            }
          },
          "lazy_load_members" : {
            "type" : "boolean",
            "description" : "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information.",
            "default" : false
          },
          "include_redundant_members" : {
            "type" : "boolean",
            "description" : "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy- loading room members for more information.",
            "default" : false
          },
          "not_rooms" : {
            "type" : "array",
            "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter.",
            "items" : {
              "type" : "string",
              "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
            }
          },
          "contains_url" : {
            "type" : "boolean",
            "description" : "If true, includes only events with a url key in their content. If false, excludes those events. Defaults to false."
          }
        },
        "description" : "Filter."
      },
      "Group" : {
        "type" : "object",
        "properties" : {
          "key" : {
            "type" : "string",
            "description" : "Key that defines the group."
          }
        },
        "description" : "Group."
      },
      "Groupings" : {
        "type" : "object",
        "properties" : {
          "group_by" : {
            "type" : "array",
            "description" : "List of groups to request.",
            "items" : {
              "$ref" : "#/components/schemas/Group"
            }
          }
        },
        "description" : "Groupings."
      },
      "RequestCategories" : {
        "type" : "object",
        "properties" : {
          "room_events" : {
            "$ref" : "#/components/schemas/RoomEventsCriteria"
          }
        },
        "description" : "Categories."
      },
      "RoomEventsCriteria" : {
        "type" : "object",
        "properties" : {
          "keys" : {
            "type" : "array",
            "description" : "The keys to search.",
            "items" : {
              "type" : "string",
              "description" : "The keys to search."
            }
          },
          "filter" : {
            "$ref" : "#/components/schemas/Filter"
          },
          "groupings" : {
            "$ref" : "#/components/schemas/Groupings"
          },
          "search_term" : {
            "type" : "string",
            "description" : "The string to search events for."
          },
          "order_by" : {
            "type" : "string",
            "description" : "The order in which to search for results."
          },
          "event_context" : {
            "$ref" : "#/components/schemas/EventContext"
          },
          "include_state" : {
            "type" : "boolean",
            "description" : "Requests the server return the current state for each room returned."
          }
        },
        "description" : "Room events."
      },
      "SearchRequest" : {
        "type" : "object",
        "properties" : {
          "limit" : {
            "type" : "integer",
            "description" : "The maximum number of results to return (Defaults to 10).",
            "format" : "int64"
          },
          "search_term" : {
            "type" : "string",
            "description" : "The term to search for."
          }
        },
        "description" : "JSON body request for user directory api (search)."
      },
      "SendToDeviceRequest" : {
        "type" : "object",
        "properties" : {
          "messages" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "$ref" : "#/components/schemas/EventContent"
              },
              "description" : "The messages to send. A map from user ID, to a map from device ID to message body. The device ID may also be *, meaning all known devices for the user."
            },
            "description" : "The messages to send. A map from user ID, to a map from device ID to message body. The device ID may also be *, meaning all known devices for the user."
          }
        },
        "description" : "Sent to device body request."
      },
      "AccountData" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Account data."
      },
      "DeviceLists" : {
        "type" : "object",
        "properties" : {
          "changed" : {
            "type" : "array",
            "description" : "List of users who have updated their device identity keys since the previous sync response.",
            "items" : {
              "type" : "string",
              "description" : "List of users who have updated their device identity keys since the previous sync response."
            }
          },
          "left" : {
            "type" : "array",
            "description" : "List of users with whom we do not share any encrypted rooms anymore since the previous sync response.",
            "items" : {
              "type" : "string",
              "description" : "List of users with whom we do not share any encrypted rooms anymore since the previous sync response."
            }
          }
        },
        "description" : "Device lists."
      },
      "Ephemeral" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Ephemeral."
      },
      "InviteState" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "Invite state."
      },
      "InvitedRoom" : {
        "type" : "object",
        "properties" : {
          "invite_state" : {
            "$ref" : "#/components/schemas/InviteState"
          }
        },
        "description" : "Invite room."
      },
      "JoinedRoom" : {
        "type" : "object",
        "properties" : {
          "summary" : {
            "$ref" : "#/components/schemas/RoomSummary"
          },
          "state" : {
            "$ref" : "#/components/schemas/State"
          },
          "timeline" : {
            "$ref" : "#/components/schemas/Timeline"
          },
          "ephemeral" : {
            "$ref" : "#/components/schemas/Ephemeral"
          },
          "account_data" : {
            "$ref" : "#/components/schemas/AccountData"
          },
          "unread_notifications" : {
            "$ref" : "#/components/schemas/UnreadNotificationCounts"
          }
        },
        "description" : "Joined room."
      },
      "LeftRoom" : {
        "type" : "object",
        "properties" : {
          "state" : {
            "$ref" : "#/components/schemas/State"
          },
          "timeline" : {
            "$ref" : "#/components/schemas/Timeline"
          },
          "account_data" : {
            "$ref" : "#/components/schemas/AccountData"
          }
        },
        "description" : "Left room."
      },
      "Presence" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "PresenceContent."
      },
      "RoomSummary" : {
        "type" : "object",
        "properties" : {
          "m.heroes" : {
            "type" : "array",
            "description" : "The users which can be used to generate a room name if the room does not have one. Required if the room's m.room.name or m.room.canonical_alias state events are unset or empty. This should be the first 5 members of the room, ordered by stream ordering, which are joined or invited. The list must never include the client's own user ID. When no joined or invited members are available, this should consist of the banned and left users. More than 5 members may be provided, however less than 5 should only be provided when there are less than 5 members to represent. When lazy-loading room members is enabled, the membership events for the heroes MUST be included in the state, unless they are redundant. When the list of users changes, the server notifies the client by sending a fresh list of heroes. If there are no changes since the last sync, this field may be omitted.",
            "items" : {
              "type" : "string",
              "description" : "The users which can be used to generate a room name if the room does not have one. Required if the room's m.room.name or m.room.canonical_alias state events are unset or empty. This should be the first 5 members of the room, ordered by stream ordering, which are joined or invited. The list must never include the client's own user ID. When no joined or invited members are available, this should consist of the banned and left users. More than 5 members may be provided, however less than 5 should only be provided when there are less than 5 members to represent. When lazy-loading room members is enabled, the membership events for the heroes MUST be included in the state, unless they are redundant. When the list of users changes, the server notifies the client by sending a fresh list of heroes. If there are no changes since the last sync, this field may be omitted."
            }
          },
          "m.joined_member_count" : {
            "type" : "integer",
            "description" : "The number of users with membership of join, including the client's own user ID. If this field has not changed since the last sync, it may be omitted. Required otherwise.",
            "format" : "int64"
          },
          "m.invited_member_count" : {
            "type" : "integer",
            "description" : "The number of users with membership of invite. If this field has not changed since the last sync, it may be omitted. Required otherwise.",
            "format" : "int64"
          }
        },
        "description" : "Room summary."
      },
      "Rooms" : {
        "type" : "object",
        "properties" : {
          "join" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/JoinedRoom"
            },
            "description" : "The rooms that the user has joined."
          },
          "invite" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/InvitedRoom"
            },
            "description" : "The rooms that the user has been invited to."
          },
          "leave" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/LeftRoom"
            },
            "description" : "The rooms that the user has left or been banned from."
          }
        },
        "description" : "Rooms."
      },
      "State" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "State."
      },
      "SyncResponse" : {
        "type" : "object",
        "properties" : {
          "rooms" : {
            "$ref" : "#/components/schemas/Rooms"
          },
          "presence" : {
            "$ref" : "#/components/schemas/Presence"
          },
          "next_batch" : {
            "type" : "string",
            "description" : "The batch token to supply in the since param of the next /sync request."
          },
          "account_data" : {
            "$ref" : "#/components/schemas/AccountData"
          },
          "to_device" : {
            "$ref" : "#/components/schemas/ToDevice"
          },
          "device_lists" : {
            "$ref" : "#/components/schemas/DeviceLists"
          },
          "device_one_time_keys_count" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "description" : "Information on end-to-end encryption keys, as specified in End-to-end encryption.",
              "format" : "int64"
            },
            "description" : "Information on end-to-end encryption keys, as specified in End-to-end encryption."
          }
        },
        "description" : "JSON body response for sync api."
      },
      "Timeline" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of events.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          },
          "limited" : {
            "type" : "boolean",
            "description" : "True if the number of events returned was limited by the limit on the filter."
          },
          "prev_batch" : {
            "type" : "string",
            "description" : "A token that can be supplied to the from parameter of the rooms/{roomId}/messages endpoint."
          }
        },
        "description" : "Timeline."
      },
      "ToDevice" : {
        "type" : "object",
        "properties" : {
          "events" : {
            "type" : "array",
            "description" : "List of send-to-device messages.",
            "items" : {
              "$ref" : "#/components/schemas/Event"
            }
          }
        },
        "description" : "To device."
      },
      "UnreadNotificationCounts" : {
        "type" : "object",
        "properties" : {
          "highlight_count" : {
            "type" : "integer",
            "description" : "The number of unread notifications for this room with the highlight flag set.",
            "format" : "int64"
          },
          "notification_count" : {
            "type" : "integer",
            "description" : "The total number of unread notifications for this room.",
            "format" : "int64"
          }
        },
        "description" : "Unread notification counts."
      },
      "Tags" : {
        "type" : "object",
        "properties" : {
          "tags" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/TagInfo"
            },
            "description" : "Tags."
          }
        },
        "description" : "TagInfo request."
      },
      "ProtocolLocation" : {
        "required" : [ "alias", "fields", "protocol" ],
        "type" : "object",
        "properties" : {
          "alias" : {
            "type" : "string",
            "description" : "An alias for a matrix room."
          },
          "protocol" : {
            "type" : "string",
            "description" : "The protocol ID that the third party location is a part of."
          },
          "fields" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "Information used to identify this third party location."
            },
            "description" : "Information used to identify this third party location."
          }
        },
        "description" : "Protocol Location."
      },
      "FieldMetadata" : {
        "required" : [ "placeholder", "regexp" ],
        "type" : "object",
        "properties" : {
          "regexp" : {
            "type" : "string",
            "description" : "A regular expression for validation of a field's value."
          },
          "placeholder" : {
            "type" : "string",
            "description" : "An placeholder serving as a valid example of the field value."
          }
        },
        "description" : "Definition of valid values for a field."
      },
      "Instance" : {
        "required" : [ "desc", "fields", "network_id" ],
        "type" : "object",
        "properties" : {
          "desc" : {
            "type" : "string",
            "description" : "Description."
          },
          "icon" : {
            "type" : "string",
            "description" : "An optional content URI representing the protocol. Overrides the one provided at the higher level Protocol object."
          },
          "fields" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "Preset values for fields the client may use to search by."
            },
            "description" : "Preset values for fields the client may use to search by."
          },
          "network_id" : {
            "type" : "string",
            "description" : "A unique identifier across all instances."
          }
        },
        "description" : "Instance."
      },
      "Protocol" : {
        "required" : [ "field_types", "icon", "instances", "location_fields", "user_fields" ],
        "type" : "object",
        "properties" : {
          "icon" : {
            "type" : "string",
            "description" : "An icon representing the third party protocol."
          },
          "instances" : {
            "type" : "array",
            "description" : "A list of objects representing independent instances of configuration. For instance multiple networkson IRC if multiple are bridged by the same bridge.",
            "items" : {
              "$ref" : "#/components/schemas/Instance"
            }
          },
          "user_fields" : {
            "type" : "array",
            "description" : "Fields used to identify a third party user.",
            "items" : {
              "type" : "string",
              "description" : "Fields used to identify a third party user."
            }
          },
          "location_fields" : {
            "type" : "array",
            "description" : "Fields used to identify a third party location.",
            "items" : {
              "type" : "string",
              "description" : "Fields used to identify a third party location."
            }
          },
          "field_types" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/FieldMetadata"
            },
            "description" : "All location or user fields should have an entry here."
          }
        },
        "description" : "Protocol metadata."
      },
      "ProtocolUser" : {
        "required" : [ "fields", "protocol", "userid" ],
        "type" : "object",
        "properties" : {
          "userid" : {
            "type" : "string",
            "description" : "A Matrix User ID represting a third party user."
          },
          "protocol" : {
            "type" : "string",
            "description" : "The protocol ID that the third party location is a part of."
          },
          "fields" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "description" : "Information used to identify this third party location."
            },
            "description" : "Information used to identify this third party location."
          }
        },
        "description" : "Protocol User."
      },
      "TypingRequest" : {
        "type" : "object",
        "properties" : {
          "typing" : {
            "type" : "boolean",
            "description" : "Whether the user is typing or not. If false, the timeout key can be omitted."
          },
          "timeout" : {
            "type" : "integer",
            "description" : "The length of time in milliseconds to mark this user as typing.",
            "format" : "int64"
          }
        },
        "description" : "TypingContent body request."
      },
      "SearchResponse" : {
        "type" : "object",
        "properties" : {
          "results" : {
            "type" : "array",
            "description" : "Ordered by rank and then whether or not profile info is available.",
            "items" : {
              "$ref" : "#/components/schemas/User"
            }
          },
          "limit" : {
            "type" : "boolean",
            "description" : "Indicates if the result list has been truncated by the limit."
          }
        },
        "description" : "JSON body response for user directory api (search result)."
      },
      "User" : {
        "type" : "object",
        "properties" : {
          "user_id" : {
            "type" : "string",
            "description" : "The user's matrix user ID."
          },
          "display_name" : {
            "type" : "string",
            "description" : "The display name of the user, if one exists."
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The avatar url, as an MXC, if one exists."
          }
        },
        "description" : "JSON body response for user directory api (User)."
      },
      "VersionsResponse" : {
        "required" : [ "versions" ],
        "type" : "object",
        "properties" : {
          "versions" : {
            "type" : "array",
            "description" : "The supported versions.",
            "items" : {
              "type" : "string",
              "description" : "The supported versions."
            }
          },
          "unstable_features" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "boolean",
              "description" : "Experimental features the server supports. Features not listed here, or the lack of this property all together, indicate that a feature is not supported."
            },
            "description" : "Experimental features the server supports. Features not listed here, or the lack of this property all together, indicate that a feature is not supported."
          }
        },
        "description" : "The versions supported by the server."
      },
      "VoipResponse" : {
        "type" : "object",
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "The username to use."
          },
          "password" : {
            "type" : "array",
            "description" : "The password to use.",
            "items" : {
              "type" : "string",
              "description" : "The password to use."
            }
          },
          "uris" : {
            "type" : "array",
            "description" : "A list of TURN URIs.",
            "items" : {
              "type" : "string",
              "description" : "A list of TURN URIs."
            }
          },
          "ttl" : {
            "type" : "integer",
            "description" : "The time-to-live in seconds.",
            "format" : "int64"
          }
        },
        "description" : "The TURN server credentials."
      }
    }
  }
}