{
  "swagger" : "2.0",
  "info" : {
    "description" : "Client-Server API",
    "version" : "r0.4.0-1-SNAPSHOT",
    "title" : "Client-Server API",
    "termsOfService" : "http://www.github.com/kongchen/swagger-maven-plugin",
    "contact" : {
      "name" : "Anatoly",
      "url" : "https://github.com/ma1uta/jeon",
      "email" : "sablintolya@gmail.com"
    },
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "host" : "matrix.org:8448",
  "tags" : [ {
    "name" : "Account",
    "description" : "Account registration and management"
  }, {
    "name" : "Admin",
    "description" : "Gets information about a particular user"
  }, {
    "name" : "Authentication",
    "description" : "A client can obtain access tokens using the /login API"
  }, {
    "name" : "CAS",
    "description" : "Central Authentication Service (CAS) is a web-based single sign-on protocol."
  }, {
    "name" : "ClientConfig",
    "description" : "Client Behaviour"
  }, {
    "name" : "Content",
    "description" : "This module allows users to upload content to their homeserver which is retrievable from other homeservers. Its' purpose is to allow users to share attachments in a room. Key locations are represented as Matrix Key (MXC) URIs."
  }, {
    "name" : "DeprecatedSync",
    "description" : "Warning: This API is deprecated and will be removed from a future release.."
  }, {
    "name" : "Device",
    "description" : "Clients that implement this module should offer the user a list of registered devices, as well as the means to update their display names. Clients should also allow users to delete disused devices."
  }, {
    "name" : "Encryption",
    "description" : "Matrix optionally supports end-to-end encryption, allowing rooms to be created whose conversation contents is not decryptable or interceptable on any of the participating homeservers."
  }, {
    "name" : "Event",
    "description" : "There are several APIs provided to GET events for a room."
  }, {
    "name" : "EventContext",
    "description" : "This API returns a number of events that happened just before and after the specified event. This allows clients to get the context surrounding an event."
  }, {
    "name" : "FallbackAuthentication",
    "description" : "If a client does not recognize any or all login flows it can use the fallback login API."
  }, {
    "name" : "Filter",
    "description" : "Filters can be created on the server and can be passed as as a parameter to APIs which return events. These filters alter the data returned from those APIs. Not all APIs accept filters."
  }, {
    "name" : "OpenID",
    "description" : "This module allows users to verify their identity with a third party service. The third party service does need to be matrix-aware in that it will need to know to resolve matrix homeservers to exchange the user's token for identity information."
  }, {
    "name" : "Presence",
    "description" : "Each user has the concept of presence information."
  }, {
    "name" : "Profile",
    "description" : "Profiles."
  }, {
    "name" : "Push",
    "description" : "This module adds support for push notifications. Homeservers send notifications of events to user-configured HTTP endpoints. Users may also configure a number of rules that determine which events generate notifications. These are all stored and managed by the user's homeserver. This allows user-specific push settings to be reused between client applications."
  }, {
    "name" : "Receipt",
    "description" : "This module adds in support for receipts. These receipts are a form of acknowledgement of an event. This module defines a single acknowledgement: m.read which indicates that the user has read up to a given event."
  }, {
    "name" : "Report",
    "description" : "Users may encounter content which they find inappropriate and should be able to report it to the server administrators or room moderators for review. This module defines a way for users to report content."
  }, {
    "name" : "Room"
  }, {
    "name" : "Search",
    "description" : "The search API allows clients to perform full text search across events in all rooms that the user has been in, including those that they have left. Only events that the user is allowed to see will be searched, e.g. it won't include events in rooms that happened after you left."
  }, {
    "name" : "SendToDevice",
    "description" : "This module provides a means by which clients can exchange signalling messages without them being stored permanently as part of a shared communication history. A message is delivered exactly once to each client device."
  }, {
    "name" : "ServerDiscovery",
    "description" : "Gets discovery information about the domain."
  }, {
    "name" : "Sync",
    "description" : "To read events, the intended flow of operation is for clients to first call the /sync API without a since parameter. This returns the most recent message events for each room, as well as the state of the room at the start of the returned timeline. The response also includes a next_batch field, which should be used as the value of the since parameter in the next call to /sync. Finally, the response includes, for each room, a prev_batch field, which can be passed as a start parameter to the /rooms/<room_id>/messages API to retrieve earlier messages."
  }, {
    "name" : "Tag",
    "description" : "Users can add tags to rooms. Tags are short strings used to label rooms, e.g. \"work\", \"family\". A room may have multiple tags. Tags are only visible to the user that set them but are shared across all their devices."
  }, {
    "name" : "ThirdPartyProtocol",
    "description" : "Application services can provide access to third party networks via bridging.This allows Matrix users to communicate with users on other communication platforms, with messages ferried back and forthby the application service. A single application service may bridge multiple third party networks, and many individuallocations within those networks. A single third party network location may be bridged to multiple Matrix rooms."
  }, {
    "name" : "Typing",
    "description" : "When a client receives an m.typing event, it MUST use the user ID list to REPLACE its knowledge of every user who is currently typing. The reason for this is that the server does not remember users who are not currently typing as that list gets big quickly. The client should mark as not typing any user ID who is not in that list."
  }, {
    "name" : "UserDirectory",
    "description" : "User directory."
  }, {
    "name" : "VOIP",
    "description" : "The homeserver MAY provide a TURN server which clients can use to contact the remote party. The following HTTP API endpoints will be used by clients in order to get information about the TURN server."
  }, {
    "name" : "Version",
    "description" : "Gets the versions of the specification supported by the server."
  } ],
  "schemes" : [ "https" ],
  "paths" : {
    "/.well-known/matrix/client" : {
      "get" : {
        "tags" : [ "ServerDiscovery" ],
        "summary" : "Gets discovery information about the domain.",
        "description" : "",
        "operationId" : "serverDiscovery",
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "Server discovery information.",
            "schema" : {
              "$ref" : "#/definitions/ServerDiscoveryResponse"
            }
          },
          "404" : {
            "description" : "No server discovery information available."
          }
        }
      }
    },
    "/_matrix/client/r0/account/3pid" : {
      "get" : {
        "tags" : [ "Account" ],
        "summary" : "Gets a list of the third party identifiers that the homeserver has associated with the user's account",
        "description" : "This is not the same as the list of third party identifiers bound to the user's Matrix ID in Identity Servers. Identifiers in this list may be used by the homeserver as, for example, identifiers that it will accept to reset the user's account password.",
        "operationId" : "getThreePid",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The lookup was successful",
            "schema" : {
              "$ref" : "#/definitions/ThreePidResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Adds contact information to the user's account",
        "description" : "",
        "operationId" : "updateThreePid",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "New contact information.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ThreePidRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The addition was successful.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "403" : {
            "description" : "The credentials could not be verified with the identity server."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/3pid/delete" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Removes a third party identifier from the user's account.",
        "description" : "This might not cause an unbind of the identifier from the identity server.",
        "operationId" : "deleteThreePid",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/Delete3PidRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The homeserver has disassociated the third party identifier from the user.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/3pid/email/requestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Proxies the identity server API validate/email/requestToken",
        "description" : "roxies the identity server API validate/email/requestToken, but first checks that the given email address is not already associated with an account on this Home Server. This API should be used to request validation tokens when adding an email address to an account. This API's parameters and response is identical to that of the HS API /register/email/requestToken endpoint.",
        "operationId" : "threePidEmailRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EmailRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An email was sent to the given address",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "The third party identifier is already in use on the homeserver, or the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option."
          }
        }
      }
    },
    "/_matrix/client/r0/account/3pid/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Proxies the identity server API validate/email/requestToken",
        "description" : "roxies the identity server API validate/email/requestToken, but first checks that the given email address is not already associated with an account on this Home Server. This API should be used to request validation tokens when adding an email address to an account. This API's parameters and response is identical to that of the HS API /register/email/requestToken endpoint.",
        "operationId" : "threePidMsisdnRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/MsisdnRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An SMS message was sent to the given phone number.",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "The third party identifier is already in use on the homeserver, or the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option."
          }
        }
      }
    },
    "/_matrix/client/r0/account/deactivate" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Deactivate the user's account, removing all ability for the user to login again.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.An access token should be submitted to this endpoint if the client has an active session.The homeserver may change the flows available depending on whether a valid access token is provided.",
        "operationId" : "deactivate",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/DeactivateRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account has been deactivated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/password" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Changes the password for an account on this homeserver.",
        "description" : "This API endpoint uses the User-Interactive Authentication API. An access token should be submitted to this endpoint if the client has an active session. The homeserver may change the flows available depending on whether a valid access token is provided.",
        "operationId" : "password",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "password.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PasswordRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The password has been changed.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/account/password/email/requestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Proxies the identity server API validate/email/requestToken, but first checks that the given email address is associated with an account on this Home Server.",
        "description" : "This API should be used to request validation tokens when authenticating for the account/password endpoint. This API's parameters and response are identical to that of the HS API /register/email/requestToken except that M_THREEPID_NOT_FOUND may be returned if no account matching the given email address could be found. The server may instead send an email to the given address prompting the user to create an account. M_THREEPID_IN_USE may not be returned.",
        "operationId" : "passwordEmailRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EmailRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An email was sent to the given address",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "400" : {
            "description" : "The referenced third party identifier is not recognised by the homeserver, or the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option."
          }
        }
      }
    },
    "/_matrix/client/r0/account/password/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Proxies the identity server API validate/email/requestToken, but first checks that the given email address is associated with an account on this Home Server.",
        "description" : "This API should be used to request validation tokens when authenticating for the account/password endpoint. This API's parameters and response are identical to that of the HS API /register/email/requestToken except that M_THREEPID_NOT_FOUND may be returned if no account matching the given email address could be found. The server may instead send an email to the given address prompting the user to create an account. M_THREEPID_IN_USE may not be returned.",
        "operationId" : "passwordMsisdnRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/MsisdnRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An SMS message was sent to the given phone number.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "400" : {
            "description" : "The referenced third party identifier is not recognised by the homeserver, or the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not allow the third party identifier as a contact option."
          }
        }
      }
    },
    "/_matrix/client/r0/account/whoami" : {
      "get" : {
        "tags" : [ "Account" ],
        "summary" : "Gets information about the owner of a given access token",
        "description" : "Note that, as with the rest of the Client-Server API, Application Services may masquerade as users within their namespace by giving a user_id query parameter. In this situation, the server should verify that the given user_id is registered by the appservice, and return it in the response body.",
        "operationId" : "whoami",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The token belongs to a known user",
            "schema" : {
              "$ref" : "#/definitions/WhoamiResponse"
            }
          },
          "401" : {
            "description" : "The token is not recognised."
          },
          "403" : {
            "description" : "The appservice cannot masquerade as the user or has not registered them."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/admin/whois/{userId}" : {
      "get" : {
        "tags" : [ "Admin" ],
        "summary" : "This API may be restricted to only be called by the user being looked up, or by a server admin. Server-local administrator privileges are not specified in this document.",
        "description" : "",
        "operationId" : "whois",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The use to look up",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The lookup was successful.",
            "schema" : {
              "$ref" : "#/definitions/AdminResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/auth/{auth}/fallback/web" : {
      "get" : {
        "tags" : [ "FallbackAuthentication" ],
        "summary" : "Fallback login endpoint. If a client does not know how to handle a given login type, it can direct the user to a web browser with the URL of a fallback page which will allow the user to complete that login step out-of-band in their web browser.",
        "description" : "",
        "operationId" : "auth",
        "produces" : [ "text/html" ],
        "parameters" : [ {
          "name" : "auth",
          "in" : "path",
          "description" : "The type name of the stage it is attempting.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "session",
          "in" : "query",
          "description" : "the ID of the session given by the homeserver.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "n HTML page which can perform this authentication stage. This page must use the following JavaScript when the authentication has been completed.",
            "schema" : {
              "type" : "string"
            }
          }
        }
      }
    },
    "/_matrix/client/r0/createRoom" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "Create a new room with various configuration options.",
        "description" : "The server MUST apply the normal state resolution rules when creating the new room, including checking power levels for each event.",
        "operationId" : "create",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/CreateRoomRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Information about the newly created room.",
            "schema" : {
              "$ref" : "#/definitions/RoomId"
            }
          },
          "400" : {
            "description" : "The request is invalid. A meaningful errcode and description error text will be returned."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/delete_devices" : {
      "post" : {
        "tags" : [ "Device" ],
        "summary" : "Deletes the given devices, and invalidates any access token associated with them.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.",
        "operationId" : "deleteDevices",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/DevicesDeleteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The devices were successfully removed, or had been removed previously.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/devices" : {
      "get" : {
        "tags" : [ "Device" ],
        "summary" : "Gets information about all devices for the current user.",
        "description" : "",
        "operationId" : "devices",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "A list of all registered devices for this user.",
            "schema" : {
              "$ref" : "#/definitions/DevicesResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/devices/{deviceId}" : {
      "get" : {
        "tags" : [ "Device" ],
        "summary" : "Gets information on a single device, by device id.",
        "description" : "",
        "operationId" : "device",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to retrieve",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Device information.",
            "schema" : {
              "$ref" : "#/definitions/Device"
            }
          },
          "404" : {
            "description" : "The current user has no device with the given ID."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Device" ],
        "summary" : "Updates the metadata on the given device.",
        "description" : "",
        "operationId" : "updateDevice",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "The new display name for this device. If not given, the display name is unchanged.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/DeviceUpdateRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The device was successfully updated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "404" : {
            "description" : "The current user has no device with the given ID."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Device" ],
        "summary" : "Deletes the given device, and invalidates any access token associated with it.",
        "description" : "This API endpoint uses the User-Interactive Authentication API.",
        "operationId" : "deleteDevice",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "deviceId",
          "in" : "path",
          "description" : "The device to delete",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Additional authentication information for the user-interactive authentication API.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/DeviceDeleteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The device was successfully removed, or had been removed previously.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/directory/list/room/{roomId}" : {
      "get" : {
        "tags" : [ "Room" ],
        "summary" : "Gets the visibility of a given room on the server's public room directory.",
        "description" : "",
        "operationId" : "getVisibility",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The visibility of the room in the directory",
            "schema" : {
              "$ref" : "#/definitions/RoomVisibility"
            }
          },
          "404" : {
            "description" : "The room is not known to the server"
          }
        }
      },
      "put" : {
        "tags" : [ "Room" ],
        "summary" : "Sets the visibility of a given room in the server's public room directory.",
        "description" : "",
        "operationId" : "setVisibility",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RoomVisibility"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The visibility was updated, or no change was needed.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "404" : {
            "description" : "The room is not known to the server."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/directory/room/{roomAlias}" : {
      "get" : {
        "tags" : [ "Room" ],
        "summary" : "Requests that the server resolve a room alias to a room ID. The server will use the federation API to resolve the alias if the domain part of the alias does not correspond to the server's own domain.",
        "description" : "",
        "operationId" : "resolveAlias",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The room ID and other information for this alias.",
            "schema" : {
              "$ref" : "#/definitions/RoomResolveResponse"
            }
          },
          "404" : {
            "description" : "There is no mapped room ID for this room alias."
          }
        }
      },
      "put" : {
        "tags" : [ "Room" ],
        "summary" : "Create a new mapping from room alias to room ID.",
        "description" : "",
        "operationId" : "createAlias",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias to set",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RoomId"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The mapping was created.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "409" : {
            "description" : "A room alias with that name already exists."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Room" ],
        "summary" : "Remove a mapping of room alias to room ID.",
        "description" : "",
        "operationId" : "deleteAlias",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomAlias",
          "in" : "path",
          "description" : "The room alias to remove.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The mapping was deleted.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/events" : {
      "get" : {
        "tags" : [ "Sync" ],
        "summary" : "This will listen for new events related to a particular room and return them to the caller. This will block until an event is received, or until the timeout is reached.",
        "description" : "",
        "operationId" : "events",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "The token to stream from. This token is either from a previous request to this API or from the initial sync API.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "timeout",
          "in" : "query",
          "description" : "The maximum time in milliseconds to wait for an event.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "room_id",
          "in" : "query",
          "description" : "The room ID for which events should be returned.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The events received, which may be none.",
            "schema" : {
              "$ref" : "#/definitions/Page"
            }
          },
          "400" : {
            "description" : "Bad pagination from parameter."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/events/{eventId}" : {
      "get" : {
        "tags" : [ "DeprecatedSync" ],
        "summary" : "Get a single event based on event_id.",
        "description" : "You must have permission to retrieve this event e.g. by being a member in the room for this event. This endpoint was deprecated in r0 of this specification. Clients should instead call the /rooms/{roomId}/event/{eventId} API or the /rooms/{roomId}/context/{eventId} API.",
        "operationId" : "event",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The full event.",
            "schema" : {
              "$ref" : "#/definitions/Event"
            }
          },
          "404" : {
            "description" : "The event was not found or you do not have permission to read this event."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ],
        "deprecated" : true
      }
    },
    "/_matrix/client/r0/initialSync" : {
      "get" : {
        "tags" : [ "DeprecatedSync" ],
        "summary" : "This returns the full state for this user, with an optional limit on the number of messages per room to return.",
        "description" : "This endpoint was deprecated in r0 of this specification. Clients should instead call the /sync API with no since parameter. See the migration guide.",
        "operationId" : "initialSync",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "archived",
          "in" : "query",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The user's current state.",
            "schema" : {
              "$ref" : "#/definitions/DeprecatedInitialSyncResponse"
            }
          },
          "404" : {
            "description" : "There is no avatar URL for this user or this user does not exist."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ],
        "deprecated" : true
      }
    },
    "/_matrix/client/r0/join/{roomIdOrAlias}" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.",
        "description" : "",
        "operationId" : "joinByIdOrAlias",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomIdOrAlias",
          "in" : "path",
          "description" : "The room identifier or alias to join.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "server_name",
          "in" : "query",
          "description" : "The servers to attempt to join the room through. One of the servers must be participating in the room.",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/JoinRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been joined. The joined room ID must be returned in the room_id field.",
            "schema" : {
              "$ref" : "#/definitions/RoomId"
            }
          },
          "403" : {
            "description" : "You do not have permission to join the room. A meaningful errcode and description error text will be returned."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/joined_rooms" : {
      "get" : {
        "tags" : [ "Room" ],
        "summary" : "This API returns a list of the user's current rooms.",
        "description" : "",
        "operationId" : "joinedRooms",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "A list of the rooms the user is in.",
            "schema" : {
              "$ref" : "#/definitions/JoinedRoomsResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/changes" : {
      "get" : {
        "tags" : [ "Encryption" ],
        "summary" : "Gets a list of users who have updated their device identity keys since a previous sync token.",
        "description" : "The server should include in the results any users who currently share a room with the calling user (ie, both users have membership state join); and added new device identity keys or removed an existing device with identity keys, between from and to.",
        "operationId" : "changes",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "The desired start point of the list. Should be the next_batch field from a response to an earlier call to /sync. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The desired end point of the list. Should be the next_batch field from a recent call to /sync - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of users who updated their devices.",
            "schema" : {
              "$ref" : "#/definitions/ChangesResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/claim" : {
      "post" : {
        "tags" : [ "Encryption" ],
        "summary" : "Claims one-time keys for use in pre-key messages.",
        "description" : "",
        "operationId" : "claim",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ClaimRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The claimed keys.",
            "schema" : {
              "$ref" : "#/definitions/ClaimResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/query" : {
      "post" : {
        "tags" : [ "Encryption" ],
        "summary" : "Returns the current devices and identity keys for the given users.",
        "description" : "",
        "operationId" : "query",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/QueryRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The device information.",
            "schema" : {
              "$ref" : "#/definitions/QueryResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/keys/upload" : {
      "post" : {
        "tags" : [ "Encryption" ],
        "summary" : "Publishes end-to-end encryption keys for the device.",
        "description" : "",
        "operationId" : "uploadKey",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/UploadRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The provided keys were sucessfully uploaded.",
            "schema" : {
              "$ref" : "#/definitions/UploadResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/login" : {
      "get" : {
        "tags" : [ "Authentication" ],
        "summary" : "Gets the homeserver's supported login types to authenticate users.",
        "description" : "Clients should pick one of these and supply it as the type when logging in.",
        "operationId" : "supportedLoginTypes",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The login types the homeserver supports.",
            "schema" : {
              "$ref" : "#/definitions/SupportedLoginResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      },
      "post" : {
        "tags" : [ "Authentication" ],
        "summary" : "Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests",
        "description" : "If the client does not supply a device_id, the server must auto-generate one. The returned access token must be associated with the device_id supplied by the client or generated by the server. The server may invalidate any access token previously associated with that device",
        "operationId" : "login",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "login request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/LoginRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user has been authenticated",
            "schema" : {
              "$ref" : "#/definitions/LoginResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid. For example, the login type may not be recognised"
          },
          "401" : {
            "description" : "The login attempt failed. For example, the password may have been incorrect."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      }
    },
    "/_matrix/client/r0/login/cas/redirect" : {
      "get" : {
        "tags" : [ "CAS" ],
        "summary" : "A web-based Matrix client should instruct the user's browser to navigate to this endpoint in order to log in via CAS.",
        "description" : "The server MUST respond with an HTTP redirect to the CAS interface. The URI MUST include a service parameter giving the path of the /login/cas/ticket endpoint (including the redirectUrl query parameter).",
        "operationId" : "redirect",
        "parameters" : [ {
          "name" : "redirectUrl",
          "in" : "query",
          "description" : "URI to which the user will be redirected after the homeserver has authenticated the user with CAS.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "302" : {
            "description" : "A redirect to the CAS interface"
          }
        }
      }
    },
    "/_matrix/client/r0/login/cas/ticket" : {
      "get" : {
        "tags" : [ "CAS" ],
        "summary" : "Once the CAS server has authenticated the user, it will redirect the browser to this endpoint (assuming /login/cas/redirect gave it the correct service parameter).",
        "description" : "The server MUST call /proxyValidate on the CAS server, to validate the ticket supplied by the browser. If validation is successful, the server must generate a Matrix login token. It must then respond with an HTTP redirect to the URI given in the redirectUrl parameter, adding a loginToken query parameter giving the generated token. If validation is unsuccessful, the server should respond with a 401 Unauthorized error, the body of which will be displayed to the user.",
        "operationId" : "ticket",
        "parameters" : [ {
          "name" : "redirectUrl",
          "in" : "query",
          "description" : "The redirectUrl originally provided by the client to /login/cas/redirect.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ticket",
          "in" : "query",
          "description" : "CAS authentication ticket",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "302" : {
            "description" : "A redirect to the Matrix client."
          },
          "401" : {
            "description" : "The server was unable to validate the CAS ticket."
          }
        }
      }
    },
    "/_matrix/client/r0/logout" : {
      "post" : {
        "tags" : [ "Authentication" ],
        "summary" : "Invalidates an existing access token, so that it can no longer be used for authorization.",
        "description" : "",
        "operationId" : "logout",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The access token used in the request was succesfully invalidated",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/logout/all" : {
      "post" : {
        "tags" : [ "Authentication" ],
        "summary" : "Invalidates all access tokens for a user, so that they can no longer be used for authorization. This includes the access token that made this request",
        "description" : "This endpoint does not require UI authorization because UI authorization is designed to protect against attacks where the someone gets hold of a single access token then takes over the account. This endpoint invalidates all access tokens for the user, including the token used in the request, and therefore the attacker is unable to take over the account in this way.",
        "operationId" : "logoutAll",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The user's access tokens were succesfully invalidated",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/notifications" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "This API is used to paginate through the list of events that the user has been, or would have been notified about.",
        "description" : "",
        "operationId" : "notifications",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "from",
          "in" : "query",
          "description" : "Pagination token given to retrieve the next set of events.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "only",
          "in" : "query",
          "description" : "Allows basic filtering of events returned.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "Limit on the number of events to return in this request.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        } ],
        "responses" : {
          "200" : {
            "description" : "A batch of events is being returned.",
            "schema" : {
              "$ref" : "#/definitions/NotificationResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/presence/list/{userId}" : {
      "get" : {
        "tags" : [ "Presence" ],
        "summary" : "Retrieve a list of presence events for every user on this list.",
        "description" : "",
        "operationId" : "getPresenceList",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence list should be retrieved.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of presence events for this list.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Event"
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Presence" ],
        "summary" : "Adds or removes users from this presence list.",
        "description" : "",
        "operationId" : "setPresenceList",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence list is being modified.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PresenceList"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list was updated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/presence/{userId}/status" : {
      "get" : {
        "tags" : [ "Presence" ],
        "summary" : "Get the given user's presence state.",
        "description" : "",
        "operationId" : "getPresenceStatus",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence state to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The presence state for this user.",
            "schema" : {
              "$ref" : "#/definitions/PresenceStatus"
            }
          },
          "403" : {
            "description" : "You are not allowed to see this user's presence status."
          },
          "404" : {
            "description" : "There is no presence state for this user. This user may not exist or isn't exposing presence information to you."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Presence" ],
        "summary" : "This API sets the given user's presence state. When setting the status, the activity time is updated to reflect that activity; the client does not need to specify the last_active_ago field. You cannot set the presence state of another user.",
        "description" : "",
        "operationId" : "setPresenceStatus",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose presence state to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PresenceRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The new presence state was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/profile/{userId}" : {
      "get" : {
        "tags" : [ "Profile" ],
        "summary" : "Get the combined profile information for this user. This API may be used to fetch the user's own profile information or other users; either locally or on remote homeservers. This API may return keys which are not limited to displayname or avatar_url.",
        "description" : "",
        "operationId" : "profile",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose profile information to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The avatar URL for this user.",
            "schema" : {
              "$ref" : "#/definitions/Profile"
            }
          },
          "404" : {
            "description" : "There is no profile information for this user or this user does not exist."
          }
        }
      }
    },
    "/_matrix/client/r0/profile/{userId}/avatar_url" : {
      "get" : {
        "tags" : [ "Profile" ],
        "summary" : "Get the user's avatar URL. This API may be used to fetch the user's own avatar URL or to query the URL of other users;  either locally or on remote homeservers.",
        "description" : "",
        "operationId" : "showAvatarUrl",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose avatar URL to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The avatar URL for this user.",
            "schema" : {
              "$ref" : "#/definitions/AvatarUrl"
            }
          },
          "404" : {
            "description" : "There is no avatar URL for this user or this user does not exist."
          }
        }
      },
      "put" : {
        "tags" : [ "Profile" ],
        "summary" : "This API sets the given user's avatar URL. You must have permission to set this user's avatar URL, e.g. you need to have their access_token.",
        "description" : "",
        "operationId" : "setAvatarUrl",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose avatar URL to set.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/AvatarUrl"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The avatar URL was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/profile/{userId}/displayname" : {
      "get" : {
        "tags" : [ "Profile" ],
        "summary" : "Get the user's display name. This API may be used to fetch the user's own displayname or to query the name of other users; either locally or on remote homeservers.",
        "description" : "",
        "operationId" : "showDisplayName",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose display name to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The display name for this user.",
            "schema" : {
              "$ref" : "#/definitions/DisplayName"
            }
          },
          "404" : {
            "description" : "There is no display name for this user or this user does not exist."
          }
        }
      },
      "put" : {
        "tags" : [ "Profile" ],
        "summary" : "his API sets the given user's display name. You must have permission to set this user's display name, e.g. you need to have their access_token.",
        "description" : "",
        "operationId" : "setDisplayName",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user whose display name to set.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/DisplayName"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The display name was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/publicRooms" : {
      "get" : {
        "tags" : [ "Room" ],
        "summary" : "Lists the public rooms on the server. This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.",
        "description" : "",
        "operationId" : "showPublicRooms",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "description" : "Limit the number of results returned.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "since",
          "in" : "query",
          "description" : "A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "server",
          "in" : "query",
          "description" : "The server to fetch the public room lists from. Defaults to the local server.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of the rooms on the server.",
            "schema" : {
              "$ref" : "#/definitions/PublicRoomsResponse"
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "Lists the public rooms on the server, with optional filter. This API returns paginated responses. The rooms are ordered by the number of joined members, with the largest rooms first.",
        "description" : "",
        "operationId" : "searchPublicRooms",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "server",
          "in" : "query",
          "description" : "The server to fetch the public room lists from. Defaults to the local server.",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PublicRoomsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of the rooms on the server.",
            "schema" : {
              "$ref" : "#/definitions/PublicRoomsResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushers" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "Gets all currently active pushers for the authenticated user.",
        "description" : "",
        "operationId" : "showPushers",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The pushers for this user.",
            "schema" : {
              "$ref" : "#/definitions/PushersResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushers/set" : {
      "post" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.",
        "description" : "",
        "operationId" : "setPushers",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PushersRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The pusher was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "400" : {
            "description" : "One or more of the pusher values were invalid."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "Retrieve all push rulesets for this user. Clients can \"drill-down]\"on the rulesets by suffixing a scope to this path e.g. /pushrules/global/. This will return a subset of this data under the specified key e.g. the global key.",
        "description" : "",
        "operationId" : "pushRules",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "All the push rulesets for this user.",
            "schema" : {
              "$ref" : "#/definitions/PushRulesResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "Retrieve a single specified push rule.",
        "description" : "",
        "operationId" : "pushRule",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The specific push rule. This will also include keys specific to the rule itself such as the rule's actions and conditions if set.",
            "schema" : {
              "$ref" : "#/definitions/PushRule"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint allows the creation, modification and deletion of pushers for this user ID. The behaviour of this endpoint varies depending on the values in the JSON body.",
        "description" : "",
        "operationId" : "updateRule",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "before",
          "in" : "query",
          "description" : "Use 'before' with a rule_id as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "after",
          "in" : "query",
          "description" : "This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule.",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PushUpdateRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The pusher was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "400" : {
            "description" : "There was a problem configuring this push rule."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint removes the push rule defined in the path.",
        "description" : "",
        "operationId" : "deleteRule",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The push rule was deleted.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint get the actions for the specified push rule.",
        "description" : "",
        "operationId" : "getActions",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Either global or device/&lt;profile_tag&gt; to specify global rules or device rules for the given profile_tag.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The actions for this push rule.",
            "schema" : {
              "$ref" : "#/definitions/PushActions"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint allows clients to change the actions of a push rule. This can be used to change the actions of builtin rules.",
        "description" : "",
        "operationId" : "setActions",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PushActions"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The actions for the push rule were set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled" : {
      "get" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint gets whether the specified push rule is enabled.",
        "description" : "",
        "operationId" : "getEnabled",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Either global or device/&lt;profile_tag&gt; to specify global rules or device rules for the given profile_tag.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Whether the push rule is enabled.",
            "schema" : {
              "$ref" : "#/definitions/PushEnable"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Push" ],
        "summary" : "his endpoint allows clients to enable or disable the specified push rule.",
        "description" : "",
        "operationId" : "setEnabled",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "scope",
          "in" : "path",
          "description" : "Global to specify global rules",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "path",
          "description" : "The kind of rule.",
          "required" : true,
          "type" : "string",
          "enum" : [ "override", "underride", "sender", "room", "content" ]
        }, {
          "name" : "ruleId",
          "in" : "path",
          "description" : "The identifier for the rule.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/PushEnable"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The push rule was enabled or disabled.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/register" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Register for an account on this homeserver.",
        "description" : "",
        "operationId" : "register",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "kind",
          "in" : "query",
          "description" : "The kind of account to register.",
          "required" : false,
          "type" : "string",
          "default" : "user",
          "enum" : [ "guest", "user" ]
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RegisterRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account has been registered",
            "schema" : {
              "$ref" : "#/definitions/LoginResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid."
          },
          "401" : {
            "description" : "The homeserver requires additional authentication information."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      }
    },
    "/_matrix/client/r0/register/available" : {
      "get" : {
        "tags" : [ "Account" ],
        "summary" : "Checks to see if a username is available, and valid, for the server.",
        "description" : "he server should check to ensure that, at the time of the request, the username requested is available for use.This includes verifying that an application service has not claimed the username and that the username fits the server'sdesired requirements (for example, a server could dictate that it does not permit usernames with underscores).Matrix clients may wish to use this API prior to attempting registration, however the clients must also be awarethat using this API does not normally reserve the username. This can mean that the username becomes unavailablebetween checking its availability and attempting to register it.",
        "operationId" : "available",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "query",
          "description" : "The username to check the availability of",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The username is available.",
            "schema" : {
              "$ref" : "#/definitions/AvailableResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid or the username is not available"
          },
          "429" : {
            "description" : "This request was rate-limited"
          }
        }
      }
    },
    "/_matrix/client/r0/register/email/emailRequestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Request email token.",
        "description" : "Proxies the identity server API validate/email/emailRequestToken, but first checks that the given email address is not already associated with an account on this Home Server. Note that, for consistency, this API takes JSON objects, though the Identity Server API takes x-www-form-urlencoded parameters. See the Identity Server API for further information.",
        "operationId" : "emailRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EmailRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An email has been sent to the specified address.",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not permit the address to be bound."
          }
        }
      }
    },
    "/_matrix/client/r0/register/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "Account" ],
        "summary" : "Request msisdn token.",
        "description" : "Proxies the Identity Service API validate/msisdn/requestToken, but first checks that the given phone number is not already associated with an account on this homeserver. See the Identity Service API for further information.",
        "operationId" : "msisdnRequestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/MsisdnRequestToken"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An SMS message has been sent to the specified phone number.",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid."
          },
          "403" : {
            "description" : "The homeserver does not permit the address to be bound."
          }
        }
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/ban" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "Ban a user in the room. If the user is currently in the room, also kick them.",
        "description" : "",
        "operationId" : "ban",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be banned.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/KickRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user has been kicked and banned from the room.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "403" : {
            "description" : "You do not have permission to ban the user from the room. A meaningful errcode and description error text will be returned."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/context/{eventId}" : {
      "get" : {
        "tags" : [ "EventContext" ],
        "summary" : "This API returns a number of events that happened just before and after the specified event.",
        "description" : "This allows clients to get the context surrounding an event.",
        "operationId" : "context",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get events from.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event to get context around.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The maximum number of events to return. Default: 10.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "The events and state surrounding the requested event.",
            "schema" : {
              "$ref" : "#/definitions/EventContextResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/event/{eventId}" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "Get a single event based on roomId/eventId. You must have permission to retrieve this event e.g. by being a member in the room for this event.",
        "description" : "",
        "operationId" : "roomEvent",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The ID of the room the event is in.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to get.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The full event.",
            "schema" : {
              "$ref" : "#/definitions/Event"
            }
          },
          "404" : {
            "description" : "The event was not found or you do not have permission to read this event."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/forget" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "This API stops a user remembering about a particular room. In general, history is a first class citizen in Matrix. After this API is called, however, a user will no longer be able to retrieve history for this room. If all users on a homeserver forget a room, the room is eligible for deletion from that homeserver.",
        "description" : "",
        "operationId" : "forget",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier to forget.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been forgotten.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "400" : {
            "description" : "The user has not left the room."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/initialSync" : {
      "get" : {
        "tags" : [ "DeprecatedSync" ],
        "summary" : "Get a copy of the current state and the most recent messages in a room.",
        "description" : "This endpoint was deprecated in r0 of this specification. There is no direct replacement; the relevant information is returned by the /sync API. See the migration guide.",
        "operationId" : "roomInitialSync",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the data.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The current state of the room.",
            "schema" : {
              "$ref" : "#/definitions/DeprecatedRoomInfo"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ],
        "deprecated" : true
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/invite" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "This API invites a user to participate in a particular room. They do not start participating in the room until they actually join the room.",
        "description" : "",
        "operationId" : "invite",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) to which to invite the user.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/InviteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user has been invited to join the room.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "403" : {
            "description" : "You do not have permission to invite the user to the room. A meaningful errcode and description error text will be returned. "
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/join" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "This API starts a user participating in a particular room, if that user is allowed to participate in that room. After this call, the client is allowed to see all current state events in the room, and all subsequent events associated with the room until the user leaves the room.",
        "description" : "",
        "operationId" : "joinById",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) to join.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/JoinRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been joined. The joined room ID must be returned in the room_id field.",
            "schema" : {
              "$ref" : "#/definitions/RoomId"
            }
          },
          "403" : {
            "description" : "You do not have permission to join the room. A meaningful errcode and description error text will be returned."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/joined_members" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "This API returns a map of MXIDs to member info objects for members of the room.",
        "description" : "The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS's users must be in the room. This API is primarily for Application Services and should be faster to respond than/members as it can be implemented more efficiently on the server.",
        "operationId" : "joinedMembers",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the members of.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "A map of MXID to room member objects.",
            "schema" : {
              "$ref" : "#/definitions/JoinedMembersResponse"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/kick" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "Kick a user from the room.",
        "description" : "",
        "operationId" : "kick",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be kicked.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/KickRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user has been kicked from the room.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "403" : {
            "description" : "You do not have permission to kick the user from the room. A meaningful errcode and description error text will be returned."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/leave" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "This API stops a user participating in a particular room. If the user was already in the room, they will no longer be able to see new events in the room. If the room requires an invite to join, they will need to be re-invited before they can re-join. If the user was invited to the room, but had not joined, this call serves to reject the invite.The user will still be allowed to retrieve history from the room which they were previously allowed to see.",
        "description" : "",
        "operationId" : "leave",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier to leave.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The room has been left.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/members" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "Get the list of members for this room.",
        "description" : "",
        "operationId" : "members",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get the member events for.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of members of the room. If you are joined to the room then this will be the current members of the room. If you have left the room then this will be the members of the room when you left.",
            "schema" : {
              "$ref" : "#/definitions/MembersResponse"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/messages" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "This API returns a list of message and state events for a room.",
        "description" : "It uses pagination query parameters to paginate history in the room.",
        "operationId" : "messages",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to get events from.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "from",
          "in" : "query",
          "description" : "The token to start returning events from. This token can be obtained from a prev_batch token returned for each room by the sync API, or from a start or end token returned by a previous request to this endpoint.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The token to stop returning events at. This token can be obtained from a prev_batch token returned for each room by the sync endpoint, or from a start or end token returned by a previous request to this endpoint.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "dir",
          "in" : "query",
          "description" : "The direction to return events from.",
          "required" : true,
          "type" : "string",
          "enum" : [ "b", "f" ]
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The maximum number of events to return.",
          "required" : false,
          "type" : "integer",
          "default" : 10,
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "A JSON RoomEventFilter to filter returned events with.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of messages with a new token to request more.",
            "schema" : {
              "$ref" : "#/definitions/Page"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/read_markers" : {
      "post" : {
        "tags" : [ "Receipt" ],
        "summary" : "Sets the position of the read marker for a given room, and optionally the read receipt's location.",
        "description" : "",
        "operationId" : "readMarkers",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room ID to set the read marker in for the user.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ReadMarkersRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The read marker, and read receipt if provided, have been updated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/receipt/{receiptType}/{eventId}" : {
      "post" : {
        "tags" : [ "Receipt" ],
        "summary" : "This API updates the marker for the given receipt type to the event ID specified.",
        "description" : "",
        "operationId" : "receipt",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room in which to send the event.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "receiptType",
          "in" : "path",
          "description" : "The type of receipt to send.",
          "required" : true,
          "type" : "string",
          "enum" : [ "m.read" ]
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event ID to acknowledge up to.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The receipt was sent.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/redact/{eventId}/{txnId}" : {
      "put" : {
        "tags" : [ "Event" ],
        "summary" : "Strips all information out of an event which isn't critical to the integrity of the server-side representation of the room.",
        "description" : "This cannot be undone. Users may redact their own events, and any user with a power level greater than or equal to the redact power level of the room may redact events there.",
        "operationId" : "redact",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room from which to redact the event.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The ID of the event to redact.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "The reason for the event being redacted.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RedactRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An ID for the redaction event.",
            "schema" : {
              "$ref" : "#/definitions/SendEventResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/report/{eventId}" : {
      "post" : {
        "tags" : [ "Report" ],
        "summary" : "Reports an event as inappropriate to the server, which may then notify the appropriate people.",
        "description" : "",
        "operationId" : "report",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room in which the event being reported is located.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventId",
          "in" : "path",
          "description" : "The event to report.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ReportRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The event has been reported successfully.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/send/{eventType}/{txnId}" : {
      "put" : {
        "tags" : [ "Event" ],
        "summary" : "This endpoint is used to send a message event to a room.",
        "description" : "Message events allow access to historical events and pagination, making them suited for \"once-off\" activity in a room. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See Room Events for the m. event specification.",
        "operationId" : "sendEvent",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to send the event to.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Event",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EventContent"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "schema" : {
              "$ref" : "#/definitions/SendEventResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "Get the state events for the current state of a room.",
        "description" : "",
        "operationId" : "roomState",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to look up the state for.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The current state of the room.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Event"
              }
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state/{eventType}" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.",
        "description" : "This looks up the state event with the empty state key.",
        "operationId" : "roomEventWithType",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to look up the state in.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of state to look up.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content of the state event.",
            "schema" : {
              "$ref" : "#/definitions/EventContent"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room."
          },
          "404" : {
            "description" : "The room has no state with the given type or key."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Event" ],
        "summary" : "State events can be sent using this endpoint.",
        "description" : "This endpoint is equivalent to calling /rooms/{roomId}/state/{eventType}/{stateKey} with an empty stateKey. Previous state events with matching (roomId) and (eventType), and empty (stateKey), will be overwritten. Requests to this endpoint cannot use transaction IDs like other PUT paths because they cannot be differentiated from the state_key. Furthermore, POST is unsupported on state paths. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event. See Room Events for the m.event specification.",
        "operationId" : "sendEventWithType",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to set the state in.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Event",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EventContent"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "schema" : {
              "$ref" : "#/definitions/SendEventResponse"
            }
          },
          "403" : {
            "description" : "The sender doesn't have permission to send the event into the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}" : {
      "get" : {
        "tags" : [ "Event" ],
        "summary" : "Looks up the contents of a state event in a room. If the user is joined to the room then the state is taken from the current state of the room. If the user has left the room then the state is taken from the state of the room when they left.",
        "description" : "",
        "operationId" : "roomEventWithTypeAndState",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to look up the state in.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of state to look up.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "stateKey",
          "in" : "path",
          "description" : "The key of the state to look up.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content of the state event.",
            "schema" : {
              "$ref" : "#/definitions/EventContent"
            }
          },
          "403" : {
            "description" : "You aren't a member of the room and weren't previously a member of the room."
          },
          "404" : {
            "description" : "The room has no state with the given type or key."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "put" : {
        "tags" : [ "Event" ],
        "summary" : "State events can be sent using this endpoint.",
        "description" : "These events will be overwritten if (room id), (event type) and (state key) all match. Requests to this endpoint cannot use transaction IDs like other PUT paths because they cannot be differentiated from the state_key. Furthermore, POST is unsupported on state paths. The body of the request should be the content object of the event; the fields in this object will vary depending on the type of event.See Room Events for the m.event specification.",
        "operationId" : "sendEventWithTypeAndState",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room to set the state in.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "stateKey",
          "in" : "path",
          "description" : "The state_key for the state to send. Defaults to the empty string.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "event",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/EventContent"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An ID for the sent event.",
            "schema" : {
              "$ref" : "#/definitions/SendEventResponse"
            }
          },
          "403" : {
            "description" : "The sender doesn't have permission to send the event into the room."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/typing/{userId}" : {
      "put" : {
        "tags" : [ "Typing" ],
        "summary" : "This tells the server that the user is typing for the next N milliseconds where N is the value specified in the timeout key. Alternatively, if typing is false, it tells the server that the user has stopped typing.",
        "description" : "",
        "operationId" : "typing",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The user who has started to type.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "path",
          "description" : "The room in which the user is typing.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/TypingRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The new typing state was set.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/rooms/{roomId}/unban" : {
      "post" : {
        "tags" : [ "Room" ],
        "summary" : "Unban a user from the room. This allows them to be invited to the room, and join if they would otherwise be allowed to join according to its join rules.",
        "description" : "",
        "operationId" : "unban",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "roomId",
          "in" : "path",
          "description" : "The room identifier (not alias) from which the user should be unbanned.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/UnbanRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The user has been unbanned from the room.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "403" : {
            "description" : "You do not have permission to unban the user from the room. A meaningful errcode and description error text will be returned."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/search" : {
      "post" : {
        "tags" : [ "Search" ],
        "summary" : "Performs a full text search across different categories.",
        "description" : "",
        "operationId" : "search",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "next_batch",
          "in" : "query",
          "description" : "The point to return events from. If given, this should be a next_batch result from a previous call to this endpoint.",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/SearchRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Results of the search.",
            "schema" : {
              "$ref" : "#/definitions/SearchResponse"
            }
          },
          "400" : {
            "description" : "Part of the request was invalid."
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/sendToDevice/{eventType}/{txnId}" : {
      "put" : {
        "tags" : [ "SendToDevice" ],
        "summary" : "This endpoint is used to send send-to-device events to a set of client devices.",
        "description" : "",
        "operationId" : "send",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "eventType",
          "in" : "path",
          "description" : "The type of event to send.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "txnId",
          "in" : "path",
          "description" : "The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON resuest body",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/SendToDeviceRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The message was successfully sent.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/sync" : {
      "get" : {
        "tags" : [ "Sync" ],
        "summary" : "Synchronise the client's state with the latest state on the server. Clients use this API when they first log in to get an initial snapshot of the state on the server, and then continue to call this API to get incremental deltas to the state, and to receive new messages.",
        "description" : "",
        "operationId" : "sync",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a \"{\" open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "since",
          "in" : "query",
          "description" : "A point in time to continue a sync from.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "full_state",
          "in" : "query",
          "description" : "Controls whether to include the full state for all rooms the user is a member of.",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "set_presence",
          "in" : "query",
          "description" : "Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to \"offline\" then the client is not marked as being online when it uses this API.",
          "required" : false,
          "type" : "string",
          "enum" : [ "offline" ]
        }, {
          "name" : "timeout",
          "in" : "query",
          "description" : "The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        } ],
        "responses" : {
          "200" : {
            "description" : "The initial snapshot or delta for the client to use to update their state.",
            "schema" : {
              "$ref" : "#/definitions/SyncResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/location" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Retrieve an array of third party network locations from a Matrix room alias.",
        "description" : "",
        "operationId" : "location",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "alias",
          "in" : "query",
          "description" : "The Matrix room alias to look up",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "At least one portal room was found.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ProtocolLocation"
              }
            }
          },
          "404" : {
            "description" : "No portal rooms were found."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/location/{protocol}" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Requesting this endpoint with a valid protocol name results in a list of successful mapping resultsin a JSON array.",
        "description" : "Each result contains objects to represent the Matrix room or rooms that represent a portal to this third party network. Each has the Matrix room alias string, an identifier for the particular third party network protocol, and an object containing the network-specific fields that comprise this identifier.It should attempt to canonicalise the identifier as much as reasonably possible given the network type.",
        "operationId" : "locationProtocol",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "The protocol used to communicate to the third party network.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "At least one portal room was found.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ProtocolLocation"
              }
            }
          },
          "404" : {
            "description" : "No portal rooms were found."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/protocol/{protocol}" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Fetches the metadata from the homeserver about a particular third party protocol.",
        "description" : "",
        "operationId" : "protocol",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "the name of the protocol",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The protocol was found and metadata returned.",
            "schema" : {
              "$ref" : "#/definitions/Protocol"
            }
          },
          "404" : {
            "description" : "The protocol is unknown."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/protocols" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Fetches the overall metadata about protocols supported by the homeserver.Includes both the available protocols and all fields required for queries against each protocol.",
        "description" : "",
        "operationId" : "protocols",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The protocols supported by the homeserver.",
            "schema" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/user" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Retrieve an array of third party users from a Matrix User ID.",
        "description" : "",
        "operationId" : "user",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userid",
          "in" : "query",
          "description" : "The Matrix User Id to look up",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The Matrix User IDs found with the given parameters.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ProtocolUser"
              }
            }
          },
          "404" : {
            "description" : "The Matrix User ID was not found."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/thirdparty/user/{protocol}" : {
      "get" : {
        "tags" : [ "ThirdPartyProtocol" ],
        "summary" : "Retrieve a Matrix User ID linked to a user on the third party service, given a set of user parameters.",
        "description" : "",
        "operationId" : "userProtocol",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "protocol",
          "in" : "path",
          "description" : "The name of the protocol",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The Matrix User IDs found with the given parameters.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/ProtocolUser"
              }
            }
          },
          "404" : {
            "description" : "The Matrix User ID was not found."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/account_data/{type}" : {
      "put" : {
        "tags" : [ "ClientConfig" ],
        "summary" : "Set some account_data for the client.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the top-level account_data.",
        "operationId" : "addConfig",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to set account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to set. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Account data",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/filter" : {
      "post" : {
        "tags" : [ "Filter" ],
        "summary" : "Uploads a new filter definition to the homeserver.",
        "description" : "Returns a filter ID that may be used in future requests to restrict which events are returned to the client.",
        "operationId" : "uploadFilter",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user uploading the filter. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body parameters",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/FilterData"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The filter was created.",
            "schema" : {
              "$ref" : "#/definitions/FilterResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/filter/{filterId}" : {
      "get" : {
        "tags" : [ "Filter" ],
        "summary" : "Download a filter.",
        "description" : "",
        "operationId" : "getFilter",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user ID to download a filter for.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "filterId",
          "in" : "path",
          "description" : "The filter ID to download.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The filter definition.",
            "schema" : {
              "$ref" : "#/definitions/FilterData"
            }
          },
          "404" : {
            "description" : "Unknown filter."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/openid/request_token" : {
      "post" : {
        "tags" : [ "OpenID" ],
        "summary" : "Gets an OpenID token object that the requester may supply to another service to verify their identity in Matrix.",
        "description" : "The generated token is only valid for exchanging for user information from the federation API for OpenID. The access token generated is only valid for the OpenID API. It cannot be used to request another OpenID access token or call /sync, for example.",
        "operationId" : "requestToken",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The user to request and OpenID token for. Should be the user who is authenticated for the request.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "OpenID token information. This response is nearly compatible with the response documented in the OpenID 1.0 Specification with the only difference being the lack of an id_token. Instead, the Matrix homeserver's name is provided.",
            "schema" : {
              "$ref" : "#/definitions/OpenIdResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/account_data/{type}" : {
      "put" : {
        "tags" : [ "ClientConfig" ],
        "summary" : "Set some account_data for the client on a given room.",
        "description" : "This config is only visible to the user that set the account_data. The config will be synced to clients in the per-room account_data.",
        "operationId" : "addRoomConfig",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to set account_data for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to set account_data on.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The event type of the account_data to set. Custom types should be namespaced to avoid clashes.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Account data",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The account_data was successfully added.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags" : {
      "get" : {
        "tags" : [ "Tag" ],
        "summary" : "List the tags set by a user on a room.",
        "description" : "",
        "operationId" : "showTags",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to get tags for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to get tags for.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of tags for the user for the room.",
            "schema" : {
              "$ref" : "#/definitions/Tags"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}" : {
      "put" : {
        "tags" : [ "Tag" ],
        "summary" : "Add a tag to the room.",
        "description" : "",
        "operationId" : "addTag",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to add a tag for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to add a tag to.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "tag",
          "in" : "path",
          "description" : "The tag to add.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "TagInfo data.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/TagInfo"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The tag was successfully added.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      },
      "delete" : {
        "tags" : [ "Tag" ],
        "summary" : "Remove a tag from the room.",
        "description" : "",
        "operationId" : "deleteTag",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "The id of the user to remove a tag for. The access token must be authorized to make requests for this user id.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "roomId",
          "in" : "path",
          "description" : "The id of the room to remove a tag from.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "tag",
          "in" : "path",
          "description" : "The tag to remove.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The tag was successfully removed.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/user_directory/search" : {
      "post" : {
        "tags" : [ "UserDirectory" ],
        "summary" : "Performs a search for users on the homeserver.",
        "description" : "The homeserver may determine which subset of users are searched, however the homeserver MUST at a minimum consider the users the requesting user shares a room with and those who reside in public rooms (known to the homeserver). The search MUST consider local users to the homeserver, and SHOULD query remote users as part of the search. The search is performed case-insensitively on user IDs and display names preferably using a collation determined based upon * the Accept-Language header provided in the request, if present.",
        "operationId" : "searchUsers",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/SearchRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The results of the search.",
            "schema" : {
              "$ref" : "#/definitions/SearchResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/r0/voip/turnServer" : {
      "get" : {
        "tags" : [ "VOIP" ],
        "summary" : "This API provides credentials for the client to use when initiating calls.",
        "description" : "",
        "operationId" : "turnServer",
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The TURN server credentials.",
            "schema" : {
              "$ref" : "#/definitions/VoipResponse"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/client/versions" : {
      "get" : {
        "tags" : [ "Version" ],
        "summary" : "Gets the versions of the specification supported by the server.",
        "description" : "",
        "operationId" : "versions",
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The versions supported by the server.",
            "schema" : {
              "$ref" : "#/definitions/VersionsResponse"
            }
          }
        }
      }
    },
    "/_matrix/media/r0/config" : {
      "get" : {
        "tags" : [ "Content" ],
        "summary" : "his endpoint allows clients to retrieve the configuration of the content repository, suchas upload limitations.",
        "description" : "Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available. NOTE: Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint.",
        "operationId" : "config",
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "The public content repository configuration for the matrix server.",
            "schema" : {
              "$ref" : "#/definitions/ContentConfig"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/media/r0/download/{serverName}/{mediaId}" : {
      "get" : {
        "tags" : [ "Content" ],
        "summary" : "Download content from the content repository.",
        "description" : "",
        "operationId" : "download",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded.",
            "schema" : {
              "$ref" : "#/definitions/OutputStream"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      }
    },
    "/_matrix/media/r0/download/{serverName}/{mediaId}/{fileName}" : {
      "get" : {
        "tags" : [ "Content" ],
        "summary" : "Download content from the content repository as a given filename.",
        "description" : "",
        "operationId" : "downloadFile",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fileName",
          "in" : "path",
          "description" : "The filename to give in the Content-Disposition.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded.",
            "schema" : {
              "$ref" : "#/definitions/OutputStream"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      }
    },
    "/_matrix/media/r0/preview_url" : {
      "get" : {
        "tags" : [ "Content" ],
        "summary" : "Get information about a PATH for a client.",
        "description" : "",
        "operationId" : "previewUrl",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "url",
          "in" : "query",
          "description" : "The PATH to get a preview of.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ts",
          "in" : "query",
          "description" : "The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded.",
            "schema" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/media/r0/thumbnail/{serverName}/{mediaId}" : {
      "get" : {
        "tags" : [ "Content" ],
        "summary" : "Download a thumbnail of the content from the content repository.",
        "description" : "",
        "operationId" : "thumbnail",
        "parameters" : [ {
          "name" : "serverName",
          "in" : "path",
          "description" : "The server name from the mxc:// URI (the authoritory component).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "mediaId",
          "in" : "path",
          "description" : "The media ID from the mxc:// URI (the path component)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "width",
          "in" : "query",
          "description" : "he desired width of the thumbnail. The actual thumbnail may not match the size specified.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "height",
          "in" : "query",
          "description" : "The desired height of the thumbnail. The actual thumbnail may not match the size specified.",
          "required" : false,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "method",
          "in" : "query",
          "description" : "The desired resizing method.",
          "required" : false,
          "type" : "string",
          "enum" : [ "['crop'", "'scale']" ]
        }, {
          "name" : "allow_remote",
          "in" : "query",
          "description" : "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided.",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The content that was previously uploaded.",
            "schema" : {
              "$ref" : "#/definitions/OutputStream"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        }
      }
    },
    "/_matrix/media/r0/upload" : {
      "post" : {
        "tags" : [ "Content" ],
        "summary" : "Upload some content to the content repository.",
        "description" : "",
        "operationId" : "upload",
        "consumes" : [ "multipart/form-data" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "The file content",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/InputStream"
          }
        }, {
          "name" : "filename",
          "in" : "query",
          "description" : "The name of the file being uploaded.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "Content-Type",
          "in" : "header",
          "description" : "The content type of the file being uploaded",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The MXC URI for the uploaded content.",
            "schema" : {
              "$ref" : "#/definitions/ContentUri"
            }
          },
          "429" : {
            "description" : "This request was rate-limited."
          }
        },
        "security" : [ {
          "Authorization" : [ ]
        } ]
      }
    },
    "/_matrix/static/client/login" : {
      "get" : {
        "tags" : [ "FallbackAuthentication" ],
        "summary" : "Fallback login.",
        "description" : "",
        "operationId" : "staticLogin",
        "produces" : [ "text/html" ],
        "responses" : {
          "200" : {
            "description" : "Login page for the fallback login.",
            "schema" : {
              "type" : "string"
            }
          }
        }
      }
    }
  },
  "securityDefinitions" : {
    "Authorization" : {
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header"
    }
  },
  "definitions" : {
    "AccountData" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "Account data."
    },
    "AdminResponse" : {
      "type" : "object",
      "properties" : {
        "devices" : {
          "type" : "object",
          "description" : "Each key is an identitfier for one of the user's devices",
          "additionalProperties" : {
            "$ref" : "#/definitions/DeviceInfo"
          }
        },
        "user_id" : {
          "type" : "string",
          "description" : "he Matrix user ID of the user."
        }
      },
      "description" : "Response for gets information about a particular user."
    },
    "Answer" : {
      "type" : "object",
      "required" : [ "sdp", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The type of session description. Must be 'answer'."
        },
        "sdp" : {
          "type" : "string",
          "description" : "The SDP text of the session description."
        }
      },
      "description" : "Answer"
    },
    "Audio" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata for the audio clip referred to in url.",
            "$ref" : "#/definitions/AudioInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the audio clip."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single audio clip."
      } ]
    },
    "AudioInfo" : {
      "type" : "object",
      "properties" : {
        "duration" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The duration of the audio in milliseconds."
        },
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the audio e.g. audio/aac."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The size of the audio clip in bytes."
        }
      },
      "description" : "Audio type."
    },
    "AuthenticationData" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Auth type."
        },
        "session" : {
          "type" : "string",
          "description" : "Session."
        },
        "user" : {
          "type" : "string",
          "description" : "user id."
        },
        "password" : {
          "type" : "string",
          "description" : "password."
        },
        "medium" : {
          "type" : "string",
          "description" : "3pid address type."
        },
        "address" : {
          "type" : "string",
          "description" : "3pid address."
        },
        "response" : {
          "type" : "string",
          "description" : "Captcha response."
        },
        "token" : {
          "type" : "string",
          "description" : "Auth token."
        },
        "uri" : {
          "type" : "string",
          "description" : "OAuth uri."
        },
        "threepidCreds" : {
          "type" : "array",
          "description" : "3pids credentials.",
          "items" : {
            "$ref" : "#/definitions/ThreePidCred"
          }
        },
        "txn_id" : {
          "type" : "string",
          "description" : "transaction id."
        }
      },
      "description" : "Authentication Data."
    },
    "AvailableResponse" : {
      "type" : "object",
      "properties" : {
        "available" : {
          "type" : "boolean",
          "description" : "A flag to indicate that the username is available. This should always be true when the server replies with 200 OK."
        }
      },
      "description" : "JSON response for available api"
    },
    "AvatarUrl" : {
      "type" : "object",
      "properties" : {
        "avatar_url" : {
          "type" : "string",
          "description" : "The new avatar URL for this user."
        }
      },
      "description" : "JSON body request for profile api."
    },
    "CallAnswer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "answer", "call_id", "version" ],
        "properties" : {
          "answer" : {
            "description" : "The session description object.",
            "$ref" : "#/definitions/Answer"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the callee when they wish to answer the call."
      } ]
    },
    "CallCandidates" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "candidates", "version" ],
        "properties" : {
          "candidates" : {
            "type" : "array",
            "description" : "Array of objects describing the candidates.",
            "items" : {
              "$ref" : "#/definitions/Candidate"
            }
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this messages adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by callers after sending an invite and by the callee after answering. Its purpose is to give the other party additional ICE candidates to try using to communicate."
      } ]
    },
    "CallHangup" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "version" ],
        "properties" : {
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "Sent by either party to signal their termination of the call. This can be sent either once the call has has been established or before to abort the call."
      } ]
    },
    "CallInvite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "lifetime", "offer", "version" ],
        "properties" : {
          "offer" : {
            "description" : "The session description object.",
            "$ref" : "#/definitions/Offer"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "lifetime" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The time in milliseconds that the invite is valid for. Once the invite age exceeds this value, clients should discard it. They should also no longer show the call as awaiting an answer in the UI."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the caller when they wish to establish a call."
      } ]
    },
    "Candidate" : {
      "type" : "object",
      "required" : [ "candidate", "sdpMLineIndex", "sdpMid" ],
      "properties" : {
        "sdpMid" : {
          "type" : "string",
          "description" : "The SDP media type this candidate is intended for."
        },
        "sdpMLineIndex" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The index of the SDP 'm' line this candidate is intended for."
        },
        "candidate" : {
          "type" : "string",
          "description" : "The SDP 'a' line of the candidate."
        }
      },
      "description" : "Candidate."
    },
    "ChangesResponse" : {
      "type" : "object",
      "properties" : {
        "changed" : {
          "type" : "array",
          "description" : "The Matrix User IDs of all users who updated their device identity keys.",
          "items" : {
            "type" : "string"
          }
        },
        "left" : {
          "type" : "array",
          "description" : "The Matrix User IDs of all users who may have left all the end-to-end encrypted rooms they previously shared with the user.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "The list of users who updated their devices."
    },
    "CharSequence" : {
      "type" : "object"
    },
    "CiphertextInfo" : {
      "type" : "object",
      "properties" : {
        "body" : {
          "type" : "string",
          "description" : "The encrypted payload."
        },
        "type" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The Olm message type."
        }
      },
      "description" : "Cipher text info."
    },
    "ClaimRequest" : {
      "type" : "object",
      "required" : [ "one_time_keys" ],
      "properties" : {
        "timeout" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default."
        },
        "one_time_keys" : {
          "type" : "object",
          "description" : "The keys to be claimed. A map from user ID, to a map from device ID to algorithm name.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "JSON body parameters for Claims one-time keys for use in pre-key messages."
    },
    "ClaimResponse" : {
      "type" : "object",
      "properties" : {
        "failures" : {
          "type" : "object",
          "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers.",
          "additionalProperties" : {
            "type" : "object"
          }
        },
        "one_time_keys" : {
          "type" : "object",
          "description" : "One-time keys for the queried devices. A map from user ID, to a map from &lt;algorithm&gt;:&lt;key_id&gt; to the key object.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            }
          }
        }
      },
      "description" : "Claim response format."
    },
    "ConnectionInfo" : {
      "type" : "object",
      "properties" : {
        "ip" : {
          "type" : "string",
          "description" : "Most recently seen IP address of the session."
        },
        "last_seen" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Unix timestamp that the session was last active."
        },
        "user_agent" : {
          "type" : "string",
          "description" : "User agent string last seen in the session."
        }
      },
      "description" : "Connection info."
    },
    "ContentConfig" : {
      "type" : "object",
      "properties" : {
        "m.upload.size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The maximum size an upload can be in bytes. Clients SHOULD use this as aguide when uploading content. If not listed or null, the size limit should be treated as unknown."
        }
      },
      "description" : "Content config."
    },
    "ContentUri" : {
      "type" : "object",
      "properties" : {
        "content_uri" : {
          "type" : "string",
          "description" : "MXC URI."
        }
      },
      "description" : "The MXC URI for the uploaded content"
    },
    "CreateRoomRequest" : {
      "type" : "object",
      "properties" : {
        "visibility" : {
          "type" : "string",
          "description" : "A public visibility indicates that the room will be shown in the published room list. A private visibility will hide the room from the published room list. Rooms default to private visibility if this key is not included. NB: This should not be confused with join_rules which also uses the word public.",
          "enum" : [ "public", "private" ]
        },
        "name" : {
          "type" : "string",
          "description" : "If this is included, an m.room.name event will be sent into the room to indicate the name of the room. See Room Events for more information on m.room.name."
        },
        "topic" : {
          "type" : "string",
          "description" : "If this is included, an m.room.topic event will be sent into the room to indicate the topic for the room. See Room Events for more information on m.room.topic."
        },
        "invite" : {
          "type" : "array",
          "description" : "A list of user IDs to invite to the room. This will tell the server to invite everyone in the list to the newly created room.",
          "items" : {
            "type" : "string"
          }
        },
        "preset" : {
          "type" : "string",
          "description" : "Convenience parameter for setting various default state events based on a preset.",
          "enum" : [ "private_chat", "public_chat", "trusted_private_chat" ]
        },
        "direct" : {
          "type" : "boolean"
        },
        "room_alias_name" : {
          "type" : "string",
          "description" : "The desired room alias local part. If this is included, a room alias will be created and mapped to the newly created room. The alias will belong on the same homeserver which created the room. For example, if this was set to \"foo\" and sent to the homeserver \"example.com\" the complete room alias would be #foo:example.com."
        },
        "invite_3pid" : {
          "type" : "array",
          "description" : "A list of objects representing third party IDs to invite into the room.",
          "items" : {
            "$ref" : "#/definitions/Invite3pid"
          }
        },
        "room_version" : {
          "type" : "string",
          "description" : "The room version to set for the room. If not provided, the homeserver is to use its configured default. If provided, the homeserver will return a 400 error with the errcode M_UNSUPPORTED_ROOM_VERSION if it does not support the room version."
        },
        "creation_content" : {
          "type" : "object",
          "description" : "Extra keys to be added to the content of the m.room.create. The server will clobber the following keys: creator. Future versions of the specification may allow the server to clobber other keys."
        },
        "initial_event" : {
          "type" : "array",
          "description" : "A list of state events to set in the new room. This allows the user to override the default state events set in the new room. The expected format of the state events are an object with type, state_key and content keys set.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        },
        "is_direct" : {
          "type" : "boolean",
          "description" : "This flag makes the server set the is_direct flag on the m.room.member events sent to the users in invite and invite_3pid. See Direct Messaging for more information."
        },
        "power_level_content_override" : {
          "description" : "The power level content to override in the default power level event. This object is applied on top of the generated m.room.power_levels event content prior to it being sent to the room. Defaults to overriding nothing.",
          "$ref" : "#/definitions/RoomPowerLevels"
        }
      },
      "description" : "JSON body request for creation api."
    },
    "DeactivateRequest" : {
      "type" : "object",
      "properties" : {
        "auth" : {
          "description" : "Additional authentication information for the user-interactive authentication API.",
          "$ref" : "#/definitions/AuthenticationData"
        }
      },
      "description" : "Request for deactivate the user's account, removing all ability for the user to login again."
    },
    "Delete3PidRequest" : {
      "type" : "object",
      "required" : [ "address", "medium" ],
      "properties" : {
        "medium" : {
          "type" : "string",
          "description" : "The medium of the third party identifier being removed",
          "enum" : [ "email", "msisdn" ]
        },
        "address" : {
          "type" : "string",
          "description" : "The third party address neing removed."
        }
      },
      "description" : "JSON body request to delte 3pid."
    },
    "DeprecatedInitialSyncResponse" : {
      "type" : "object",
      "required" : [ "end", "presence", "rooms" ],
      "properties" : {
        "end" : {
          "type" : "string",
          "description" : "A token which correlates to the last value in chunk. This token should be used with the /events API to listen for new events."
        },
        "presence" : {
          "type" : "array",
          "description" : "A list of presence events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        },
        "rooms" : {
          "type" : "array",
          "description" : "Rooms info.",
          "items" : {
            "$ref" : "#/definitions/DeprecatedRoomInfo"
          }
        },
        "accountData" : {
          "type" : "array",
          "description" : "The global private data create by this user.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "JSON body response of the deprecated initial sync."
    },
    "DeprecatedRoomInfo" : {
      "type" : "object",
      "required" : [ "membership", "room_id" ],
      "properties" : {
        "membership" : {
          "type" : "string",
          "description" : "The user's membership state in this room.",
          "enum" : [ "invite", "join", "leave", "ban" ]
        },
        "invite" : {
          "description" : "The invite event if membership is invite.",
          "$ref" : "#/definitions/Event"
        },
        "messages" : {
          "description" : "The pagination chunk for this room.",
          "$ref" : "#/definitions/PageEvent"
        },
        "state" : {
          "type" : "array",
          "description" : "If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        },
        "visibility" : {
          "type" : "string",
          "description" : "Whether this room is visible to the /publicRooms API or not.",
          "enum" : [ "private", "public" ]
        },
        "room_id" : {
          "type" : "string",
          "description" : "The ID of this room."
        },
        "account_data" : {
          "type" : "array",
          "description" : "The private data that this user has attached to this room.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "Deprecated room info."
    },
    "Device" : {
      "type" : "object",
      "required" : [ "device_id" ],
      "properties" : {
        "device_id" : {
          "type" : "string",
          "description" : "Identifier of this device."
        },
        "display_name" : {
          "type" : "string",
          "description" : "Display name set by the user for this device. Absent if no name has been set."
        },
        "last_seen_ip" : {
          "type" : "string",
          "description" : "The IP address where this device was last seen. (May be a few minutes out of date, for efficiency reasons)"
        },
        "last_seen_ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The timestamp (in milliseconds since the unix epoch) when this devices was last seen. (May be a few minutes out of date, for efficiency reasons)."
        }
      },
      "description" : "Device"
    },
    "DeviceDeleteRequest" : {
      "type" : "object",
      "properties" : {
        "auth" : {
          "description" : "Authentication information.",
          "$ref" : "#/definitions/AuthenticationData"
        }
      },
      "description" : "Additional authentication information for the user-interactive authentication API."
    },
    "DeviceInfo" : {
      "type" : "object",
      "properties" : {
        "sessions" : {
          "type" : "array",
          "description" : "A user's sessions (i.e. what they did with an access token from one login)",
          "items" : {
            "$ref" : "#/definitions/SessionInfo"
          }
        }
      },
      "description" : "Device info"
    },
    "DeviceKeys" : {
      "type" : "object",
      "required" : [ "algorithms", "device_id", "keys", "signatures", "user_id" ],
      "properties" : {
        "algorithms" : {
          "type" : "array",
          "description" : "The encryption algorithms supported by this device.",
          "items" : {
            "type" : "string"
          }
        },
        "keys" : {
          "type" : "object",
          "description" : "Public identity keys. The names of the properties should be in the format &lt;algorithm&gt;:&lt;device_id&gt;. The keys themselves should be encoded as specified by the key algorithm.",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "signatures" : {
          "type" : "object",
          "description" : "Signatures for the device key object. A map from user ID, to a map from (algorithm):(device_id) to the signature.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        },
        "unsignedDeviceInfo" : {
          "description" : "Additional data added to the device key information by intermediate servers, and not covered by the signatures.",
          "$ref" : "#/definitions/UnsignedDeviceInfo"
        },
        "user_id" : {
          "type" : "string",
          "description" : "The ID of the user the device belongs to. Must match the user ID used when logging in."
        },
        "device_id" : {
          "type" : "string",
          "description" : "The ID of the device these keys belong to. Must match the device ID used when logging in."
        }
      },
      "description" : "Device keys."
    },
    "DeviceLists" : {
      "type" : "object",
      "properties" : {
        "changed" : {
          "type" : "array",
          "description" : "List of users who have updated their device identity keys since the previous sync response.",
          "items" : {
            "type" : "string"
          }
        },
        "left" : {
          "type" : "array",
          "description" : "List of users with whom we do not share any encrypted rooms anymore since the previous sync response.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "Device lists."
    },
    "DeviceUpdateRequest" : {
      "type" : "object",
      "properties" : {
        "display_name" : {
          "type" : "string",
          "description" : "The new display name."
        }
      },
      "description" : "The new display name for this device. If not given, the display name is unchanged."
    },
    "DevicesDeleteRequest" : {
      "type" : "object",
      "required" : [ "devices" ],
      "properties" : {
        "devices" : {
          "type" : "array",
          "description" : "The list of device IDs to delete.",
          "items" : {
            "type" : "string"
          }
        },
        "auth" : {
          "description" : "Additional authentication information for the user-interactive authentication API.",
          "$ref" : "#/definitions/AuthenticationData"
        }
      },
      "description" : "JSON body request for bulk devices delete."
    },
    "DevicesResponse" : {
      "type" : "object",
      "properties" : {
        "devices" : {
          "type" : "array",
          "description" : "A list of all registered devices for this user.",
          "items" : {
            "$ref" : "#/definitions/Device"
          }
        }
      },
      "description" : "Information about all devices for the current user."
    },
    "Direct" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID."
      } ]
    },
    "DisplayName" : {
      "type" : "object",
      "properties" : {
        "displayname" : {
          "type" : "string",
          "description" : "The new display name for this user."
        }
      },
      "description" : "JSON body request for profile api."
    },
    "EmailRequestToken" : {
      "type" : "object",
      "required" : [ "client_secret", "email", "id_server", "send_attempt" ],
      "properties" : {
        "email" : {
          "type" : "string",
          "description" : "The email address to validate"
        },
        "id_server" : {
          "type" : "string",
          "description" : "The hostname of the identity server to communicate with. May optionally include a port."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
        },
        "send_attempt" : {
          "type" : "string",
          "description" : "The server will only send an email if the send_attempt is a number greater than the most recent one which it has seen, scoped to that email + client_secret pair. This is to avoid repeatedly sending the same email in the case of request retries between the POSTing user and the identity server.The client should increment this value if they desire a new email(e.g.a reminder) to be sent ."
        }
      },
      "description" : "Request for the proxies the identity server API validate/email/requestToken."
    },
    "Emote" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is similar to m.text except that the sender is 'performing' the action contained in the body key, similar to /me in IRC. This message should be prefixed by the name of the sender. This message could also be represented in a different colour to distinguish it from regular m.text messages."
      } ]
    },
    "EmptyResponse" : {
      "type" : "object",
      "description" : "Empty response"
    },
    "EncryptedFile" : {
      "type" : "object",
      "required" : [ "iv", "key", "url", "v" ],
      "properties" : {
        "url" : {
          "type" : "string",
          "description" : "the URL to the file."
        },
        "key" : {
          "description" : "A JSON Web Key object.",
          "$ref" : "#/definitions/JWK"
        },
        "iv" : {
          "type" : "string",
          "description" : " The Initialisation Vector used by AES-CTR, encoded as unpadded base64."
        },
        "hashes" : {
          "type" : "object",
          "description" : "A map from an algorithm name to a hash of the ciphertext, encoded as unpadded base64. Clients should support the SHA-256 hash, which uses the key sha256.",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "v" : {
          "type" : "string",
          "description" : "Version of the encrypted attachments protocol. Must be v2."
        }
      },
      "description" : "Encrypted file."
    },
    "Ephemeral" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "Ephemeral."
    },
    "Event" : {
      "type" : "object",
      "required" : [ "event_id", "origin_server_ts", "room_id", "sender", "state_key", "type" ],
      "properties" : {
        "content" : {
          "description" : "The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.",
          "$ref" : "#/definitions/EventContent"
        },
        "type" : {
          "type" : "string",
          "description" : "The type of event. This SHOULD be namespaced similar to Java package naming conventions."
        },
        "sender" : {
          "type" : "string",
          "description" : "Contains the fully-qualified ID of the user who sent this event."
        },
        "unsigned" : {
          "description" : "Contains optional extra information about the event.",
          "$ref" : "#/definitions/Unsigned"
        },
        "event_id" : {
          "type" : "string",
          "description" : "The globally unique event identifier."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The ID of the room associated with this event."
        },
        "origin_server_ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Timestamp in milliseconds on originating homeserver when this event was sent."
        },
        "prev_content" : {
          "description" : "The previous content for this event. If there is no previous content, this key will be missing.",
          "$ref" : "#/definitions/EventContent"
        },
        "state_key" : {
          "type" : "string",
          "description" : " A unique key which defines the overwriting semantics for this piece of room state. This value is often a zero-length string. The presence of this key makes this event a State Event. The key MUST NOT start with '_'."
        },
        "invite_room_state" : {
          "type" : "array",
          "description" : "This contains an array of StrippedState Events. These events provide information on a subset of state events such as the room name.",
          "items" : {
            "$ref" : "#/definitions/StrippedState"
          }
        }
      },
      "description" : "Event."
    },
    "EventContent" : {
      "type" : "object",
      "discriminator" : "type",
      "description" : "Parent class of all event contents part in the Event."
    },
    "EventContext" : {
      "type" : "object",
      "properties" : {
        "before_limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "How many events before the result are returned."
        },
        "after_limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "How many events after the result are returned."
        },
        "include_profile" : {
          "type" : "boolean",
          "description" : "Requests that the server returns the historic profile information for the users that sent the events that were returned."
        }
      },
      "description" : "Event context."
    },
    "EventContextResponse" : {
      "type" : "object",
      "properties" : {
        "start" : {
          "type" : "string",
          "description" : "A token that can be used to paginate backwards with."
        },
        "end" : {
          "type" : "string",
          "description" : "A token that can be used to paginate forwards with."
        },
        "event" : {
          "description" : "Details of the requested event.",
          "$ref" : "#/definitions/Event"
        },
        "state" : {
          "description" : "The state of the room at the last event returned.",
          "$ref" : "#/definitions/Event"
        },
        "events_before" : {
          "type" : "array",
          "description" : "A list of room events that happened just before the requested event, in reverse-chronological order.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        },
        "events_after" : {
          "type" : "array",
          "description" : "A list of room events that happened just after the requested event, in chronological order.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "Events that happened just before and after the specified event."
    },
    "EventFilter" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The maximum number of events to return."
        },
        "senders" : {
          "type" : "array",
          "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
          "items" : {
            "type" : "string"
          }
        },
        "types" : {
          "type" : "array",
          "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        },
        "not_senders" : {
          "type" : "array",
          "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
          "items" : {
            "type" : "string"
          }
        },
        "not_types" : {
          "type" : "array",
          "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "Filter."
    },
    "FieldMetadata" : {
      "type" : "object",
      "required" : [ "placeholder", "regexp" ],
      "properties" : {
        "regexp" : {
          "type" : "string",
          "description" : "A regular expression for validation of a field's value."
        },
        "placeholder" : {
          "type" : "string",
          "description" : "An placeholder serving as a valid example of the field value."
        }
      },
      "description" : "Definition of valid values for a field."
    },
    "File" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "filename", "url" ],
        "properties" : {
          "filename" : {
            "type" : "string",
            "description" : "The original filename of the uploaded file."
          },
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/FileInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a generic file."
      } ]
    },
    "FileInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        }
      },
      "description" : "File info."
    },
    "Filter" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The maximum number of events to return."
        },
        "senders" : {
          "type" : "array",
          "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
          "items" : {
            "type" : "string"
          }
        },
        "types" : {
          "type" : "array",
          "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        },
        "rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to include. If this list is absent then all rooms are included.",
          "items" : {
            "type" : "string"
          }
        },
        "not_senders" : {
          "type" : "array",
          "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
          "items" : {
            "type" : "string"
          }
        },
        "not_types" : {
          "type" : "array",
          "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        },
        "not_rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter.",
          "items" : {
            "type" : "string"
          }
        },
        "contains_url" : {
          "type" : "boolean",
          "description" : "If true, includes only events with a url key in their content. If false, excludes those events. Defaults to false."
        }
      },
      "description" : "Filter."
    },
    "FilterData" : {
      "type" : "object",
      "properties" : {
        "presence" : {
          "description" : "The presence updates to include.",
          "$ref" : "#/definitions/EventFilter"
        },
        "room" : {
          "description" : "Filters to be applied to room data.",
          "$ref" : "#/definitions/RoomFilter"
        },
        "event_fields" : {
          "type" : "array",
          "description" : "List of event fields to include. If this list is absent then all fields are included. The entries may include '.' charaters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a ''. A server may include more fields than were requested.",
          "items" : {
            "type" : "string"
          }
        },
        "event_format" : {
          "type" : "string",
          "description" : "The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as receieved over federation. The default is 'client'.",
          "enum" : [ "client", "federation" ]
        },
        "account_data" : {
          "description" : "The user account data that isn't associated with rooms to include.",
          "$ref" : "#/definitions/EventFilter"
        }
      },
      "description" : "JSON body request for filter api."
    },
    "FilterResponse" : {
      "type" : "object",
      "required" : [ "filter_id" ],
      "properties" : {
        "filter_id" : {
          "type" : "string",
          "description" : "The ID of the filter that was created. Cannot start with a { as this character is used to determine if the filter provided is inline JSON or a previously declared filter by homeservers on some APIs."
        }
      },
      "description" : "JSON body response."
    },
    "ForwardedRoomKey" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "forwarding_curve25519_key_chain", "room_id", "sender_claimed_ed25519_key", "sender_key", "session_id", "session_key" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "Required. The encryption algorithm the key in this event is to be used with."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "sender_key" : {
            "type" : "string",
            "description" : "Required. The Curve25519 key of the device which initiated the session originally."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          },
          "sender_claimed_ed25519_key" : {
            "type" : "string",
            "description" : "The Ed25519 key of the device which initiated the session originally. It is 'claimed' because the receiving device has no way to tell that the original room_key actually came from a device which owns the private partof this key unless they have done device verification."
          },
          "forwarding_curve25519_key_chain" : {
            "type" : "array",
            "description" : "Chain of Curve25519 keys. It starts out empty, but each time the key is forwarded to another device, the previous sender in the chain is added to the end of the list. For example, if the key is forwarded from A to B to C, this field is empty between A and B, and contains A's Curve25519 key between B and C.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event type is used to forward keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event."
      } ]
    },
    "FullyRead" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "event_id" ],
        "properties" : {
          "event_id" : {
            "type" : "string",
            "description" : "The event the user's read marker is located at in the room."
          }
        },
        "description" : "The current location of the user's read marker in a room. This event appears in the user's room account data for the room the marker is applicable for."
      } ]
    },
    "Group" : {
      "type" : "object",
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "Key that defines the group.",
          "enum" : [ "room_id", "sender" ]
        }
      },
      "description" : "Group."
    },
    "GroupValue" : {
      "type" : "object",
      "properties" : {
        "order" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Key that can be used to order different groups."
        },
        "results" : {
          "type" : "array",
          "description" : "Which results are in this group.",
          "items" : {
            "type" : "string"
          }
        },
        "next_batch" : {
          "type" : "string",
          "description" : "Token that can be used to get the next batch of results in the group, by passing as the next_batch parameter to the next call. If this field is absent, there are no more results in this group."
        }
      },
      "description" : "Group value."
    },
    "Groupings" : {
      "type" : "object",
      "properties" : {
        "group_by" : {
          "type" : "array",
          "description" : "List of groups to request.",
          "items" : {
            "$ref" : "#/definitions/Group"
          }
        }
      },
      "description" : "Groupings."
    },
    "HomeserverInfo" : {
      "type" : "object",
      "required" : [ "base_url" ],
      "properties" : {
        "base_url" : {
          "type" : "string",
          "description" : "The base URL for the homeserver for client-server connections."
        }
      },
      "description" : "Homeserver information."
    },
    "Identifier" : {
      "type" : "object",
      "required" : [ "type" ],
      "discriminator" : "type",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Identifier type."
        }
      },
      "description" : "Identifier types."
    },
    "IdentityServerInfo" : {
      "type" : "object",
      "required" : [ "base_url" ],
      "properties" : {
        "base_url" : {
          "type" : "string",
          "description" : "The base URL for the identity server for client-server connections."
        }
      },
      "description" : "Identity server information."
    },
    "IgnoredUserList" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "ignoredUsers" ],
        "properties" : {
          "ignoredUsers" : {
            "type" : "object",
            "description" : "The map of users to ignore.",
            "additionalProperties" : {
              "type" : "object"
            }
          }
        },
        "description" : "A map of users which are considered ignored is kept in account_data in an event type of m.ignored_user_list."
      } ]
    },
    "Image" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single image and an optional thumbnail."
      } ]
    },
    "ImageInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Image info."
    },
    "InputStream" : {
      "type" : "object"
    },
    "Instance" : {
      "type" : "object",
      "required" : [ "desc", "fields", "network_id" ],
      "properties" : {
        "desc" : {
          "type" : "string",
          "description" : "Description."
        },
        "icon" : {
          "type" : "string",
          "description" : "An optional content URI representing the protocol. Overrides the one provided at the higher level Protocol object."
        },
        "fields" : {
          "type" : "object",
          "description" : "Preset values for fields the client may use to search by.",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "network_id" : {
          "type" : "string",
          "description" : "A unique identifier across all instances."
        }
      },
      "description" : "Instance."
    },
    "Invite" : {
      "type" : "object",
      "required" : [ "display_name", "signed" ],
      "properties" : {
        "signed" : {
          "description" : "A block of content which has been signed, which servers can use to verify the event. Clients should ignore this.",
          "$ref" : "#/definitions/Signed"
        },
        "display_name" : {
          "type" : "string",
          "description" : "A name which can be displayed to represent the user instead of their third party identifier."
        }
      },
      "description" : "Third-party invites."
    },
    "Invite3pid" : {
      "type" : "object",
      "required" : [ "address", "id_server", "medium" ],
      "properties" : {
        "medium" : {
          "type" : "string",
          "description" : "The kind of address being passed in the address field, for example email."
        },
        "address" : {
          "type" : "string",
          "description" : "The invitee's third party identifier."
        },
        "id_server" : {
          "type" : "string",
          "description" : "The hostname+port of the identity server which should be used for third party identifier lookups."
        }
      },
      "description" : "Invite 3pid."
    },
    "InviteRequest" : {
      "type" : "object",
      "required" : [ "address", "id_server", "medium", "user_id" ],
      "properties" : {
        "medium" : {
          "type" : "string",
          "description" : "The kind of address being passed in the address field, for example email."
        },
        "address" : {
          "type" : "string",
          "description" : "The invitee's third party identifier."
        },
        "user_id" : {
          "type" : "string",
          "description" : "The fully qualified user ID of the invitee."
        },
        "id_server" : {
          "type" : "string",
          "description" : "The hostname+port of the identity server which should be used for third party identifier lookups."
        }
      },
      "description" : "Invite request."
    },
    "InviteState" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of events.",
          "items" : {
            "$ref" : "#/definitions/StrippedState"
          }
        }
      },
      "description" : "Invite state."
    },
    "InvitedRoom" : {
      "type" : "object",
      "properties" : {
        "invite_state" : {
          "description" : "The state of a room that the user has been invited to. These state events may only have the sender, type, state_key and content keys present. These events do not replace any state that the client already has for the room, for example if the client has archived the room. Instead the client should keep two separate copies of the state: the one from the invite_state and one from the archived state.If the client joins the room then the current state will be given as a delta against the archived state not the invite_state.",
          "$ref" : "#/definitions/InviteState"
        }
      },
      "description" : "Invite room."
    },
    "JWK" : {
      "type" : "object",
      "required" : [ "alg", "ext", "k", "key", "key_opts" ],
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "Key type. Must be oct."
        },
        "alg" : {
          "type" : "string",
          "description" : "Algorithm, Must be A256CTR."
        },
        "ext" : {
          "type" : "boolean",
          "description" : "Extractable. Must be true. This is a W3C extension."
        },
        "key_opts" : {
          "type" : "array",
          "description" : "Key operations, Must at least contain encrypt and decrypt.",
          "items" : {
            "type" : "string"
          }
        },
        "k" : {
          "type" : "string",
          "description" : "The key, encoded as urlsafe unpadded base64."
        }
      },
      "description" : "JSON Web Key."
    },
    "JoinRequest" : {
      "type" : "object",
      "properties" : {
        "third_party_signed" : {
          "description" : "A signature of an m.third_party_invite token to prove that this user owns a third party identity which has been invited to the room.",
          "$ref" : "#/definitions/ThirdPartySigned"
        }
      },
      "description" : "Join request."
    },
    "JoinedMembersResponse" : {
      "type" : "object",
      "properties" : {
        "joined" : {
          "type" : "object",
          "description" : "A map from user ID to a RoomMember object.",
          "additionalProperties" : {
            "$ref" : "#/definitions/RoomMember"
          }
        }
      },
      "description" : "Joined room members."
    },
    "JoinedRoom" : {
      "type" : "object",
      "properties" : {
        "state" : {
          "description" : "Updates to the state, between the time indicated by the since parameter, and the start of the timeline (or all state up to the start of the timeline, if since is not given, or full_state is true).",
          "$ref" : "#/definitions/State"
        },
        "timeline" : {
          "description" : "The timeline of messages and state changes in the room.",
          "$ref" : "#/definitions/Timeline"
        },
        "ephemeral" : {
          "description" : "The ephemeral events in the room that aren't recorded in the timeline or state of the room. e.g. typing.",
          "$ref" : "#/definitions/Ephemeral"
        },
        "account_data" : {
          "description" : "The private data that this user has attached to this room.",
          "$ref" : "#/definitions/AccountData"
        },
        "unread_notifications" : {
          "description" : "Counts of unread notifications for this room.",
          "$ref" : "#/definitions/UnreadNotificationCounts"
        }
      },
      "description" : "Joined room."
    },
    "JoinedRoomsResponse" : {
      "type" : "object",
      "required" : [ "joined_rooms" ],
      "properties" : {
        "joined_rooms" : {
          "type" : "array",
          "description" : "The ID of each room in which the user has joined membership.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "JSON body resposnse with joined rooms."
    },
    "KickRequest" : {
      "type" : "object",
      "required" : [ "user_id" ],
      "properties" : {
        "reason" : {
          "type" : "string",
          "description" : "The reason the user has been kicked."
        },
        "user_id" : {
          "type" : "string",
          "description" : "The fully qualified user ID of the user being kicked."
        }
      },
      "description" : "Kick JSON body request."
    },
    "LeftRoom" : {
      "type" : "object",
      "properties" : {
        "state" : {
          "description" : "The state updates for the room up to the start of the timeline.",
          "$ref" : "#/definitions/State"
        },
        "timeline" : {
          "description" : "The timeline of messages and state changes in the room up to the point when the user left.",
          "$ref" : "#/definitions/Timeline"
        },
        "account_data" : {
          "description" : "The private data that this user has attached to this room.",
          "$ref" : "#/definitions/AccountData"
        }
      },
      "description" : "Left room."
    },
    "Location" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "geo_uri" ],
        "properties" : {
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/LocationInfo"
          },
          "geo_uri" : {
            "type" : "string",
            "description" : "A geo URI representing this location."
          }
        },
        "description" : "This message represents a real-world location."
      } ]
    },
    "LocationInfo" : {
      "type" : "object",
      "properties" : {
        "thumbnailFile" : {
          "description" : "Information on the encrypted thumbnail file, as specified in End-to-end encryption. Only present if the thumbnail is encrypted.",
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the location being represented."
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        }
      },
      "description" : "Location info."
    },
    "LoginRequest" : {
      "type" : "object",
      "required" : [ "identifier", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The login type being used",
          "enum" : [ "m.login.password", "m.login.token" ]
        },
        "identifier" : {
          "description" : "Identification information for the user.",
          "$ref" : "#/definitions/Identifier"
        },
        "user" : {
          "type" : "string",
          "description" : "he fully qualified user ID or just local part of the user ID, to log in."
        },
        "medium" : {
          "type" : "string",
          "description" : "When logging in using a third party identifier, the medium of the identifier. Must be 'email'."
        },
        "address" : {
          "type" : "string",
          "description" : "Third party identifier for the user"
        },
        "password" : {
          "description" : "Required when type is m.login.password. The user's password.",
          "$ref" : "#/definitions/CharSequence"
        },
        "token" : {
          "type" : "string",
          "description" : "Required when type is m.login.token. The login token"
        },
        "device_id" : {
          "type" : "string",
          "description" : "ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified"
        },
        "initial_device_display_name" : {
          "type" : "string",
          "description" : "A display name to assign to the newly-created device. Ignored if device_id corresponds to a known device."
        }
      },
      "description" : "Authenticates the user, and issues an access token they can use to authorize themself in subsequent requests"
    },
    "LoginResponse" : {
      "type" : "object",
      "properties" : {
        "user_id" : {
          "type" : "string",
          "description" : "The fully-qualified Matrix ID that has been registered."
        },
        "access_token" : {
          "type" : "string",
          "description" : "An access token for the account. This access token can then be used to authorize other requests."
        },
        "home_server" : {
          "type" : "string",
          "description" : "The hostname of the homeserver on which the account has been registered."
        },
        "device_id" : {
          "type" : "string",
          "description" : "ID of the logged-in device. Will be the same as the corresponding parameter in the request, if one was specified."
        }
      },
      "description" : "JSON body response for the login api."
    },
    "LoginType" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Type of the authentication stage."
        }
      },
      "description" : "Login type."
    },
    "MegolmEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomEncrypted"
      }, {
        "type" : "object",
        "required" : [ "ciphertext" ],
        "properties" : {
          "ciphertext" : {
            "type" : "string",
            "description" : "The encrypted content of the event. The encrypted payload itself."
          }
        },
        "description" : "Megolm encrypted message."
      } ]
    },
    "MembersResponse" : {
      "type" : "object",
      "properties" : {
        "chunk" : {
          "type" : "array",
          "description" : "Member events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "The list of members for this room."
    },
    "MsisdnRequestToken" : {
      "type" : "object",
      "required" : [ "client_secret", "country", "id_server", "phone_number", "send_attempt" ],
      "properties" : {
        "country" : {
          "type" : "string",
          "description" : "The two-letter uppercase ISO country code that the number in phone_number should be parsed as if it were dialled from."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
        },
        "phone_number" : {
          "type" : "string",
          "description" : "The phone number to validate."
        },
        "send_attempt" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The server will only send an SMS if the send_attempt is a number greater than the most recent one which it has seen, scoped to that country + phone_number + client_secret triple. This is to avoid repeatedly sending the same SMS in the case of request retries between the POSTing user and the identity server. The client should increment this value if they desire a new SMS (e.g. a reminder) to be sent."
        },
        "next_link" : {
          "type" : "string",
          "description" : "When the validation is completed, the identity server will redirect the user to this URL."
        },
        "id_server" : {
          "type" : "string",
          "description" : "The hostname of the identity server to communicate with. May optionally include a port."
        }
      },
      "description" : "Request for the proxies the identity server API validate/msisdn/requestToken."
    },
    "Notice" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "The ``m.notice`` type is primarily intended for responses from automated clients. An ``m.notice`` message must be treated the same way as a regular ``m.text`` message with two exceptions. Firstly, clients should present ``m.notice`` messages to users in a distinct manner, and secondly, ``m.notice`` messages must never be automatically responded to. This helps to prevent infinite-loop situations where two automated clients continuously exchange messages."
      } ]
    },
    "Notification" : {
      "type" : "object",
      "required" : [ "actions", "event", "read", "room_id", "ts" ],
      "properties" : {
        "actions" : {
          "type" : "array",
          "description" : "The action(s) to perform when the conditions for this rule are met. See Push Rules: API.",
          "items" : {
            "type" : "object"
          }
        },
        "event" : {
          "description" : "The Event object for the event that triggered the notification.",
          "$ref" : "#/definitions/Event"
        },
        "read" : {
          "type" : "boolean",
          "description" : "Indicates whether the user has sent a read receipt indicating that they have read this message."
        },
        "ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The unix timestamp at which the event notification was sent, in milliseconds."
        },
        "profile_tag" : {
          "type" : "string",
          "description" : "The profile tag of the rule that matched this event."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The ID of the room in which the event was posted."
        }
      },
      "description" : "Notification"
    },
    "NotificationPowerLevel" : {
      "type" : "object",
      "properties" : {
        "room" : {
          "type" : "string",
          "format" : "byte",
          "description" : "The level required to trigger an @room notification. Defaults to 50 if unspecified."
        }
      },
      "description" : "Notifications."
    },
    "NotificationResponse" : {
      "type" : "object",
      "required" : [ "notifications" ],
      "properties" : {
        "notifications" : {
          "type" : "array",
          "description" : "The list of events that triggered notifications.",
          "items" : {
            "$ref" : "#/definitions/Notification"
          }
        },
        "next_token" : {
          "type" : "string",
          "description" : "The token to supply in the from param of the next /notifications request in order to request more events. If this is absent, there are no more results."
        }
      },
      "description" : "JSON body response for push notifications."
    },
    "Offer" : {
      "type" : "object",
      "required" : [ "sdp", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The type of session description. Must be 'offer'."
        },
        "sdp" : {
          "type" : "string",
          "description" : "The SDP text of the session description."
        }
      },
      "description" : "Offer"
    },
    "OlmEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomEncrypted"
      }, {
        "type" : "object",
        "required" : [ "ciphertext" ],
        "properties" : {
          "ciphertext" : {
            "type" : "object",
            "description" : "The encrypted content of the event. A map from the recipient Curve25519 identity key to ciphertext information. For more details, see Messaging Algorithms.",
            "additionalProperties" : {
              "$ref" : "#/definitions/CiphertextInfo"
            }
          }
        },
        "description" : "Olm encrypted message."
      } ]
    },
    "OpenIdResponse" : {
      "type" : "object",
      "required" : [ "access_token", "expires_in", "matrix_server_name", "token_type" ],
      "properties" : {
        "access_token" : {
          "type" : "string",
          "description" : "An access token the consumer may use to verify the identity of the person who generated the token. This is given to the federation API GET /openid/userinfo."
        },
        "token_type" : {
          "type" : "string",
          "description" : "The string Bearer."
        },
        "matrix_server_name" : {
          "type" : "string",
          "description" : "The homeserver domain the consumer should use when attempting to verify the user's identity."
        },
        "expires_in" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The number of seconds before this token expires and a new one must be generated."
        }
      },
      "description" : "JSON body response of the OpenID API."
    },
    "OutputStream" : {
      "type" : "object"
    },
    "Page" : {
      "type" : "object",
      "properties" : {
        "start" : {
          "type" : "string",
          "description" : "The token the pagination starts from. If dir=b this will be the token supplied in from."
        },
        "end" : {
          "type" : "string",
          "description" : "The token the pagination ends at. If dir=b this token should be used again to request even earlier events."
        },
        "chunk" : {
          "type" : "array",
          "description" : "A list of room events.",
          "items" : {
            "type" : "object"
          }
        }
      },
      "description" : "Pagination."
    },
    "PageEvent" : {
      "type" : "object",
      "properties" : {
        "start" : {
          "type" : "string",
          "description" : "The token the pagination starts from. If dir=b this will be the token supplied in from."
        },
        "end" : {
          "type" : "string",
          "description" : "The token the pagination ends at. If dir=b this token should be used again to request even earlier events."
        },
        "chunk" : {
          "type" : "array",
          "description" : "A list of room events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "Pagination."
    },
    "PasswordRequest" : {
      "type" : "object",
      "required" : [ "new_password" ],
      "properties" : {
        "auth" : {
          "description" : "Additional authentication information for the user-interactive authentication API.",
          "$ref" : "#/definitions/AuthenticationData"
        },
        "new_password" : {
          "type" : "string",
          "description" : "The new password for the account."
        }
      },
      "description" : "Request for changes the password for an account on this homeserver."
    },
    "PhoneIdentifier" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Identifier"
      }, {
        "type" : "object",
        "required" : [ "country", "phone" ],
        "properties" : {
          "country" : {
            "type" : "string",
            "description" : "The country that the phone number is from."
          },
          "phone" : {
            "type" : "string",
            "description" : "The phone number."
          }
        },
        "description" : "The user is identified by a phone number."
      } ]
    },
    "Presence" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "presence" ],
        "properties" : {
          "presence" : {
            "type" : "string",
            "description" : "The presence state for this user.",
            "enum" : [ "online", "offline", "unavailable" ]
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The current avatar URL for this user, if any."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The current display name for this user, if any."
          },
          "last_active_ago" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The last time since this used performed some action, in milliseconds."
          },
          "currently_active" : {
            "type" : "boolean",
            "description" : "Whether the user is currently active."
          }
        },
        "description" : "Informs the client of a user's presence state change."
      } ]
    },
    "PresenceList" : {
      "type" : "object",
      "properties" : {
        "invite" : {
          "type" : "array",
          "description" : "A list of user IDs to add to the list.",
          "items" : {
            "type" : "string"
          }
        },
        "drop" : {
          "type" : "array",
          "description" : "A list of user IDs to remove from the list.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "JSON body request for presence api."
    },
    "PresenceRequest" : {
      "type" : "object",
      "required" : [ "presence" ],
      "properties" : {
        "presence" : {
          "type" : "string",
          "description" : "The new presence state.",
          "enum" : [ "online", "offline", "unavailable" ]
        },
        "status_msg" : {
          "type" : "string",
          "description" : "The status message to attach to this state."
        }
      },
      "description" : "JSON body request for presence api."
    },
    "PresenceStatus" : {
      "type" : "object",
      "required" : [ "presence" ],
      "properties" : {
        "presence" : {
          "type" : "string",
          "description" : "The new presence state.",
          "enum" : [ "online", "offline", "unavailable" ]
        },
        "status_msg" : {
          "type" : "string",
          "description" : "The status message to attach to this state."
        },
        "last_active_ago" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The length of time in milliseconds since an action was performed by this user."
        },
        "currently_active" : {
          "type" : "boolean",
          "description" : "Whether the user is currently active."
        }
      },
      "description" : "JSON body request for presence api."
    },
    "Profile" : {
      "type" : "object",
      "properties" : {
        "avatar_url" : {
          "type" : "string",
          "description" : "The user's avatar URL if they have set one, otherwise not present."
        },
        "displayname" : {
          "type" : "string",
          "description" : "The user's display name if they have set one, otherwise not present."
        }
      },
      "description" : "JSON body for profile api (profile)."
    },
    "Protocol" : {
      "type" : "object",
      "required" : [ "field_types", "icon", "instances", "location_fields", "user_fields" ],
      "properties" : {
        "icon" : {
          "type" : "string",
          "description" : "An icon representing the third party protocol."
        },
        "instances" : {
          "type" : "array",
          "description" : "A list of objects representing independent instances of configuration. For instance multiple networkson IRC if multiple are bridged by the same bridge.",
          "items" : {
            "$ref" : "#/definitions/Instance"
          }
        },
        "user_fields" : {
          "type" : "array",
          "description" : "Fields used to identify a third party user.",
          "items" : {
            "type" : "string"
          }
        },
        "location_fields" : {
          "type" : "array",
          "description" : "Fields used to identify a third party location.",
          "items" : {
            "type" : "string"
          }
        },
        "field_types" : {
          "type" : "object",
          "description" : "All location or user fields should have an entry here.",
          "additionalProperties" : {
            "$ref" : "#/definitions/FieldMetadata"
          }
        }
      },
      "description" : "Protocol metadata."
    },
    "ProtocolLocation" : {
      "type" : "object",
      "required" : [ "alias", "fields", "protocol" ],
      "properties" : {
        "alias" : {
          "type" : "string",
          "description" : "An alias for a matrix room."
        },
        "protocol" : {
          "type" : "string",
          "description" : "The protocol ID that the third party location is a part of."
        },
        "fields" : {
          "type" : "object",
          "description" : "Information used to identify this third party location.",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Protocol Location."
    },
    "ProtocolUser" : {
      "type" : "object",
      "required" : [ "fields", "protocol", "userid" ],
      "properties" : {
        "userid" : {
          "type" : "string",
          "description" : "A Matrix User ID represting a third party user."
        },
        "protocol" : {
          "type" : "string",
          "description" : "The protocol ID that the third party location is a part of."
        },
        "fields" : {
          "type" : "object",
          "description" : "Information used to identify this third party location.",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Protocol User."
    },
    "PublicKeys" : {
      "type" : "object",
      "required" : [ "publicKey" ],
      "properties" : {
        "publicKey" : {
          "type" : "string",
          "description" : "A base-64 encoded ed25519 key with which token may be signed."
        },
        "key_validity_url" : {
          "type" : "string",
          "description" : "An optional URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'. If this URL is absent, the key must be considered valid indefinitely."
        }
      },
      "description" : "Public keys."
    },
    "PublicRoomsChunk" : {
      "type" : "object",
      "required" : [ "guest_can_join", "num_joined_members", "room_id", "world_readable" ],
      "properties" : {
        "aliases" : {
          "type" : "array",
          "description" : "Aliases of the room. May be empty.",
          "items" : {
            "type" : "string"
          }
        },
        "name" : {
          "type" : "string",
          "description" : "The name of the room, if any."
        },
        "topic" : {
          "type" : "string",
          "description" : "The topic of the room, if any."
        },
        "canonical_alias" : {
          "type" : "string",
          "description" : "The canonical alias of the room, if any."
        },
        "num_joined_members" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The number of members joined to the room."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The ID of the room."
        },
        "world_readable" : {
          "type" : "boolean",
          "description" : "Whether the room may be viewed by guest users without joining."
        },
        "guest_can_join" : {
          "type" : "boolean",
          "description" : "Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user."
        },
        "avatar_url" : {
          "type" : "string",
          "description" : "The URL for the room's avatar, if one is set."
        }
      },
      "description" : "Public rooms chunk."
    },
    "PublicRoomsFilter" : {
      "type" : "object",
      "properties" : {
        "generic_search_term" : {
          "type" : "string",
          "description" : "A string to search for in the room metadata, e.g. name, topic, canonical alias etc. (Optional)."
        }
      },
      "description" : "Search filter."
    },
    "PublicRoomsRequest" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Limit the number of results returned."
        },
        "since" : {
          "type" : "string",
          "description" : "A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag."
        },
        "filter" : {
          "description" : "Filter to apply to the results.",
          "$ref" : "#/definitions/PublicRoomsFilter"
        },
        "include_all_networks" : {
          "type" : "boolean",
          "description" : "Whether or not to include all known networks/protocols from application services on the homeserver. Defaults to false."
        },
        "third_party_instance_id" : {
          "type" : "string",
          "description" : "The specific third party network/protocol to request from the homeserver. Can only be used if include_all_networks is false."
        }
      },
      "description" : "JSON body request."
    },
    "PublicRoomsResponse" : {
      "type" : "object",
      "required" : [ "chunk" ],
      "properties" : {
        "chunk" : {
          "type" : "array",
          "description" : "A paginated chunk of public rooms.",
          "items" : {
            "$ref" : "#/definitions/PublicRoomsChunk"
          }
        },
        "next_batch" : {
          "type" : "string",
          "description" : "A pagination token for the response. The absence of this token means there are no more results to fetch and the client should stop paginating."
        },
        "prev_batch" : {
          "type" : "string",
          "description" : "A pagination token that allows fetching previous results. The absence of this token means there are no results before this batch, i.e. this is the first batch."
        },
        "total_room_count_estimate" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "An estimate on the total number of public rooms, if the server has an estimate."
        }
      },
      "description" : "JSON body request."
    },
    "PushActions" : {
      "type" : "object",
      "required" : [ "actions" ],
      "properties" : {
        "actions" : {
          "type" : "array",
          "description" : "The action(s) to perform for this rule.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "JSON body request/response for action push api."
    },
    "PushCondition" : {
      "type" : "object",
      "required" : [ "kind" ],
      "properties" : {
        "kind" : {
          "type" : "string",
          "enum" : [ "event_match", "contains_display_name", "room_member_count]" ]
        },
        "key" : {
          "type" : "string",
          "description" : "Required for event_match conditions. The dot- separated field of the event to match."
        },
        "pattern" : {
          "type" : "string",
          "description" : "Required for event_match conditions. The glob- style pattern to match against. Patterns with no special glob characters should be treated as having asterisks prepended and appended when testing the condition."
        },
        "is" : {
          "type" : "string",
          "description" : "Required for room_member_count conditions. A decimal integer optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches rooms where the member count is strictly less than the given number and so forth. If no prefix is present, this parameter defaults to==."
        }
      },
      "description" : "Push condition."
    },
    "PushEnable" : {
      "type" : "object",
      "required" : [ "enabled" ],
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Whether the push rule is enabled or not."
        }
      },
      "description" : "JSON body request/response for enable/disable push api."
    },
    "PushRule" : {
      "type" : "object",
      "required" : [ "actions", "default", "enabled", "rule_id" ],
      "properties" : {
        "actions" : {
          "type" : "array",
          "description" : "The actions to perform when this rule is matched.",
          "items" : {
            "type" : "object"
          }
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Whether the push rule is enabled or not."
        },
        "conditions" : {
          "type" : "array",
          "description" : "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules.",
          "items" : {
            "$ref" : "#/definitions/PushCondition"
          }
        },
        "pattern" : {
          "type" : "string",
          "description" : "The glob-style pattern to match against. Only applicable to content rules."
        },
        "default" : {
          "type" : "boolean",
          "description" : "Whether this is a default rule, or has been set explicitly."
        },
        "rule_id" : {
          "type" : "string",
          "description" : "The ID of this rule."
        }
      },
      "description" : "Push rule."
    },
    "PushRulesResponse" : {
      "type" : "object",
      "required" : [ "global" ],
      "properties" : {
        "global" : {
          "description" : "The global ruleset.",
          "$ref" : "#/definitions/Ruleset"
        }
      },
      "description" : "JSON body response for push api."
    },
    "PushUpdateRequest" : {
      "type" : "object",
      "required" : [ "actions" ],
      "properties" : {
        "actions" : {
          "type" : "array",
          "description" : "The action(s) to perform when the conditions for this rule are met.",
          "items" : {
            "type" : "string"
          }
        },
        "conditions" : {
          "type" : "array",
          "description" : "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules.",
          "items" : {
            "$ref" : "#/definitions/PushCondition"
          }
        },
        "pattern" : {
          "type" : "string",
          "description" : "Only applicable to content rules. The glob- style pattern to match against."
        }
      },
      "description" : "JSON body request for push update api."
    },
    "Pusher" : {
      "type" : "object",
      "properties" : {
        "pushkey" : {
          "type" : "string",
          "description" : "This is a unique identifier for this pusher. See /set for more detail. Max length, 512 bytes."
        },
        "kind" : {
          "type" : "string",
          "description" : "The kind of pusher. \"http\" is a pusher that sends HTTP pokes."
        },
        "lang" : {
          "type" : "string",
          "description" : "The preferred language for receiving notifications (e.g. 'en' or 'en-US')"
        },
        "data" : {
          "description" : "A dictionary of information for the pusher implementation itself.",
          "$ref" : "#/definitions/PusherData"
        },
        "app_id" : {
          "type" : "string",
          "description" : "This is a reverse-DNS style identifier for the application. Max length, 64 chars."
        },
        "app_display_name" : {
          "type" : "string",
          "description" : "A string that will allow the user to identify what application owns this pusher."
        },
        "device_display_name" : {
          "type" : "string",
          "description" : "A string that will allow the user to identify what device owns this pusher."
        },
        "profile_tag" : {
          "type" : "string",
          "description" : "This string determines which set of device specific rules this pusher executes."
        }
      },
      "description" : "Pusher. A pusher is a worker on the homeserver that manages the sending of HTTP notifications for a user. A user can have multiple pushers: one per device."
    },
    "PusherData" : {
      "type" : "object",
      "properties" : {
        "url" : {
          "type" : "string",
          "description" : "Required if kind is http. The URL to use to send notifications to."
        },
        "format" : {
          "type" : "string",
          "description" : "The format to use when sending notifications to the Push Gateway."
        }
      },
      "description" : "Pusher data."
    },
    "PushersRequest" : {
      "type" : "object",
      "properties" : {
        "pushkey" : {
          "type" : "string",
          "description" : "This is a unique identifier for this pusher. See /set for more detail. Max length, 512 bytes."
        },
        "kind" : {
          "type" : "string",
          "description" : "The kind of pusher. \"http\" is a pusher that sends HTTP pokes."
        },
        "lang" : {
          "type" : "string",
          "description" : "The preferred language for receiving notifications (e.g. 'en' or 'en-US')"
        },
        "data" : {
          "description" : "A dictionary of information for the pusher implementation itself.",
          "$ref" : "#/definitions/PusherData"
        },
        "append" : {
          "type" : "boolean",
          "description" : "If true, the homeserver should add another pusher with the given pushkey and App ID in addition to any others with different user IDs. Otherwise, the homeserver must remove any other pushers with the same App ID and pushkey for different users. The default is false."
        },
        "app_id" : {
          "type" : "string",
          "description" : "This is a reverse-DNS style identifier for the application. Max length, 64 chars."
        },
        "app_display_name" : {
          "type" : "string",
          "description" : "A string that will allow the user to identify what application owns this pusher."
        },
        "device_display_name" : {
          "type" : "string",
          "description" : "A string that will allow the user to identify what device owns this pusher."
        },
        "profile_tag" : {
          "type" : "string",
          "description" : "This string determines which set of device specific rules this pusher executes."
        }
      },
      "description" : "JSON body request to create a new pusher."
    },
    "PushersResponse" : {
      "type" : "object",
      "properties" : {
        "pushers" : {
          "type" : "array",
          "description" : "An array containing the current pushers for the user.",
          "items" : {
            "$ref" : "#/definitions/Pusher"
          }
        }
      },
      "description" : "Pusher list."
    },
    "QueryRequest" : {
      "type" : "object",
      "required" : [ "device_keys" ],
      "properties" : {
        "timeout" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The time (in milliseconds) to wait when downloading keys from remote servers. 10 seconds is the recommended default."
        },
        "token" : {
          "type" : "string",
          "description" : "If the client is fetching keys as a result of a device update received in a sync request, this should be the 'since' token of that sync request, or any later sync token. This allows the server to ensure its response contains the keys advertised by the notification in that sync."
        },
        "device_keys" : {
          "type" : "object",
          "description" : "The keys to be downloaded. A map from user ID, to a list of device IDs, or to an empty list to indicate all devices for the corresponding user.",
          "additionalProperties" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "JSON body parameters for Returns the current devices and identity keys for the given users."
    },
    "QueryResponse" : {
      "type" : "object",
      "properties" : {
        "failures" : {
          "type" : "object",
          "description" : "If any remote homeservers could not be reached, they are recorded here. The names of the properties are the names of the unreachable servers.",
          "additionalProperties" : {
            "type" : "object"
          }
        },
        "device_keys" : {
          "type" : "object",
          "description" : "Information on the queried devices. A map from user ID, to a map from device ID to device information. For each device, the information returned will be the same as uploaded via /keys/upload, with the addition of an unsigned property.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/definitions/DeviceKeys"
            }
          }
        }
      },
      "description" : "Query response."
    },
    "ReadMarkersRequest" : {
      "type" : "object",
      "required" : [ "m.fully_read" ],
      "properties" : {
        "m.fully_read" : {
          "type" : "string",
          "description" : "The event ID the read marker should be located at. The event MUST belong to the room."
        },
        "m.read" : {
          "type" : "string",
          "description" : "The event ID to set the read receipt location at. This is equivalent to calling /receipt/m.read/$elsewhere:domain.com and is provided here to save that extra call."
        }
      },
      "description" : "JSON body of the read marker request."
    },
    "Receipt" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID."
      } ]
    },
    "RedactRequest" : {
      "type" : "object",
      "properties" : {
        "reason" : {
          "type" : "string",
          "description" : "The reason for the event being redacted."
        }
      },
      "description" : "Request for the redaction."
    },
    "RegisterRequest" : {
      "type" : "object",
      "properties" : {
        "auth" : {
          "description" : "Additional authentication information for the user-interactive authentication API. Note that this information is not used to define how the registered user should be authenticated, but is instead used to authenticate the register call itself. It should be left empty, or omitted, unless an earlier call returned an response with status code 401.",
          "$ref" : "#/definitions/AuthenticationData"
        },
        "username" : {
          "type" : "string",
          "description" : "The basis for the localpart of the desired Matrix ID. If omitted, the homeserver MUST generate a Matrix ID local part."
        },
        "password" : {
          "type" : "string",
          "description" : "The desired password for the account."
        },
        "bind_email" : {
          "type" : "boolean",
          "description" : "If true, the server binds the email used for authentication to the Matrix ID with the ID Server."
        },
        "device_id" : {
          "type" : "string",
          "description" : "ID of the client device. If this does not correspond to a known client device, a new device will be created. The server will auto-generate a device_id if this is not specified."
        },
        "initial_device_display_name" : {
          "type" : "string",
          "description" : "A display name to assign to the newly-created device. Ignored if device_id corresponds to a known device."
        }
      },
      "description" : "Request for register for an account on this homeserver."
    },
    "Relates" : {
      "type" : "object",
      "properties" : {
        "m.in_reply_to" : {
          "description" : "Reply.",
          "$ref" : "#/definitions/Reply"
        }
      },
      "description" : "Related data."
    },
    "Reply" : {
      "type" : "object",
      "required" : [ "event_id" ],
      "properties" : {
        "event_id" : {
          "type" : "string",
          "description" : "The origin event id."
        }
      },
      "description" : "Reply model."
    },
    "ReportRequest" : {
      "type" : "object",
      "required" : [ "reason", "score" ],
      "properties" : {
        "score" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The score to rate this content as where -100 is most offensive and 0 is inoffensive."
        },
        "reason" : {
          "type" : "string",
          "description" : "The reason the content is being reported. May be blank."
        }
      },
      "description" : "JSON Body for report request."
    },
    "RequestCategories" : {
      "type" : "object",
      "properties" : {
        "room_events" : {
          "description" : "Mapping of category name to search criteria.",
          "$ref" : "#/definitions/RoomEvents"
        }
      },
      "description" : "Categories."
    },
    "RequestedKeyInfo" : {
      "type" : "object",
      "required" : [ "algorithm", "room_id", "sender_key", "session_id" ],
      "properties" : {
        "algorithm" : {
          "type" : "string",
          "description" : "Required. The encryption algorithm the requested key in this event is to be used with."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The room where the key is used."
        },
        "sender_key" : {
          "type" : "string",
          "description" : "The Curve25519 key of the device which initiated the session originally."
        },
        "session_id" : {
          "type" : "string",
          "description" : "The ID of the session that the key is for."
        }
      },
      "description" : "Requested key info."
    },
    "ResponseCategories" : {
      "type" : "object",
      "properties" : {
        "room_events" : {
          "description" : "Mapping of category name to search criteria.",
          "$ref" : "#/definitions/RoomEventResults"
        }
      },
      "description" : "Response categories."
    },
    "Result" : {
      "type" : "object",
      "properties" : {
        "rank" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A number that describes how closely this result matches the search. Higher is closer."
        },
        "result" : {
          "description" : "The event that matched.",
          "$ref" : "#/definitions/Event"
        },
        "context" : {
          "description" : "Context for result, if requested.",
          "$ref" : "#/definitions/EventContextResponse"
        }
      },
      "description" : "Search result."
    },
    "RoomAliases" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "aliases" ],
        "properties" : {
          "aliases" : {
            "type" : "array",
            "description" : "A list of room aliases.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event is sent by a homeserver directly to inform of changes to the list of aliases it knows about for that room. The state_key for this event is set to the homeserver which owns the room alias. The entire set of known aliases for the room is the union of all the m.room.aliases events, one for each homeserver. Clients should check the validity of any room alias given in this list before presenting it to the user as trusted fact. The lists given by this event should be considered simply as advice on which aliases might exist, for which the client can perform the lookup to confirm whether it receives the correct room ID."
      } ]
    },
    "RoomAvatar" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata about the image referred to in url.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the image."
          }
        },
        "description" : "A picture that is associated with the room. This can be displayed alongside the room information."
      } ]
    },
    "RoomCanonicalAlias" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "alias" ],
        "properties" : {
          "alias" : {
            "type" : "string",
            "description" : "The canonical alias"
          }
        },
        "description" : "This event is used to inform the room about which alias should be considered the canonical one. This could be for display purposes or as suggestion to users which alias to use to advertise the room. A room with an m.room.canonical_alias event with an absent, null, or empty alias field should be treated the same as a room with no m.room.canonical_alias event."
      } ]
    },
    "RoomCreate" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "creator" ],
        "properties" : {
          "creator" : {
            "type" : "string",
            "description" : "The user_id of the room creator. This is set by the homeserver."
          },
          "m.federate" : {
            "type" : "boolean",
            "description" : "Whether users on other servers can join this room. Defaults to ``true`` if key does not exist."
          },
          "room_version" : {
            "type" : "string",
            "description" : "The version of the room. Defaults to \"1\" if the key does not exist."
          }
        },
        "description" : "This is the first event in a room and cannot be changed. It acts as the root of all other events."
      } ]
    },
    "RoomEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "sender_key" ],
        "properties" : {
          "sender_key" : {
            "type" : "string",
            "description" : "The Curve25519 key of the sender."
          },
          "device_id" : {
            "type" : "string",
            "description" : "The ID of the sending device. Required with Megolm."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session used to encrypt the message. Required with Megolm."
          },
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm used to encrypt this event. The value of this field determines which other properties will be present.",
            "readOnly" : true,
            "enum" : [ "m.olm.v1.curve25519-aes-sha2", "m.megolm.v1.aes-sha2" ]
          }
        },
        "description" : "This event type is used when sending encrypted events. It can be used either within a room (in which case it will have all of the Room Event fields), or as a to-device event."
      } ]
    },
    "RoomEncryption" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm to be used to encrypt messages sent in this room. Must be 'm.megolm.v1.aes-sha2'."
          },
          "rotation_period_ms" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "How long the session should be used before changing it. 604800000 (a week) is the recommended default."
          },
          "rotation_period_msgs" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "How many messages should be sent before changing the session. 100 is the recommended default."
          }
        },
        "description" : "State Event. Defines how messages sent in this room should be encrypted."
      } ]
    },
    "RoomEventFilter" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The maximum number of events to return."
        },
        "senders" : {
          "type" : "array",
          "description" : "A list of senders IDs to include. If this list is absent then all senders are included.",
          "items" : {
            "type" : "string"
          }
        },
        "types" : {
          "type" : "array",
          "description" : "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        },
        "rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to include. If this list is absent then all rooms are included.",
          "items" : {
            "type" : "string"
          }
        },
        "not_senders" : {
          "type" : "array",
          "description" : "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter.",
          "items" : {
            "type" : "string"
          }
        },
        "not_types" : {
          "type" : "array",
          "description" : "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A '*' can be used as a wildcard to match any sequence of characters.",
          "items" : {
            "type" : "string"
          }
        },
        "not_rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter.",
          "items" : {
            "type" : "string"
          }
        },
        "contains_url" : {
          "type" : "boolean",
          "description" : "If true, includes only events with a url key in their content. If false, excludes those events."
        }
      },
      "description" : "Room event filter."
    },
    "RoomEventResults" : {
      "type" : "object",
      "properties" : {
        "count" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "An approximate count of the total number of results found."
        },
        "highlights" : {
          "type" : "array",
          "description" : "List of words which should be highlighted, useful for stemming which may change the query terms.",
          "items" : {
            "type" : "string"
          }
        },
        "results" : {
          "type" : "array",
          "description" : "List of results in the requested order.",
          "items" : {
            "$ref" : "#/definitions/Result"
          }
        },
        "state" : {
          "type" : "object",
          "description" : "The current state for every room in the results. This is included if the request had the include_state key set with a value of true.",
          "additionalProperties" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/Event"
            }
          }
        },
        "groups" : {
          "type" : "object",
          "description" : "Any groups that were requested.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/definitions/GroupValue"
            }
          }
        },
        "next_batch" : {
          "type" : "string",
          "description" : "Token that can be used to get the next batch of results, by passing as the next_batch parameter to the next call. If this field is absent, there are no more results."
        }
      },
      "description" : "Room events results."
    },
    "RoomEvents" : {
      "type" : "object",
      "required" : [ "search_term" ],
      "properties" : {
        "keys" : {
          "type" : "array",
          "description" : "The keys to search.",
          "items" : {
            "type" : "string"
          }
        },
        "filter" : {
          "description" : "This takes a filter.",
          "$ref" : "#/definitions/Filter"
        },
        "groupings" : {
          "description" : "Requests that the server partitions the result set based on the provided list of keys.",
          "$ref" : "#/definitions/Groupings"
        },
        "search_term" : {
          "type" : "string",
          "description" : "The string to search events for."
        },
        "order_by" : {
          "type" : "string",
          "description" : "The order in which to search for results.",
          "enum" : [ "recent", "rank" ]
        },
        "event_context" : {
          "description" : "Configures whether any context for the events returned are included in the response.",
          "$ref" : "#/definitions/EventContext"
        },
        "include_state" : {
          "type" : "boolean",
          "description" : "Requests the server return the current state for each room returned."
        }
      },
      "description" : "Room events."
    },
    "RoomFilter" : {
      "type" : "object",
      "properties" : {
        "rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ephemeral, state, timeline or account_data.",
          "items" : {
            "type" : "string"
          }
        },
        "ephemeral" : {
          "description" : "The events that aren't recorded in the room history, e.g. typing and receipts, to include for rooms.",
          "$ref" : "#/definitions/RoomEventFilter"
        },
        "state" : {
          "description" : "The state events to include for rooms.",
          "$ref" : "#/definitions/RoomEventFilter"
        },
        "timeline" : {
          "description" : "The message and state update events to include for rooms.",
          "$ref" : "#/definitions/RoomEventFilter"
        },
        "not_rooms" : {
          "type" : "array",
          "description" : "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter. This filter is applied before the filters in ephemeral, state, timeline or account_data.",
          "items" : {
            "type" : "string"
          }
        },
        "include_leave" : {
          "type" : "boolean",
          "description" : "Include rooms that the user has left in the sync, default false."
        },
        "account_data" : {
          "description" : "The per user account data to include for rooms.",
          "$ref" : "#/definitions/RoomEventFilter"
        }
      },
      "description" : "Room filter."
    },
    "RoomGuestAccess" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "guest_access" : {
            "type" : "string",
            "description" : "Whether guests can join the room.",
            "enum" : [ "can_join", "forbidden" ]
          }
        },
        "description" : "This event controls whether guest users are allowed to join rooms. If this event is absent, servers should act as if it is present and has the guest_access value \"forbidden\"."
      } ]
    },
    "RoomHistoryVisibility" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "history_visibility" ],
        "properties" : {
          "history_visibility" : {
            "type" : "string",
            "description" : "Who can see the room history.",
            "enum" : [ "invited", "joined", "shared", "world_readable" ]
          }
        },
        "description" : "This event controls whether a user can see the events that happened in a room from before they joined."
      } ]
    },
    "RoomId" : {
      "type" : "object",
      "properties" : {
        "room_id" : {
          "type" : "string",
          "description" : "The created room's ID."
        }
      },
      "description" : "JSON body with roomId used in the room apis."
    },
    "RoomJoinRules" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "join_rule" : {
            "type" : "string",
            "description" : "The type of rules used for users wishing to join this room.",
            "enum" : [ "public", "knock", "invite", "private" ]
          }
        },
        "description" : "A room may be ``public`` meaning anyone can join the room without any prior action. Alternatively, it can be ``invite`` meaning that a user who wishes to join the room must first receive an invite to the room from someone already inside of the room. Currently, ``knock`` and ``private`` are reserved keywords which are not implemented."
      } ]
    },
    "RoomKey" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "room_id", "session_id", "session_key" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm the key in this event is to be used with. Must be 'm.megolm.v1.aes-sha2'."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          }
        },
        "description" : "This event type is used to exchange keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event."
      } ]
    },
    "RoomKeyRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "action", "request_id", "requesting_device_id" ],
        "properties" : {
          "body" : {
            "description" : "Information about the requested key. Required when action is request.",
            "$ref" : "#/definitions/RequestedKeyInfo"
          },
          "action" : {
            "type" : "string",
            "description" : "Request action.",
            "enum" : [ "request", "cancel_request" ]
          },
          "requesting_device_id" : {
            "type" : "string",
            "description" : "ID of the device requesting the key."
          },
          "request_id" : {
            "type" : "string",
            "description" : "A random string uniquely identifying the request for a key. If the key is requested multiple times, it should be reused. It should also reused in order to cancel a request."
          }
        },
        "description" : "This event type is used to request keys for end-to-end encryption. It is sent as an unencrypted to-device event."
      } ]
    },
    "RoomMember" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "membership" ],
        "properties" : {
          "membership" : {
            "type" : "string",
            "description" : "The membership state of the user.",
            "enum" : [ "invite", "join", "knock", "leave", "ban" ]
          },
          "unsigned" : {
            "description" : "Contains optional extra information about the event.",
            "$ref" : "#/definitions/RoomMemberUnsigned"
          },
          "direct" : {
            "type" : "boolean"
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The avatar URL for this user, if any. This is added by the homeserver."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The display name for this user, if any. This is added by the homeserver."
          },
          "is_direct" : {
            "type" : "boolean",
            "description" : "Flag indicating if the room containing this event was created with the intention of being a direct chat. See Direct Messaging."
          },
          "third_party_invite" : {
            "description" : "Third-party invites.",
            "$ref" : "#/definitions/Invite"
          }
        },
        "description" : "Adjusts the membership state for a user in a room. It is preferable to use the membership APIs (/rooms/<room id>/invite etc) when performing membership actions rather than adjusting the state directly as there are a restricted set of valid transformations. For example, user A cannot force user B to join a room, and trying to force this state change directly will fail."
      } ]
    },
    "RoomMemberUnsigned" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "A subset of the state of the room at the time of the invite, if membership is invite. Note that this state is informational, and SHOULD NOT be trusted; once the client has joined the room, it SHOULD fetch the live state from the server and discard the invite_room_state. Also, clients must not rely on any particular state being present here; they SHOULD behave properly (with possibly a degraded but not a broken experience) in the absence of any particular events here. If they are set on the room, at least the state for m.room.avatar, m.room.canonical_alias, m.room.join_rules, and m.room.name SHOULD be included.",
          "items" : {
            "$ref" : "#/definitions/StrippedState"
          }
        }
      },
      "description" : "Unsigned data."
    },
    "RoomMessage" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "The textual representation of this message."
          },
          "m.relates_to" : {
            "description" : "Relates (reply, ...).",
            "$ref" : "#/definitions/Relates"
          },
          "msgtype" : {
            "type" : "string",
            "description" : "Message type.",
            "readOnly" : true
          }
        },
        "description" : "This event is used when sending messages in a room. Messages are not limited to be text. The ``msgtype`` key outlines the type of message, e.g. text, audio, image, video, etc. The ``body`` key is text and MUST be used with every kind of ``msgtype`` as a fallback mechanism for when a client cannot render a message. This allows clients to display *something* even if it is just plain text."
      } ]
    },
    "RoomName" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The name of the room. This MUST NOT exceed 255 bytes."
          }
        },
        "description" : "A room has an opaque room ID which is not human-friendly to read. A room alias is human-friendly, but not all rooms have room aliases. The room name is a human-friendly string designed to be displayed to the end-user. The room name is not unique, as multiple rooms can have the same room name set. A room with an m.room.name event with an absent, null, or empty name field should be treated the same as a room with no m.room.name event. An event of this type is automatically created when creating a room using /createRoom with the name key."
      } ]
    },
    "RoomPinned" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "pinned" ],
        "properties" : {
          "pinned" : {
            "type" : "array",
            "description" : "An ordered list of event IDs to pin.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event is used to \"pin\" particular events in a room for other participants to review later. The order of the pinned events is guaranteed and based upon the order supplied in the event. Clients should be aware that the current user may not be able to see some of the events pinned due to visibility settings in the room. Clients are responsible for determining if a particular event in the pinned list is displayable, and have the option to not display it if it cannot be pinned in the client."
      } ]
    },
    "RoomPowerLevels" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "ban" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to ban a user. Defaults to 50 if unspecified."
          },
          "events" : {
            "type" : "object",
            "description" : "The level required to send specific event types. This is a mapping from event type to power level required.",
            "additionalProperties" : {
              "type" : "string",
              "format" : "byte"
            }
          },
          "invite" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to invite a user. Defaults to 50 if unspecified."
          },
          "kick" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to kick a user. Defaults to 50 if unspecified."
          },
          "redact" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to redact an event. Defaults to 50 if unspecified."
          },
          "users" : {
            "type" : "object",
            "description" : "The power levels for specific users. This is a mapping from user_id to power level for that user.",
            "additionalProperties" : {
              "type" : "string",
              "format" : "byte"
            }
          },
          "notifications" : {
            "description" : "The power level requirements for specific notification types. This is a mapping from key to power level for that notifications key.",
            "$ref" : "#/definitions/NotificationPowerLevel"
          },
          "events_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default level required to send message events. Can be overridden by the events key. Defaults to 0 if unspecified."
          },
          "state_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default level required to send state events. Can be overridden by the events key. Defaults to 50 if unspecified, but 0 if there is no m.room.power_levels event at all."
          },
          "users_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default power level for every user in the room, unless their user_id is mentioned in the users key. Defaults to 0 if unspecified."
          }
        },
        "description" : "This event specifies the minimum level a user must have in order to perform a certain action. It also specifies the levels of each user in the room. If a user_id is in the users list, then that user_id has the associated power level. Otherwise they have the default level users_default. If users_default is not supplied, it is assumed to be 0. If the room contains no m.room.power_levels event, the room's creator has a power level of 100, and all other users have a power level of 0. The level required to send a certain event is governed by events, state_default and events_default. If an event type is specified in events, then the user must have at least the level specified in order to send that event. If the event type is not supplied, it defaults to events_default for Message Events and state_default for State Events. If there is no state_default in the m.room.power_levels event, the state_default is 50. If there is no events_default in the m.room.power_levels event, the events_default is 0. If the room contains no m.room.power_levels event, both the state_default and events_default are 0. The power level required to invite a user to the room, kick a user from the room, ban a user from the room, or redact an event, is defined by invite, kick, ban, and redact, respectively. Each of these levels defaults to 50 if they are not specified in the m.room.power_levels event, or if the room contains no m.room.power_levels event."
      } ]
    },
    "RoomRedaction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "reason" : {
            "type" : "string",
            "description" : "The reason for the redaction, if any."
          }
        },
        "description" : "Events can be redacted by either room or server admins. Redacting an event means that all keys not required by the protocol are stripped off, allowing admins to remove offensive or illegal content that may have been attached to any event. This cannot be undone, allowing server owners to physically delete the offending data. There is also a concept of a moderator hiding a message event, which can be undone, but cannot be applied to state events. The event that has been redacted is specified in the redacts event level key."
      } ]
    },
    "RoomResolveResponse" : {
      "type" : "object",
      "properties" : {
        "servers" : {
          "type" : "array",
          "description" : "A list of servers that are aware of this room alias.",
          "items" : {
            "type" : "string"
          }
        },
        "room_id" : {
          "type" : "string",
          "description" : "The created room's ID."
        }
      },
      "description" : "JSON body response of the room response api."
    },
    "RoomServerAcl" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "allow" : {
            "type" : "array",
            "description" : "The server names to allow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided, effectively disallowing every server.",
            "items" : {
              "type" : "string"
            }
          },
          "deny" : {
            "type" : "array",
            "description" : "The server names to disallow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided.",
            "items" : {
              "type" : "string"
            }
          },
          "allow_ip_literals" : {
            "type" : "boolean",
            "description" : "True to allow server names that are IP address literals. False to deny. Defaults to true if missing or otherwise not a boolean. This is strongly recommended to be set to false as servers running with IP literal names are strongly discouraged in order to require legitimate homeservers to be backed by a valid registered domain name."
          }
        },
        "description" : "An event to indicate which servers are permitted to participate in the room. Server ACLs may allow or deny groups of hosts."
      } ]
    },
    "RoomThirdPartyInvite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "display_name", "key_validity_url", "public_key" ],
        "properties" : {
          "display_name" : {
            "type" : "string",
            "description" : "A user-readable string which represents the user who has been invited. This should not contain the user's third party ID, as otherwise when the invite is accepted it would leak the association between the matrix ID and the third party ID."
          },
          "key_validity_url" : {
            "type" : "string",
            "description" : "A URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'."
          },
          "public_key" : {
            "type" : "string",
            "description" : "A base64-encoded ed25519 key with which token must be signed (though a signature from any entry in public_keys is also sufficient). This exists for backwards compatibility."
          },
          "public_keys" : {
            "type" : "array",
            "description" : "Keys with which the token may be signed.",
            "items" : {
              "$ref" : "#/definitions/PublicKeys"
            }
          }
        },
        "description" : "Acts as an m.room.member invite event, where there isn't a target user_id to invite. This event contains a token and a public key whose private key must be used to sign the token. Any user who can present that signature may use this invitation to join the target room."
      } ]
    },
    "RoomTopic" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "topic" ],
        "properties" : {
          "topic" : {
            "type" : "string",
            "description" : "The topic text"
          }
        },
        "description" : "A topic is a short message detailing what is currently being discussed in the room. It can also be used as a way to display extra information about the room, which may not be suitable for the room name. The room topic can also be set when creating a room using /createRoom with the topic key."
      } ]
    },
    "RoomVisibility" : {
      "type" : "object",
      "properties" : {
        "visibility" : {
          "type" : "string",
          "description" : "The visibility of the room in the directory.",
          "enum" : [ "private", "public" ]
        }
      },
      "description" : "JSON body request and response for listing room api."
    },
    "Rooms" : {
      "type" : "object",
      "properties" : {
        "join" : {
          "type" : "object",
          "description" : "The rooms that the user has joined.",
          "additionalProperties" : {
            "$ref" : "#/definitions/JoinedRoom"
          }
        },
        "invite" : {
          "type" : "object",
          "description" : "The rooms that the user has been invited to.",
          "additionalProperties" : {
            "$ref" : "#/definitions/InvitedRoom"
          }
        },
        "leave" : {
          "type" : "object",
          "description" : "The rooms that the user has left or been banned from.",
          "additionalProperties" : {
            "$ref" : "#/definitions/LeftRoom"
          }
        }
      },
      "description" : "Rooms."
    },
    "Ruleset" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Content rules.",
          "items" : {
            "$ref" : "#/definitions/PushRule"
          }
        },
        "override" : {
          "type" : "array",
          "description" : "Override rules.",
          "items" : {
            "$ref" : "#/definitions/PushRule"
          }
        },
        "room" : {
          "type" : "array",
          "description" : "Room rules.",
          "items" : {
            "$ref" : "#/definitions/PushRule"
          }
        },
        "sender" : {
          "type" : "array",
          "description" : "Sender rules.",
          "items" : {
            "$ref" : "#/definitions/PushRule"
          }
        },
        "underride" : {
          "type" : "array",
          "description" : "Underride rules.",
          "items" : {
            "$ref" : "#/definitions/PushRule"
          }
        }
      },
      "description" : "Ruleset."
    },
    "SearchRequest" : {
      "type" : "object",
      "required" : [ "search_categories" ],
      "properties" : {
        "search_categories" : {
          "description" : "Describes which categories to search in and their criteria.",
          "$ref" : "#/definitions/RequestCategories"
        }
      },
      "description" : "JSON body request for search api."
    },
    "SearchResponse" : {
      "type" : "object",
      "required" : [ "search_categories" ],
      "properties" : {
        "search_categories" : {
          "description" : "Describes which categories to search in and their criteria.",
          "$ref" : "#/definitions/ResponseCategories"
        }
      },
      "description" : "JSON body response for search api."
    },
    "SendEventResponse" : {
      "type" : "object",
      "properties" : {
        "event_id" : {
          "type" : "string",
          "description" : "A unique identifier for the event."
        }
      },
      "description" : "Sent event."
    },
    "SendToDeviceRequest" : {
      "type" : "object",
      "properties" : {
        "messages" : {
          "type" : "object",
          "description" : "The messages to send. A map from user ID, to a map from device ID to message body. The device ID may also be *, meaning all known devices for the user.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/definitions/EventContent"
            }
          }
        }
      },
      "description" : "Sent to device body request."
    },
    "ServerDiscoveryResponse" : {
      "type" : "object",
      "required" : [ "m.homeserver" ],
      "properties" : {
        "m.homeserver" : {
          "description" : "Information about the homeserver to connect to.",
          "$ref" : "#/definitions/HomeserverInfo"
        },
        "m.identity_server" : {
          "description" : "Information about the identity server to connect to.",
          "$ref" : "#/definitions/IdentityServerInfo"
        }
      },
      "description" : "Server discovery information."
    },
    "SessionInfo" : {
      "type" : "object",
      "properties" : {
        "connections" : {
          "type" : "array",
          "description" : "Information particular connections in the session.",
          "items" : {
            "$ref" : "#/definitions/ConnectionInfo"
          }
        }
      },
      "description" : "Session info."
    },
    "SessionResponse" : {
      "type" : "object",
      "required" : [ "sid" ],
      "properties" : {
        "sid" : {
          "type" : "string",
          "description" : "The session ID. Session IDs are opaque strings generated by the identity server. They must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
        }
      },
      "description" : "The sid generated for this session to the caller, in a JSON object containing the sid key."
    },
    "Signed" : {
      "type" : "object",
      "required" : [ "mxid", "signatures", "token" ],
      "properties" : {
        "mxid" : {
          "type" : "string",
          "description" : "The invited matrix user ID. Must be equal to the user_id property of the event."
        },
        "token" : {
          "type" : "string",
          "description" : "The token property of the containing third_party_invite object."
        },
        "signatures" : {
          "type" : "object",
          "description" : "A single signature from the verifying server, in the format specified by the Signing Events section of the server-server API.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "Signed part of the invitation request."
    },
    "State" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "State."
    },
    "Sticker" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "body", "info", "url" ],
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "A textual representation or associated description of the sticker image. This could be the alt text of the original image, or a message to accompany and further describe the sticker."
          },
          "info" : {
            "description" : "Metadata about the image referred to in url including a thumbnail representation.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the sticker image. This must be a valid mxc:// URI."
          }
        },
        "description" : "This message represents a single sticker image."
      } ]
    },
    "StrippedState" : {
      "type" : "object",
      "required" : [ "content", "sender", "state_key", "type" ],
      "properties" : {
        "content" : {
          "description" : "The content for the event.",
          "$ref" : "#/definitions/EventContent"
        },
        "type" : {
          "type" : "string",
          "description" : "The type for the event."
        },
        "sender" : {
          "type" : "string",
          "description" : "The sender for the event."
        },
        "state_key" : {
          "type" : "string",
          "description" : "The state_key for the event."
        }
      },
      "description" : "Provides information on a subset of state events such as the room name."
    },
    "SupportedLoginResponse" : {
      "type" : "object",
      "properties" : {
        "flows" : {
          "type" : "array",
          "description" : "Supported login types.",
          "items" : {
            "$ref" : "#/definitions/LoginType"
          }
        }
      },
      "description" : "Supported login types."
    },
    "SyncResponse" : {
      "type" : "object",
      "required" : [ "next_batch" ],
      "properties" : {
        "rooms" : {
          "description" : "Updates to rooms.",
          "$ref" : "#/definitions/Rooms"
        },
        "presence" : {
          "description" : "The updates to the presence status of other users.",
          "$ref" : "#/definitions/Presence"
        },
        "next_batch" : {
          "type" : "string",
          "description" : "The batch token to supply in the since param of the next /sync request."
        },
        "account_data" : {
          "description" : "The global private data created by this user.",
          "$ref" : "#/definitions/AccountData"
        },
        "to_device" : {
          "description" : "Information on the send-to-device messages for the client device, as defined in Send-to-Device messaging.",
          "$ref" : "#/definitions/ToDevice"
        },
        "device_lists" : {
          "description" : "Information on end-to-end device updates, as specified in End-to-end encryption.",
          "$ref" : "#/definitions/DeviceLists"
        },
        "device_one_time_keys_count" : {
          "type" : "object",
          "description" : "Information on end-to-end encryption keys, as specified in End-to-end encryption.",
          "additionalProperties" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "description" : "JSON body response for sync api."
    },
    "Tag" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "tags" : {
            "type" : "object",
            "description" : "The tags on the room and their contents.",
            "additionalProperties" : {
              "$ref" : "#/definitions/TagInfo"
            }
          }
        },
        "description" : "Informs the client of tags on a room."
      } ]
    },
    "TagInfo" : {
      "type" : "object",
      "properties" : {
        "order" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A number in a range [0,1] describing a relative position of the room under the given tag."
        }
      },
      "description" : "Tag info."
    },
    "Tags" : {
      "type" : "object",
      "properties" : {
        "tags" : {
          "type" : "object",
          "description" : "Tags.",
          "additionalProperties" : {
            "$ref" : "#/definitions/TagInfo"
          }
        }
      },
      "description" : "TagInfo request."
    },
    "Text" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is the most basic message and is used to represent text."
      } ]
    },
    "ThirdPartyIdentifier" : {
      "type" : "object",
      "required" : [ "added_at", "address", "medium", "validated_at" ],
      "properties" : {
        "medium" : {
          "type" : "string",
          "description" : "The medium of the third party identifier. Must be 'email'",
          "enum" : [ "email", "msisdn" ]
        },
        "address" : {
          "type" : "string",
          "description" : "The third party identifier address"
        },
        "validated_at" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The timestamp, in milliseconds, when the identifier was validated by the identity server."
        },
        "added_at" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The timestamp, in milliseconds, when the homeserver associated the third party identifier with the user."
        }
      },
      "description" : "Request for gets a list of the third party identifiers that the homeserver has associated with the user's account."
    },
    "ThirdPartySigned" : {
      "type" : "object",
      "required" : [ "mxid", "sender", "signatures", "token" ],
      "properties" : {
        "sender" : {
          "type" : "string",
          "description" : "The Matrix ID of the user who issued the invite."
        },
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix ID of the invitee."
        },
        "token" : {
          "type" : "string",
          "description" : "The state key of the m.third_party_invite event."
        },
        "signatures" : {
          "type" : "object",
          "description" : "A signatures object containing a signature of the entire signed object.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "Third party signed."
    },
    "ThirdpartyIdentifier" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Identifier"
      }, {
        "type" : "object",
        "required" : [ "address", "medium" ],
        "properties" : {
          "medium" : {
            "type" : "string",
            "description" : "The medium of the third party identifier."
          },
          "address" : {
            "type" : "string",
            "description" : "The canonicalised third party address of the user."
          }
        },
        "description" : "The user is identified by a third-party identifer in canonicalised form."
      } ]
    },
    "ThreePidCred" : {
      "type" : "object",
      "required" : [ "client_secret", "id_server", "sid" ],
      "properties" : {
        "sid" : {
          "type" : "string",
          "description" : "The session identifier given by the identity server."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "The client secret used in the session with the identity server."
        },
        "id_server" : {
          "type" : "string",
          "description" : "The identity server to use."
        }
      },
      "description" : "3pid credentials"
    },
    "ThreePidRequest" : {
      "type" : "object",
      "required" : [ "three_pid_creds" ],
      "properties" : {
        "bind" : {
          "type" : "boolean",
          "description" : "Whether the homeserver should also bind this third party identifier to the account's Matrix ID with the passed identity server"
        },
        "three_pid_creds" : {
          "type" : "array",
          "description" : "The third party credentials to associate with the account",
          "items" : {
            "$ref" : "#/definitions/ThreePidCred"
          }
        }
      },
      "description" : "Request for adds contact information to the user's account"
    },
    "ThreePidResponse" : {
      "type" : "object",
      "properties" : {
        "threepids" : {
          "type" : "array",
          "description" : "All 3pids",
          "items" : {
            "$ref" : "#/definitions/ThirdPartyIdentifier"
          }
        }
      },
      "description" : "Response for gets a list of the third party identifiers that the homeserver has associated with the user's account"
    },
    "ThumbnailInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Thumbnail info."
    },
    "Timeline" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of events.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        },
        "limited" : {
          "type" : "boolean",
          "description" : "True if the number of events returned was limited by the limit on the filter."
        },
        "prev_batch" : {
          "type" : "string",
          "description" : "A token that can be supplied to the from parameter of the rooms/{roomId}/messages endpoint."
        }
      },
      "description" : "Timeline."
    },
    "ToDevice" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "List of send-to-device messages.",
          "items" : {
            "$ref" : "#/definitions/Event"
          }
        }
      },
      "description" : "To device."
    },
    "Typing" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "user_ids" ],
        "properties" : {
          "user_ids" : {
            "type" : "array",
            "description" : "The list of user IDs typing in this room, if any.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "Informs the client of the list of users currently typing."
      } ]
    },
    "TypingRequest" : {
      "type" : "object",
      "required" : [ "typing" ],
      "properties" : {
        "typing" : {
          "type" : "boolean",
          "description" : "Whether the user is typing or not. If false, the timeout key can be omitted."
        },
        "timeout" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The length of time in milliseconds to mark this user as typing."
        }
      },
      "description" : "Typing body request."
    },
    "UnbanRequest" : {
      "type" : "object",
      "required" : [ "user_id" ],
      "properties" : {
        "user_id" : {
          "type" : "string",
          "description" : "The fully qualified user ID of the user being unbanned."
        }
      },
      "description" : "Unban JSON body request."
    },
    "UnreadNotificationCounts" : {
      "type" : "object",
      "properties" : {
        "highlight_count" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The number of unread notifications for this room with the highlight flag set."
        },
        "notification_count" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The total number of unread notifications for this room."
        }
      },
      "description" : "Unread notification counts."
    },
    "Unsigned" : {
      "type" : "object",
      "properties" : {
        "age" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
        },
        "redacted_because" : {
          "description" : "The event that redacted this event, if any.",
          "$ref" : "#/definitions/Event"
        },
        "transaction_id" : {
          "type" : "string",
          "description" : "The client-supplied transaction ID, if the client being given the event is the same one which sent it."
        },
        "prev_content" : {
          "description" : "The previous content for this state. This will be present only for state events appearing in the timeline. If this is not a state event, or there is no previous content, this key will be missing.",
          "$ref" : "#/definitions/EventContent"
        }
      },
      "description" : "Unsigned addition data."
    },
    "UnsignedDeviceInfo" : {
      "type" : "object",
      "properties" : {
        "device_display_name" : {
          "type" : "string",
          "description" : "The display name which the user set on the device."
        }
      },
      "description" : "Unsigned device info."
    },
    "UploadRequest" : {
      "type" : "object",
      "properties" : {
        "device_keys" : {
          "description" : "Identity keys for the device. May be absent if no new identity keys are required.",
          "$ref" : "#/definitions/DeviceKeys"
        },
        "one_time_keys" : {
          "type" : "object",
          "description" : "One-time public keys for \"pre-key\" messages. The names of the properties should be in the format (algorithm):(key_id). The format of the key is determined by the key algorithm.",
          "additionalProperties" : {
            "type" : "object"
          }
        }
      },
      "description" : "JSON body parameters for Publishes end-to-end encryption keys for the device."
    },
    "UploadResponse" : {
      "type" : "object",
      "required" : [ "one_time_key_counts" ],
      "properties" : {
        "one_time_key_counts" : {
          "type" : "object",
          "description" : "For each key algorithm, the number of unclaimed one-time keys of that type currently held on the server for this device.",
          "additionalProperties" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "description" : "Response format."
    },
    "User" : {
      "type" : "object",
      "required" : [ "user_id" ],
      "properties" : {
        "user_id" : {
          "type" : "string",
          "description" : "The user's matrix user ID."
        },
        "display_name" : {
          "type" : "string",
          "description" : "The display name of the user, if one exists."
        },
        "avatar_url" : {
          "type" : "string",
          "description" : "The avatar url, as an MXC, if one exists."
        }
      },
      "description" : "JSON body response for user directory api (User)."
    },
    "UserIdentifier" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Identifier"
      }, {
        "type" : "object",
        "required" : [ "user" ],
        "properties" : {
          "user" : {
            "type" : "string",
            "description" : "A client can identify a user using their Matrix ID. This can either be the fully qualified Matrix user ID, or just the localpart of the user ID."
          }
        },
        "description" : "The user is identified by their Matrix ID."
      } ]
    },
    "VersionsResponse" : {
      "type" : "object",
      "properties" : {
        "versions" : {
          "type" : "array",
          "description" : "The supported versions.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "The versions supported by the server."
    },
    "Video" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata about the video clip referred to in url.",
            "$ref" : "#/definitions/VideoInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the video clip."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single video clip."
      } ]
    },
    "VideoInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "duration" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The duration of the video in milliseconds."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Video info."
    },
    "VoipResponse" : {
      "type" : "object",
      "required" : [ "password", "ttl", "uris", "username" ],
      "properties" : {
        "username" : {
          "type" : "string",
          "description" : "The username to use."
        },
        "password" : {
          "type" : "string",
          "description" : "The password to use."
        },
        "uris" : {
          "type" : "array",
          "description" : "A list of TURN URIs.",
          "items" : {
            "type" : "string"
          }
        },
        "ttl" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The time-to-live in seconds."
        }
      },
      "description" : "The TURN server credentials."
    },
    "WhoamiResponse" : {
      "type" : "object",
      "required" : [ "user_id" ],
      "properties" : {
        "user_id" : {
          "type" : "string",
          "description" : "The user id that owns the access token."
        }
      },
      "description" : "Response for gets information about the owner of a given access token"
    }
  }
}