{
  "swagger" : "2.0",
  "info" : {
    "description" : "Identity API",
    "version" : "r0.1.0-1-SNAPSHOT",
    "title" : "Identity API",
    "termsOfService" : "http://www.github.com/kongchen/swagger-maven-plugin",
    "contact" : {
      "name" : "Anatoly",
      "url" : "https://github.com/ma1uta/jeon",
      "email" : "sablintolya@gmail.com"
    },
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "host" : "matrix.org:8448",
  "tags" : [ {
    "name" : "AssociationLookup"
  }, {
    "name" : "Deprecated"
  }, {
    "name" : "EphemeralInvitationSigning",
    "description" : "To aid clients who may not be able to perform crypto themselves, the identity server offers some crypto functionality to help in accepting invitations. This is less secure than the client doing it itself, but may be useful where this isn't possible."
  }, {
    "name" : "Invitation",
    "description" : "An identity service can store pending invitations to a user's 3pid, which will be retrieved and can be either notified on or look up when the 3pid is associated with a Matrix user ID. At a later point, if the owner of that particular 3pid binds it with a Matrix user ID, the identity server will attempt to make an HTTP POST to the Matrix user's homeserver via the /3pid/onbind endpoint. The request MUST be signed with a long-term private key for the identity server."
  }, {
    "name" : "KeyManagement",
    "description" : "An identity service has some long-term public-private keypairs. These are named in a scheme algorithm:identifier, e.g. ed25519:0. When signing an association, the standard Signing JSON algorithm applies.\nThe identity server may also keep track of some short-term public-private keypairs, which may have different usage and lifetime characteristics than the service's long-term keys."
  }, {
    "name" : "Session"
  }, {
    "name" : "Status",
    "description" : "Checks that an Identity server is available at this API endpoint."
  }, {
    "name" : "Validation",
    "description" : "Checking the validation of the 3pid ownership."
  } ],
  "schemes" : [ "https" ],
  "paths" : {
    "/_matrix/identity/api/v1" : {
      "get" : {
        "tags" : [ "Status" ],
        "summary" : "To discover that an Identity server is available at a specific URL, this endpoint can be queried and will return an empty object.",
        "description" : "This is primarly used for auto-discovery and health check purposes by entities acting as a client for the Identity server.",
        "operationId" : "v1Status",
        "produces" : [ "application/json" ],
        "responses" : {
          "200" : {
            "description" : "An identity server is ready to serve requests.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          }
        }
      }
    },
    "/_matrix/identity/api/v1/3pid/getValidated3pid" : {
      "get" : {
        "tags" : [ "Validation" ],
        "summary" : "Determines if a given 3pid has been validated by a user.",
        "description" : "",
        "operationId" : "validate",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "query",
          "description" : "The Session ID generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "query",
          "description" : "The client secret passed to the requestToken call.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Validation information for the session.",
            "schema" : {
              "$ref" : "#/definitions/ValidationResponse"
            }
          },
          "400" : {
            "description" : "he session has not been validated. If the session has not been validated, then errcode will be M_SESSION_NOT_VALIDATED. If the session has timed out, then errcode will be M_SESSION_EXPIRED."
          },
          "404" : {
            "description" : "The Session ID or client secret were not found."
          }
        }
      }
    },
    "/_matrix/identity/api/v1/bind" : {
      "post" : {
        "tags" : [ "Deprecated" ],
        "summary" : "Publish an association between a session and a Matrix user ID.",
        "description" : "Future calls to /lookup for any of the session's 3pids will return this association.",
        "operationId" : "publishDeprecated",
        "consumes" : [ "application/x-www-form-urlencoded" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "formData",
          "description" : "The Session ID generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "formData",
          "description" : "The client secret passed to the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "mxid",
          "in" : "formData",
          "description" : "The Matrix user ID to associate with the 3pids.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The association was published.",
            "schema" : {
              "$ref" : "#/definitions/PublishResponse"
            }
          },
          "400" : {
            "description" : "The association was not published. If the session has not been validated, then errcode will be M_SESSION_NOT_VALIDATED. If the session has timed out, then errcode will be M_SESSION_EXPIRED."
          },
          "404" : {
            "description" : "he Session ID or client secret were not found."
          }
        },
        "deprecated" : true
      }
    },
    "/_matrix/identity/api/v1/bulk_lookup" : {
      "post" : {
        "tags" : [ "AssociationLookup" ],
        "summary" : "Lookup Matrix user IDs for a list of 3pids.",
        "description" : "",
        "operationId" : "bulkLookup",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "An array of arrays containing the 3PID Types with the medium in first position and the address in second position.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/BulkLookupRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of known 3PID mappings for the supplied 3PIDs.",
            "schema" : {
              "$ref" : "#/definitions/BulkLookupResponse"
            }
          }
        }
      }
    },
    "/_matrix/identity/api/v1/lookup" : {
      "get" : {
        "tags" : [ "AssociationLookup" ],
        "summary" : "Look up the Matrix user ID for a 3pid.",
        "description" : "",
        "operationId" : "lookup",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "medium",
          "in" : "query",
          "description" : "The medium type of the 3pid. See the 3PID Types Appendix.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "address",
          "in" : "query",
          "description" : "The address of the 3pid being looked up. See the 3PID Types Appendix.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The association for that 3pid, or an empty object if no association is known.",
            "schema" : {
              "$ref" : "#/definitions/LookupResponse"
            }
          }
        }
      }
    },
    "/_matrix/identity/api/v1/pubkey/ephemeral/isvalid" : {
      "get" : {
        "tags" : [ "KeyManagement" ],
        "summary" : "Check whether a short-term public key is valid.",
        "description" : "",
        "operationId" : "ephemeralValid",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "public_key",
          "in" : "query",
          "description" : "The unpadded base64-encoded public key to check.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The validity of the public key.",
            "schema" : {
              "$ref" : "#/definitions/KeyValidationResponse"
            }
          }
        }
      }
    },
    "/_matrix/identity/api/v1/pubkey/isvalid" : {
      "get" : {
        "tags" : [ "KeyManagement" ],
        "summary" : "Check whether a long-term public key is valid.",
        "description" : "The response should always be the same, provided the key exists.",
        "operationId" : "valid",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "public_key",
          "in" : "query",
          "description" : "The unpadded base64-encoded public key to check.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The validity of the public key.",
            "schema" : {
              "$ref" : "#/definitions/KeyValidationResponse"
            }
          }
        }
      }
    },
    "/_matrix/identity/api/v1/pubkey/{keyId}" : {
      "get" : {
        "tags" : [ "KeyManagement" ],
        "summary" : "Get the public key for the passed key ID.",
        "description" : "",
        "operationId" : "get",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "keyId",
          "in" : "path",
          "description" : "The ID of the key. This should take the form algorithm:identifier where algorithm identifies the signing algorithm, and the identifier is an opaque string.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The public key exists.",
            "schema" : {
              "$ref" : "#/definitions/PublicKeyResponse"
            }
          },
          "404" : {
            "description" : "The public key was not found."
          }
        }
      }
    },
    "/_matrix/identity/api/v1/sign-ed25519" : {
      "post" : {
        "tags" : [ "EphemeralInvitationSigning" ],
        "summary" : "Sign invitation details.",
        "description" : "The identity server will look up token which was stored in a call to store-invite, and fetch the sender of the invite.",
        "operationId" : "sign",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/SigningRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The signed JSON of the mxid, sender, and token.",
            "schema" : {
              "$ref" : "#/definitions/SigningResponse"
            }
          },
          "404" : {
            "description" : "The token was not found."
          }
        }
      }
    },
    "/_matrix/identity/api/v1/store-invite" : {
      "post" : {
        "tags" : [ "Invitation" ],
        "summary" : "Store pending invitations to a user's 3pid.",
        "description" : "In addition to the request parameters specified below, an arbitrary number of other parameters may also be specified. These may be used in the invite message generation described below. The service will generate a random token and an ephemeral key used for accepting the invite. The service also generates a display_name for the inviter, which is a redacted version of address which does not leak the full contents of the address. The service records persistently all of the above information. It also generates an email containing all of this data, sent to the address parameter, notifying them of the invitation. Also, the generated ephemeral public key will be listed as valid on requests to /_matrix/identity/api/v1/pubkey/ephemeral/isvalid. Currently, invites may only be issued for 3pids of the email medium.",
        "operationId" : "invite",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "JSON body request",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/InvitationRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The invitation was stored.",
            "schema" : {
              "$ref" : "#/definitions/InvitationResponse"
            }
          },
          "400" : {
            "description" : "An error has occured. If the 3pid is already bound to a Matrix user ID, the error code will be M_THREEPID_IN_USE. If the medium is unsupported, the error code will be M_UNRECOGNIZED."
          }
        }
      }
    },
    "/_matrix/identity/api/v1/validate/email/requestToken" : {
      "post" : {
        "tags" : [ "Deprecated" ],
        "summary" : "Create a session for validating an email address.",
        "description" : "The identity server will send an email containing a token. If that token is presented to the identity server in the future, it indicates that that user was able to read the email for that email address, and so we validate ownership of the email address.\nNote that homeservers offer APIs that proxy this API, adding additional behaviour on top, for example,/register/email/requestToken is designed specifically for use when registering an account and therefore will inform the user if the email address given is already registered on the server.",
        "operationId" : "createEmailSessionDeprecated",
        "consumes" : [ "application/x-www-form-urlencoded" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "client_secret",
          "in" : "formData",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "email",
          "in" : "formData",
          "description" : "The email address to validate.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "send_attempt",
          "in" : "formData",
          "description" : "The server will only send an email if the send_attempt is a number greater than the most recent one which it has seen, scoped to that email + client_secret pair. This is to avoid repeatedly sending the same email in the case of request retries between the POSTing user and the identity server. The client should increment this value if they desire a new email (e.g. a reminder) to be sent.",
          "required" : true,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "next_link",
          "in" : "formData",
          "description" : "When the validation is completed, the identity server will redirect the user to this URL.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Session created.",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "An error ocurred."
          }
        },
        "deprecated" : true
      }
    },
    "/_matrix/identity/api/v1/validate/email/submitToken" : {
      "get" : {
        "tags" : [ "Session" ],
        "summary" : "Validate ownership of an email address.",
        "description" : "If the three parameters are consistent with a set generated by a requestToken call, ownership of the email address is considered to have been validated. This does not publish any information publicly, or associate the email address with any Matrix user ID. Specifically, calls to /lookup will not show a binding.\nThe identity server is free to match the token case-insensitively, or carry out other mapping operations such as unicode normalisation. Whether to do so is an implementation detail for the identity server. Clients must always pass on the token without modification.",
        "operationId" : "getValidateEmail",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "query",
          "description" : "The session ID, generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "query",
          "description" : "The client secret that was supplied to the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "query",
          "description" : "The token generated by the requestToken call and emailed to the user.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Email address is validated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "302" : {
            "description" : "Email address is validated, and the next_link parameter was provided to the requestToken call. The user must be redirected to the URL provided by the next_link parameter."
          },
          "400" : {
            "description" : "Validation failed."
          }
        }
      },
      "post" : {
        "tags" : [ "Deprecated" ],
        "summary" : "Validate ownership of an email address.",
        "description" : "If the three parameters are consistent with a set generated by a requestToken call, ownership of the email address is considered to have been validated. This does not publish any information publicly, or associate the email address with any Matrix user ID. Specifically, calls to /lookup will not show a binding.\nThe identity server is free to match the token case-insensitively, or carry out other mapping operations such as unicode normalisation. Whether to do so is an implementation detail for the identity server. Clients must always pass on the token without modification.",
        "operationId" : "postValidateEmailDeprecated",
        "consumes" : [ "application/x-www-form-urlencoded" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "formData",
          "description" : "The session ID, generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "formData",
          "description" : "The client secret that was supplied to the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "formData",
          "description" : "The token generated by the requestToken call and emailed to the user.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The success of the validation.",
            "schema" : {
              "$ref" : "#/definitions/ValidationResponse"
            }
          }
        },
        "deprecated" : true
      }
    },
    "/_matrix/identity/api/v1/validate/msisdn/requestToken" : {
      "post" : {
        "tags" : [ "Deprecated" ],
        "summary" : "Create a session for validating a phone number.",
        "description" : "The identity server will send an SMS message containing a token. If that token is presented to the identity server in the future, it indicates that that user was able to read the SMS for that phone number, and so we validate ownership of the phone number.\nNote that homeservers offer APIs that proxy this API, adding additional behaviour on top, for example, /register/msisdn/requestToken is designed specifically for use when registering an account and therefore will inform the user if the phone number given is already registered on the server.",
        "operationId" : "createPhoneSessionDeprecated",
        "consumes" : [ "application/x-www-form-urlencoded" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "client_secret",
          "in" : "formData",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "country",
          "in" : "formData",
          "description" : "The two-letter uppercase ISO country code that the number in phone_number should be parsed as if it were dialled from.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "phone_number",
          "in" : "formData",
          "description" : "The phone number to validate.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "send_attempt",
          "in" : "formData",
          "description" : "The server will only send an SMS if the send_attempt is a number greater than the most recent one which it has seen, scoped to that country + phone_number + client_secret triple. This is to avoid repeatedly sending the same SMS in the case of request retries between the POSTing user and the identity server. The client should increment this value if they desire a new SMS (e.g. a reminder) to be sent.",
          "required" : true,
          "type" : "integer",
          "format" : "int64"
        }, {
          "name" : "next_link",
          "in" : "formData",
          "description" : "When the validation is completed, the identity server will redirect the user to this URL.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Session created.",
            "schema" : {
              "$ref" : "#/definitions/SessionResponse"
            }
          },
          "400" : {
            "description" : "An error occured."
          }
        },
        "deprecated" : true
      }
    },
    "/_matrix/identity/api/v1/validate/msisdn/submitToken" : {
      "get" : {
        "tags" : [ "Session" ],
        "summary" : "Validate ownership of an email address.",
        "description" : "If the three parameters are consistent with a set generated by a requestToken call, ownership of the email address is considered to have been validated. This does not publish any information publicly, or associate the email address with any Matrix user ID. Specifically, calls to /lookup will not show a binding.\nThe identity server is free to match the token case-insensitively, or carry out other mapping operations such as unicode normalisation. Whether to do so is an implementation detail for the identity server. Clients must always pass on the token without modification.\n Note: for backwards compatibility with previous drafts of this specification, the parameters may also be specifiedas application/x-form-www-urlencoded data. However, this usage is deprecated.",
        "operationId" : "getValidatePhone",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "query",
          "description" : "The session ID, generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "query",
          "description" : "The client secret that was supplied to the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "query",
          "description" : "The token generated by the requestToken call and sent to the user.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Phone number is validated.",
            "schema" : {
              "$ref" : "#/definitions/EmptyResponse"
            }
          },
          "302" : {
            "description" : "Email address is validated, and the next_link parameter was provided to the requestToken call. The user must be redirected to the URL provided by the next_link parameter."
          },
          "400" : {
            "description" : "Validation failed."
          }
        }
      },
      "post" : {
        "tags" : [ "Deprecated" ],
        "summary" : "Validate ownership of a phone number.",
        "description" : "If the three parameters are consistent with a set generated by a requestToken call, ownership of the email address is considered to have been validated. This does not publish any information publicly, or associate the email address with any Matrix user ID. Specifically, calls to /lookup will not show a binding.\nThe identity server is free to match the token case-insensitively, or carry out other mapping operations such as unicode normalisation. Whether to do so is an implementation detail for the identity server. Clients must always pass on the token without modification.",
        "operationId" : "postValidatePhoneDeprecated",
        "consumes" : [ "application/x-www-form-urlencoded" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "sid",
          "in" : "formData",
          "description" : "The session ID, generated by the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "formData",
          "description" : "The client secret that was supplied to the requestToken call.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "formData",
          "description" : "The token generated by the requestToken call and sent to the user.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The success of the validation.",
            "schema" : {
              "$ref" : "#/definitions/ValidationResponse"
            }
          }
        },
        "deprecated" : true
      }
    }
  },
  "definitions" : {
    "BulkLookupRequest" : {
      "type" : "object",
      "required" : [ "threepids" ],
      "properties" : {
        "threepids" : {
          "type" : "array",
          "description" : "An array of arrays containing the 3PID Types with the medium in first position and the address in second position.",
          "items" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "Request of the lookup Matrix user IDs for a list of 3pids."
    },
    "BulkLookupResponse" : {
      "type" : "object",
      "required" : [ "threepids" ],
      "properties" : {
        "threepids" : {
          "type" : "array",
          "description" : "An array of array containing the 3PID Types with the medium in first position, the address in second position and Matrix user ID in third position.",
          "items" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "Response of the lookup Matrix user IDs for a list of 3pids."
    },
    "EmailRequestToken" : {
      "type" : "object",
      "required" : [ "client_secret", "email", "send_attempt" ],
      "properties" : {
        "email" : {
          "type" : "string",
          "description" : "The email address to validate."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
        },
        "send_attempt" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The server will only send an email if the send_attempt is a number greater than the most recent one which it has seen, scoped to that email + client_secret pair. This is to avoid repeatedly sending the same email in the case of request retries between the POSTing user and the identity server.The client should increment this value if they desire a new email(e.g.a reminder) to be sent."
        },
        "next_link" : {
          "type" : "string",
          "description" : "When the validation is completed, the identity server will redirect the user to this URL."
        }
      },
      "description" : "JSON body request of the creating an email association."
    },
    "EmptyResponse" : {
      "type" : "object",
      "description" : "Empty response"
    },
    "InvitationRequest" : {
      "type" : "object",
      "required" : [ "address", "medium", "roomId", "sender" ],
      "properties" : {
        "medium" : {
          "type" : "string",
          "description" : "The literal string email"
        },
        "address" : {
          "type" : "string",
          "description" : "The email address of the invited user."
        },
        "roomId" : {
          "type" : "string",
          "description" : "The Matrix room ID to which the user is invited."
        },
        "sender" : {
          "type" : "string",
          "description" : "The Matrix user ID of the inviting user."
        }
      },
      "description" : "JSON boy requesst of the invitation api."
    },
    "InvitationResponse" : {
      "type" : "object",
      "required" : [ "display_name", "public_keys", "token" ],
      "properties" : {
        "token" : {
          "type" : "string",
          "description" : "The generated token. Must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
        },
        "public_keys" : {
          "type" : "array",
          "description" : "A list of [server's long-term public key, generated ephemeral public key].",
          "items" : {
            "type" : "string"
          }
        },
        "display_name" : {
          "type" : "string",
          "description" : "The generated (redacted) display_name."
        }
      },
      "description" : "Result of the pending invitation."
    },
    "KeyValidationResponse" : {
      "type" : "object",
      "required" : [ "valid" ],
      "properties" : {
        "valid" : {
          "type" : "boolean",
          "description" : "Whether the public key is recognised and is currently valid."
        }
      },
      "description" : "The validity of the public key."
    },
    "LookupResponse" : {
      "type" : "object",
      "required" : [ "address", "medium", "mxid", "not_after", "not_before", "signatures", "ts" ],
      "properties" : {
        "address" : {
          "type" : "string",
          "description" : "The 3pid address of the user being looked up, matching the address requested."
        },
        "medium" : {
          "type" : "string",
          "description" : "A medium from the 3PID Types Appendix, matching the medium requested."
        },
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix user ID associated with the 3pid."
        },
        "ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The unix timestamp at which the association was verified."
        },
        "signatures" : {
          "type" : "object",
          "description" : "The signatures of the verifying identity services which show that the association should be trusted, if you trust the verifying identity services.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        },
        "not_before" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A unix timestamp before which the association is not known to be valid."
        },
        "not_after" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A unix timestamp after which the association is not known to be valid."
        }
      },
      "description" : "Look up response the Matrix user ID for a 3pid."
    },
    "PhoneRequestToken" : {
      "type" : "object",
      "required" : [ "client_secret", "country", "phone_number", "send_attempt" ],
      "properties" : {
        "country" : {
          "type" : "string",
          "description" : "The two-letter uppercase ISO country code that the number in phone_number should be parsed as if it were dialled from."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "A unique string generated by the client, and used to identify the validation attempt. It must be a string consisting of the characters [0-9a-zA-Z.=_-]. Its length must not exceed 255 characters and it must not be empty."
        },
        "phone_number" : {
          "type" : "string",
          "description" : "The phone number to validate."
        },
        "send_attempt" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The server will only send an email if the send_attempt is a number greater than the most recent one which it has seen, scoped to that email + client_secret pair. This is to avoid repeatedly sending the same email in the case of request retries between the POSTing user and the identity server.The client should increment this value if they desire a new email(e.g.a reminder) to be sent."
        },
        "next_link" : {
          "type" : "string",
          "description" : "When the validation is completed, the identity server will redirect the user to this URL."
        }
      },
      "description" : "JSON body request of the creating an phone association."
    },
    "PublicKeyResponse" : {
      "type" : "object",
      "required" : [ "public_key" ],
      "properties" : {
        "public_key" : {
          "type" : "string",
          "description" : "Unpadded Base64 encoded public key."
        }
      },
      "description" : "The public key exists."
    },
    "PublishRequest" : {
      "type" : "object",
      "required" : [ "client_secret", "mxid", "sid" ],
      "properties" : {
        "sid" : {
          "type" : "string",
          "description" : "The Session ID generated by the requestToken call."
        },
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix user ID to associate with the 3pids."
        },
        "client_secret" : {
          "type" : "string",
          "description" : "The client secret passed to the requestToken call."
        }
      },
      "description" : "JSON body request of the bind api."
    },
    "PublishResponse" : {
      "type" : "object",
      "required" : [ "address", "medium", "mxid", "not_after", "not_before", "signatures", "ts" ],
      "properties" : {
        "address" : {
          "type" : "string",
          "description" : "The 3pid address of the user being looked up."
        },
        "medium" : {
          "type" : "string",
          "description" : "The medium type of the 3pid."
        },
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix user ID associated with the 3pid."
        },
        "ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The unix timestamp at which the association was verified."
        },
        "signatures" : {
          "type" : "object",
          "description" : "The signatures of the verifying identity servers which show that the association should be trusted, if you trust the verifying identity services.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        },
        "not_before" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A unix timestamp before which the association is not known to be valid."
        },
        "not_after" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A unix timestamp after which the association is not known to be valid."
        }
      },
      "description" : "Result of the publishing association."
    },
    "SessionResponse" : {
      "type" : "object",
      "required" : [ "sid" ],
      "properties" : {
        "sid" : {
          "type" : "string",
          "description" : "The session ID. Session IDs are opaque strings generated by the identity server. They must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
        }
      },
      "description" : "The sid generated for this session to the caller, in a JSON object containing the sid key."
    },
    "SigningRequest" : {
      "type" : "object",
      "required" : [ "mxid", "private_key", "token" ],
      "properties" : {
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix user ID of the user accepting the invitation."
        },
        "token" : {
          "type" : "string",
          "description" : "The token from the call to store-invite."
        },
        "private_key" : {
          "type" : "string",
          "description" : "The private key, encoded as Unpadded base64."
        }
      },
      "description" : "JSON body request of the signing api."
    },
    "SigningResponse" : {
      "type" : "object",
      "required" : [ "mxid", "sender", "signatures", "token" ],
      "properties" : {
        "mxid" : {
          "type" : "string",
          "description" : "The Matrix user ID of the user accepting the invitation."
        },
        "sender" : {
          "type" : "string",
          "description" : "The Matrix user ID of the user who sent the invitation."
        },
        "signatures" : {
          "type" : "object",
          "description" : "The signature of the mxid, sender, and token.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        },
        "token" : {
          "type" : "string",
          "description" : "The token for the invitation."
        }
      },
      "description" : "JSON body response of the signing api."
    },
    "SubmitToken" : {
      "type" : "object",
      "properties" : {
        "sid" : {
          "type" : "string"
        },
        "token" : {
          "type" : "string"
        },
        "client_secret" : {
          "type" : "string"
        }
      }
    },
    "ValidationResponse" : {
      "type" : "object",
      "required" : [ "validated" ],
      "properties" : {
        "validated" : {
          "type" : "boolean",
          "description" : "Whether the validation was successful or not."
        }
      },
      "description" : "Result of the 3pid validation."
    }
  }
}