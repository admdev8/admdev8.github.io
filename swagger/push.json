{
  "swagger" : "2.0",
  "info" : {
    "description" : "Push API",
    "version" : "r0.1.0-1",
    "title" : "Push API",
    "termsOfService" : "http://www.github.com/kongchen/swagger-maven-plugin",
    "contact" : {
      "name" : "Anatoly",
      "url" : "https://github.com/ma1uta/jeon",
      "email" : "sablintolya@gmail.com"
    },
    "license" : {
      "name" : "Apache 2.0",
      "url" : "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "host" : "matrix.org:8448",
  "tags" : [ {
    "name" : "Push",
    "description" : "This describes the format used by \"HTTP\" pushers to send notifications of events to Push Gateways. If the endpoint returns an HTTP error code, the homeserver SHOULD retry for a reasonable amount of time using exponential backoff."
  } ],
  "schemes" : [ "https" ],
  "paths" : {
    "/_matrix/push/r0/notify" : {
      "post" : {
        "tags" : [ "Push" ],
        "summary" : "This endpoint is invoked by HTTP pushers to notify a push gateway about an event or update the number of unread notifications a user has.",
        "description" : "In the former case it will contain selected information about the event. In either case it may contain numeric counts of the number of unread events of different types the user has. The counts may be sent along with a notification about an event or by themselves.\nNotifications about a particular event will normally cause the user to be alerted in some way.It is therefore necessary to perform duplicate suppression for such notifications using the event_id field to avoid retries of this HTTP API causing duplicate alerts.The operation of updating counts of unread notifications should be idempotent and therefore do not require duplicate suppression.\nNotifications are sent to the URL configured when the pusher is created.This means that the HTTP path may be different depending on the push gateway.",
        "operationId" : "pushNotify",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "Information about the push notification.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/Notification"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "A list of rejected push keys.",
            "schema" : {
              "$ref" : "#/definitions/RejectedPushKey"
            }
          }
        }
      }
    }
  },
  "securityDefinitions" : {
    "Authorization" : {
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header"
    }
  },
  "definitions" : {
    "Answer" : {
      "type" : "object",
      "required" : [ "sdp", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The type of session description. Must be 'answer'."
        },
        "sdp" : {
          "type" : "string",
          "description" : "The SDP text of the session description."
        }
      },
      "description" : "Answer"
    },
    "Audio" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata for the audio clip referred to in url.",
            "$ref" : "#/definitions/AudioInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the audio clip."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single audio clip."
      } ]
    },
    "AudioInfo" : {
      "type" : "object",
      "properties" : {
        "duration" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The duration of the audio in milliseconds."
        },
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the audio e.g. audio/aac."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The size of the audio clip in bytes."
        }
      },
      "description" : "Audio type."
    },
    "CallAnswer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "answer", "call_id", "version" ],
        "properties" : {
          "answer" : {
            "description" : "The session description object.",
            "$ref" : "#/definitions/Answer"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the callee when they wish to answer the call."
      } ]
    },
    "CallCandidates" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "candidates", "version" ],
        "properties" : {
          "candidates" : {
            "type" : "array",
            "description" : "Array of objects describing the candidates.",
            "items" : {
              "$ref" : "#/definitions/Candidate"
            }
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this messages adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by callers after sending an invite and by the callee after answering. Its purpose is to give the other party additional ICE candidates to try using to communicate."
      } ]
    },
    "CallHangup" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "version" ],
        "properties" : {
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "Sent by either party to signal their termination of the call. This can be sent either once the call has has been established or before to abort the call."
      } ]
    },
    "CallInvite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "call_id", "lifetime", "offer", "version" ],
        "properties" : {
          "offer" : {
            "description" : "The session description object.",
            "$ref" : "#/definitions/Offer"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The version of the VoIP specification this message adheres to. This specification is version 0."
          },
          "lifetime" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The time in milliseconds that the invite is valid for. Once the invite age exceeds this value, clients should discard it. They should also no longer show the call as awaiting an answer in the UI."
          },
          "call_id" : {
            "type" : "string",
            "description" : "The ID of the call this event relates to."
          }
        },
        "description" : "This event is sent by the caller when they wish to establish a call."
      } ]
    },
    "Candidate" : {
      "type" : "object",
      "required" : [ "candidate", "sdpMLineIndex", "sdpMid" ],
      "properties" : {
        "sdpMid" : {
          "type" : "string",
          "description" : "The SDP media type this candidate is intended for."
        },
        "sdpMLineIndex" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The index of the SDP 'm' line this candidate is intended for."
        },
        "candidate" : {
          "type" : "string",
          "description" : "The SDP 'a' line of the candidate."
        }
      },
      "description" : "Candidate."
    },
    "CiphertextInfo" : {
      "type" : "object",
      "properties" : {
        "body" : {
          "type" : "string",
          "description" : "The encrypted payload."
        },
        "type" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The Olm message type."
        }
      },
      "description" : "Cipher text info."
    },
    "Counts" : {
      "type" : "object",
      "properties" : {
        "unread" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The number of unread messages a user has across all of the rooms they are a member of."
        },
        "missed_calls" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The number of unacknowledged missed calls a user has across all rooms of which they are a member."
        }
      },
      "description" : "Counts."
    },
    "Device" : {
      "type" : "object",
      "required" : [ "app_id", "pushkey" ],
      "properties" : {
        "data" : {
          "description" : "A dictionary of additional pusher-specific data. For 'http' pushers, this is the data dictionary passed in at pusher creation minus the url key.",
          "$ref" : "#/definitions/PusherData"
        },
        "tweaks" : {
          "type" : "object",
          "description" : "A dictionary of customisations made to the way this notification is to be presented. These are added by push rules.",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "app_id" : {
          "type" : "string",
          "description" : "The app_id given when the pusher was created."
        },
        "pushkey" : {
          "type" : "string",
          "description" : "The pushkey given when the pusher was created."
        },
        "pushkey_ts" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The unix timestamp (in seconds) when the pushkey was last updated."
        }
      },
      "description" : "Device."
    },
    "Direct" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID."
      } ]
    },
    "Emote" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is similar to m.text except that the sender is 'performing' the action contained in the body key, similar to /me in IRC. This message should be prefixed by the name of the sender. This message could also be represented in a different colour to distinguish it from regular m.text messages."
      } ]
    },
    "EncryptedFile" : {
      "type" : "object",
      "required" : [ "iv", "key", "url", "v" ],
      "properties" : {
        "url" : {
          "type" : "string",
          "description" : "the URL to the file."
        },
        "key" : {
          "description" : "A JSON Web Key object.",
          "$ref" : "#/definitions/JWK"
        },
        "iv" : {
          "type" : "string",
          "description" : " The Initialisation Vector used by AES-CTR, encoded as unpadded base64."
        },
        "hashes" : {
          "type" : "object",
          "description" : "A map from an algorithm name to a hash of the ciphertext, encoded as unpadded base64. Clients should support the SHA-256 hash, which uses the key sha256.",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "v" : {
          "type" : "string",
          "description" : "Version of the encrypted attachments protocol. Must be v2."
        }
      },
      "description" : "Encrypted file."
    },
    "EventContent" : {
      "type" : "object",
      "discriminator" : "type",
      "description" : "Parent class of all event contents part in the Event."
    },
    "File" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "filename", "url" ],
        "properties" : {
          "filename" : {
            "type" : "string",
            "description" : "The original filename of the uploaded file."
          },
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/FileInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a generic file."
      } ]
    },
    "FileInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        }
      },
      "description" : "File info."
    },
    "ForwardedRoomKey" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "forwarding_curve25519_key_chain", "room_id", "sender_claimed_ed25519_key", "sender_key", "session_id", "session_key" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "Required. The encryption algorithm the key in this event is to be used with."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "sender_key" : {
            "type" : "string",
            "description" : "Required. The Curve25519 key of the device which initiated the session originally."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          },
          "sender_claimed_ed25519_key" : {
            "type" : "string",
            "description" : "The Ed25519 key of the device which initiated the session originally. It is 'claimed' because the receiving device has no way to tell that the original room_key actually came from a device which owns the private partof this key unless they have done device verification."
          },
          "forwarding_curve25519_key_chain" : {
            "type" : "array",
            "description" : "Chain of Curve25519 keys. It starts out empty, but each time the key is forwarded to another device, the previous sender in the chain is added to the end of the list. For example, if the key is forwarded from A to B to C, this field is empty between A and B, and contains A's Curve25519 key between B and C.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event type is used to forward keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event."
      } ]
    },
    "FullyRead" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "event_id" ],
        "properties" : {
          "event_id" : {
            "type" : "string",
            "description" : "The event the user's read marker is located at in the room."
          }
        },
        "description" : "The current location of the user's read marker in a room. This event appears in the user's room account data for the room the marker is applicable for."
      } ]
    },
    "IgnoredUserList" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "ignoredUsers" ],
        "properties" : {
          "ignoredUsers" : {
            "type" : "object",
            "description" : "The map of users to ignore.",
            "additionalProperties" : {
              "type" : "object"
            }
          }
        },
        "description" : "A map of users which are considered ignored is kept in account_data in an event type of m.ignored_user_list."
      } ]
    },
    "Image" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the file."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single image and an optional thumbnail."
      } ]
    },
    "ImageInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Image info."
    },
    "Invite" : {
      "type" : "object",
      "required" : [ "display_name", "signed" ],
      "properties" : {
        "signed" : {
          "description" : "A block of content which has been signed, which servers can use to verify the event. Clients should ignore this.",
          "$ref" : "#/definitions/Signed"
        },
        "display_name" : {
          "type" : "string",
          "description" : "A name which can be displayed to represent the user instead of their third party identifier."
        }
      },
      "description" : "Third-party invites."
    },
    "JWK" : {
      "type" : "object",
      "required" : [ "alg", "ext", "k", "key", "key_opts" ],
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "Key type. Must be oct."
        },
        "alg" : {
          "type" : "string",
          "description" : "Algorithm, Must be A256CTR."
        },
        "ext" : {
          "type" : "boolean",
          "description" : "Extractable. Must be true. This is a W3C extension."
        },
        "key_opts" : {
          "type" : "array",
          "description" : "Key operations, Must at least contain encrypt and decrypt.",
          "items" : {
            "type" : "string"
          }
        },
        "k" : {
          "type" : "string",
          "description" : "The key, encoded as urlsafe unpadded base64."
        }
      },
      "description" : "JSON Web Key."
    },
    "Location" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "geo_uri" ],
        "properties" : {
          "info" : {
            "description" : "Information about the file referred to in url.",
            "$ref" : "#/definitions/LocationInfo"
          },
          "geo_uri" : {
            "type" : "string",
            "description" : "A geo URI representing this location."
          }
        },
        "description" : "This message represents a real-world location."
      } ]
    },
    "LocationInfo" : {
      "type" : "object",
      "properties" : {
        "thumbnailFile" : {
          "description" : "Information on the encrypted thumbnail file, as specified in End-to-end encryption. Only present if the thumbnail is encrypted.",
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the location being represented."
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        }
      },
      "description" : "Location info."
    },
    "MegolmEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomEncrypted"
      }, {
        "type" : "object",
        "required" : [ "ciphertext" ],
        "properties" : {
          "ciphertext" : {
            "type" : "string",
            "description" : "The encrypted content of the event. The encrypted payload itself."
          }
        },
        "description" : "Megolm encrypted message."
      } ]
    },
    "Notice" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "The ``m.notice`` type is primarily intended for responses from automated clients. An ``m.notice`` message must be treated the same way as a regular ``m.text`` message with two exceptions. Firstly, clients should present ``m.notice`` messages to users in a distinct manner, and secondly, ``m.notice`` messages must never be automatically responded to. This helps to prevent infinite-loop situations where two automated clients continuously exchange messages."
      } ]
    },
    "Notification" : {
      "type" : "object",
      "required" : [ "devices" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The type of the event as in the event's type field."
        },
        "sender" : {
          "type" : "string",
          "description" : "The sender of the event as in the corresponding event field."
        },
        "prio" : {
          "type" : "string",
          "description" : "The priority of the notification. If omitted, high is assumed. This may be used by push gateways to deliverless time-sensitive notifications in a way that will preserve battery power on mobile devices.",
          "enum" : [ "high", "low" ]
        },
        "content" : {
          "description" : "The content field from the event, if present. The pusher may omit this if the event had no content or for any other reas",
          "$ref" : "#/definitions/EventContent"
        },
        "counts" : {
          "description" : "This is a dictionary of the current number of unacknowledged communications for the recipient user. Counts whose value is zero should be omitted.",
          "$ref" : "#/definitions/Counts"
        },
        "devices" : {
          "type" : "array",
          "description" : "This is an array of devices that the notification should be sent to.",
          "items" : {
            "$ref" : "#/definitions/Device"
          }
        },
        "event_id" : {
          "type" : "string",
          "description" : "The Matrix event ID of the event being notified about. This is required if the notification is about a particular Matrix event. It may be omitted for notifications that only contain updated badge counts. This ID can and should be used to detect duplicate notification requests."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The ID of the room in which this event occurred. Required if the notification relates to a specific Matrix event."
        },
        "sender_display_name" : {
          "type" : "string",
          "description" : "The current display name of the sender in the room in which the event occurred."
        },
        "room_name" : {
          "type" : "string",
          "description" : "The name of the room in which the event occurred."
        },
        "room_alias" : {
          "type" : "string",
          "description" : "An alias to display for the room in which the event occurred."
        },
        "user_is_target" : {
          "type" : "boolean",
          "description" : "This is true if the user receiving the notification is the subject of a member event (i.e. the state_key of the member event is equal to the user's Matrix ID)."
        }
      },
      "description" : "Information about the push notification."
    },
    "NotificationPowerLevel" : {
      "type" : "object",
      "properties" : {
        "room" : {
          "type" : "string",
          "format" : "byte",
          "description" : "The level required to trigger an @room notification. Defaults to 50 if unspecified."
        }
      },
      "description" : "Notifications."
    },
    "Offer" : {
      "type" : "object",
      "required" : [ "sdp", "type" ],
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The type of session description. Must be 'offer'."
        },
        "sdp" : {
          "type" : "string",
          "description" : "The SDP text of the session description."
        }
      },
      "description" : "Offer"
    },
    "OlmEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomEncrypted"
      }, {
        "type" : "object",
        "required" : [ "ciphertext" ],
        "properties" : {
          "ciphertext" : {
            "type" : "object",
            "description" : "The encrypted content of the event. A map from the recipient Curve25519 identity key to ciphertext information. For more details, see Messaging Algorithms.",
            "additionalProperties" : {
              "$ref" : "#/definitions/CiphertextInfo"
            }
          }
        },
        "description" : "Olm encrypted message."
      } ]
    },
    "Presence" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "presence" ],
        "properties" : {
          "presence" : {
            "type" : "string",
            "description" : "The presence state for this user.",
            "enum" : [ "online", "offline", "unavailable" ]
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The current avatar URL for this user, if any."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The current display name for this user, if any."
          },
          "last_active_ago" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "The last time since this used performed some action, in milliseconds."
          },
          "currently_active" : {
            "type" : "boolean",
            "description" : "Whether the user is currently active."
          }
        },
        "description" : "Informs the client of a user's presence state change."
      } ]
    },
    "PublicKeys" : {
      "type" : "object",
      "required" : [ "publicKey" ],
      "properties" : {
        "publicKey" : {
          "type" : "string",
          "description" : "A base-64 encoded ed25519 key with which token may be signed."
        },
        "key_validity_url" : {
          "type" : "string",
          "description" : "An optional URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'. If this URL is absent, the key must be considered valid indefinitely."
        }
      },
      "description" : "Public keys."
    },
    "PusherData" : {
      "type" : "object",
      "properties" : {
        "url" : {
          "type" : "string",
          "description" : "Required if kind is http. The URL to use to send notifications to."
        },
        "format" : {
          "type" : "string",
          "description" : "The format to use when sending notifications to the Push Gateway."
        }
      },
      "description" : "Pusher data."
    },
    "Receipt" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "description" : "A map of which rooms are considered 'direct' rooms for specific users is kept in account_data in an event of type m.direct. The content of this event is an object where the keys are the user IDs and values are lists of room ID strings of the 'direct' rooms for that user ID."
      } ]
    },
    "RejectedPushKey" : {
      "type" : "object",
      "required" : [ "rejected" ],
      "properties" : {
        "rejected" : {
          "type" : "array",
          "description" : "A list of all pushkeys given in the notification request that are not valid. These could have been rejected by an upstream gateway because they have expired or have never been valid. Homeservers must cease sending notification requests for these pushkeys and remove the associated pushers. It may not necessarily be the notification in the request that failed: it could be that a previous notification to the same pushkey failed. May be empty.",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "JSON body response for push api."
    },
    "Relates" : {
      "type" : "object",
      "properties" : {
        "m.in_reply_to" : {
          "description" : "Reply.",
          "$ref" : "#/definitions/Reply"
        }
      },
      "description" : "Related data."
    },
    "Reply" : {
      "type" : "object",
      "required" : [ "event_id" ],
      "properties" : {
        "event_id" : {
          "type" : "string",
          "description" : "The origin event id."
        }
      },
      "description" : "Reply model."
    },
    "RequestedKeyInfo" : {
      "type" : "object",
      "required" : [ "algorithm", "room_id", "sender_key", "session_id" ],
      "properties" : {
        "algorithm" : {
          "type" : "string",
          "description" : "Required. The encryption algorithm the requested key in this event is to be used with."
        },
        "room_id" : {
          "type" : "string",
          "description" : "The room where the key is used."
        },
        "sender_key" : {
          "type" : "string",
          "description" : "The Curve25519 key of the device which initiated the session originally."
        },
        "session_id" : {
          "type" : "string",
          "description" : "The ID of the session that the key is for."
        }
      },
      "description" : "Requested key info."
    },
    "RoomAliases" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "aliases" ],
        "properties" : {
          "aliases" : {
            "type" : "array",
            "description" : "A list of room aliases.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event is sent by a homeserver directly to inform of changes to the list of aliases it knows about for that room. The state_key for this event is set to the homeserver which owns the room alias. The entire set of known aliases for the room is the union of all the m.room.aliases events, one for each homeserver. Clients should check the validity of any room alias given in this list before presenting it to the user as trusted fact. The lists given by this event should be considered simply as advice on which aliases might exist, for which the client can perform the lookup to confirm whether it receives the correct room ID."
      } ]
    },
    "RoomAvatar" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata about the image referred to in url.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the image."
          }
        },
        "description" : "A picture that is associated with the room. This can be displayed alongside the room information."
      } ]
    },
    "RoomCanonicalAlias" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "alias" ],
        "properties" : {
          "alias" : {
            "type" : "string",
            "description" : "The canonical alias"
          }
        },
        "description" : "This event is used to inform the room about which alias should be considered the canonical one. This could be for display purposes or as suggestion to users which alias to use to advertise the room. A room with an m.room.canonical_alias event with an absent, null, or empty alias field should be treated the same as a room with no m.room.canonical_alias event."
      } ]
    },
    "RoomCreate" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "creator" ],
        "properties" : {
          "creator" : {
            "type" : "string",
            "description" : "The user_id of the room creator. This is set by the homeserver."
          },
          "m.federate" : {
            "type" : "boolean",
            "description" : "Whether users on other servers can join this room. Defaults to ``true`` if key does not exist."
          },
          "room_version" : {
            "type" : "string",
            "description" : "The version of the room. Defaults to \"1\" if the key does not exist."
          }
        },
        "description" : "This is the first event in a room and cannot be changed. It acts as the root of all other events."
      } ]
    },
    "RoomEncrypted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "sender_key" ],
        "properties" : {
          "sender_key" : {
            "type" : "string",
            "description" : "The Curve25519 key of the sender."
          },
          "device_id" : {
            "type" : "string",
            "description" : "The ID of the sending device. Required with Megolm."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session used to encrypt the message. Required with Megolm."
          },
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm used to encrypt this event. The value of this field determines which other properties will be present.",
            "readOnly" : true,
            "enum" : [ "m.olm.v1.curve25519-aes-sha2", "m.megolm.v1.aes-sha2" ]
          }
        },
        "description" : "This event type is used when sending encrypted events. It can be used either within a room (in which case it will have all of the Room Event fields), or as a to-device event."
      } ]
    },
    "RoomEncryption" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm to be used to encrypt messages sent in this room. Must be 'm.megolm.v1.aes-sha2'."
          },
          "rotation_period_ms" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "How long the session should be used before changing it. 604800000 (a week) is the recommended default."
          },
          "rotation_period_msgs" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "How many messages should be sent before changing the session. 100 is the recommended default."
          }
        },
        "description" : "State Event. Defines how messages sent in this room should be encrypted."
      } ]
    },
    "RoomGuestAccess" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "guest_access" : {
            "type" : "string",
            "description" : "Whether guests can join the room.",
            "enum" : [ "can_join", "forbidden" ]
          }
        },
        "description" : "This event controls whether guest users are allowed to join rooms. If this event is absent, servers should act as if it is present and has the guest_access value \"forbidden\"."
      } ]
    },
    "RoomHistoryVisibility" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "history_visibility" ],
        "properties" : {
          "history_visibility" : {
            "type" : "string",
            "description" : "Who can see the room history.",
            "enum" : [ "invited", "joined", "shared", "world_readable" ]
          }
        },
        "description" : "This event controls whether a user can see the events that happened in a room from before they joined."
      } ]
    },
    "RoomJoinRules" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "join_rule" : {
            "type" : "string",
            "description" : "The type of rules used for users wishing to join this room.",
            "enum" : [ "public", "knock", "invite", "private" ]
          }
        },
        "description" : "A room may be ``public`` meaning anyone can join the room without any prior action. Alternatively, it can be ``invite`` meaning that a user who wishes to join the room must first receive an invite to the room from someone already inside of the room. Currently, ``knock`` and ``private`` are reserved keywords which are not implemented."
      } ]
    },
    "RoomKey" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "algorithm", "room_id", "session_id", "session_key" ],
        "properties" : {
          "algorithm" : {
            "type" : "string",
            "description" : "The encryption algorithm the key in this event is to be used with. Must be 'm.megolm.v1.aes-sha2'."
          },
          "room_id" : {
            "type" : "string",
            "description" : "The room where the key is used."
          },
          "session_id" : {
            "type" : "string",
            "description" : "The ID of the session that the key is for."
          },
          "session_key" : {
            "type" : "string",
            "description" : "The key to be exchanged."
          }
        },
        "description" : "This event type is used to exchange keys for end-to-end encryption. Typically it is encrypted as an m.room.encrypted event, then sent as a to-device event."
      } ]
    },
    "RoomKeyRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "action", "request_id", "requesting_device_id" ],
        "properties" : {
          "body" : {
            "description" : "Information about the requested key. Required when action is request.",
            "$ref" : "#/definitions/RequestedKeyInfo"
          },
          "action" : {
            "type" : "string",
            "description" : "Request action.",
            "enum" : [ "request", "cancel_request" ]
          },
          "requesting_device_id" : {
            "type" : "string",
            "description" : "ID of the device requesting the key."
          },
          "request_id" : {
            "type" : "string",
            "description" : "A random string uniquely identifying the request for a key. If the key is requested multiple times, it should be reused. It should also reused in order to cancel a request."
          }
        },
        "description" : "This event type is used to request keys for end-to-end encryption. It is sent as an unencrypted to-device event."
      } ]
    },
    "RoomMember" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "membership" ],
        "properties" : {
          "membership" : {
            "type" : "string",
            "description" : "The membership state of the user.",
            "enum" : [ "invite", "join", "knock", "leave", "ban" ]
          },
          "unsigned" : {
            "description" : "Contains optional extra information about the event.",
            "$ref" : "#/definitions/RoomMemberUnsigned"
          },
          "direct" : {
            "type" : "boolean"
          },
          "avatar_url" : {
            "type" : "string",
            "description" : "The avatar URL for this user, if any. This is added by the homeserver."
          },
          "displayname" : {
            "type" : "string",
            "description" : "The display name for this user, if any. This is added by the homeserver."
          },
          "is_direct" : {
            "type" : "boolean",
            "description" : "Flag indicating if the room containing this event was created with the intention of being a direct chat. See Direct Messaging."
          },
          "third_party_invite" : {
            "description" : "Third-party invites.",
            "$ref" : "#/definitions/Invite"
          }
        },
        "description" : "Adjusts the membership state for a user in a room. It is preferable to use the membership APIs (/rooms/<room id>/invite etc) when performing membership actions rather than adjusting the state directly as there are a restricted set of valid transformations. For example, user A cannot force user B to join a room, and trying to force this state change directly will fail."
      } ]
    },
    "RoomMemberUnsigned" : {
      "type" : "object",
      "properties" : {
        "events" : {
          "type" : "array",
          "description" : "A subset of the state of the room at the time of the invite, if membership is invite. Note that this state is informational, and SHOULD NOT be trusted; once the client has joined the room, it SHOULD fetch the live state from the server and discard the invite_room_state. Also, clients must not rely on any particular state being present here; they SHOULD behave properly (with possibly a degraded but not a broken experience) in the absence of any particular events here. If they are set on the room, at least the state for m.room.avatar, m.room.canonical_alias, m.room.join_rules, and m.room.name SHOULD be included.",
          "items" : {
            "$ref" : "#/definitions/StrippedState"
          }
        }
      },
      "description" : "Unsigned data."
    },
    "RoomMessage" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "The textual representation of this message."
          },
          "m.relates_to" : {
            "description" : "Relates (reply, ...).",
            "$ref" : "#/definitions/Relates"
          },
          "msgtype" : {
            "type" : "string",
            "description" : "Message type.",
            "readOnly" : true
          }
        },
        "description" : "This event is used when sending messages in a room. Messages are not limited to be text. The ``msgtype`` key outlines the type of message, e.g. text, audio, image, video, etc. The ``body`` key is text and MUST be used with every kind of ``msgtype`` as a fallback mechanism for when a client cannot render a message. This allows clients to display *something* even if it is just plain text."
      } ]
    },
    "RoomName" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The name of the room. This MUST NOT exceed 255 bytes."
          }
        },
        "description" : "A room has an opaque room ID which is not human-friendly to read. A room alias is human-friendly, but not all rooms have room aliases. The room name is a human-friendly string designed to be displayed to the end-user. The room name is not unique, as multiple rooms can have the same room name set. A room with an m.room.name event with an absent, null, or empty name field should be treated the same as a room with no m.room.name event. An event of this type is automatically created when creating a room using /createRoom with the name key."
      } ]
    },
    "RoomPinned" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "pinned" ],
        "properties" : {
          "pinned" : {
            "type" : "array",
            "description" : "An ordered list of event IDs to pin.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "This event is used to \"pin\" particular events in a room for other participants to review later. The order of the pinned events is guaranteed and based upon the order supplied in the event. Clients should be aware that the current user may not be able to see some of the events pinned due to visibility settings in the room. Clients are responsible for determining if a particular event in the pinned list is displayable, and have the option to not display it if it cannot be pinned in the client."
      } ]
    },
    "RoomPowerLevels" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "ban" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to ban a user. Defaults to 50 if unspecified."
          },
          "events" : {
            "type" : "object",
            "description" : "The level required to send specific event types. This is a mapping from event type to power level required.",
            "additionalProperties" : {
              "type" : "string",
              "format" : "byte"
            }
          },
          "invite" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to invite a user. Defaults to 50 if unspecified."
          },
          "kick" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to kick a user. Defaults to 50 if unspecified."
          },
          "redact" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The level required to redact an event. Defaults to 50 if unspecified."
          },
          "users" : {
            "type" : "object",
            "description" : "The power levels for specific users. This is a mapping from user_id to power level for that user.",
            "additionalProperties" : {
              "type" : "string",
              "format" : "byte"
            }
          },
          "notifications" : {
            "description" : "The power level requirements for specific notification types. This is a mapping from key to power level for that notifications key.",
            "$ref" : "#/definitions/NotificationPowerLevel"
          },
          "events_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default level required to send message events. Can be overridden by the events key. Defaults to 0 if unspecified."
          },
          "state_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default level required to send state events. Can be overridden by the events key. Defaults to 50 if unspecified, but 0 if there is no m.room.power_levels event at all."
          },
          "users_default" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The default power level for every user in the room, unless their user_id is mentioned in the users key. Defaults to 0 if unspecified."
          }
        },
        "description" : "This event specifies the minimum level a user must have in order to perform a certain action. It also specifies the levels of each user in the room. If a user_id is in the users list, then that user_id has the associated power level. Otherwise they have the default level users_default. If users_default is not supplied, it is assumed to be 0. If the room contains no m.room.power_levels event, the room's creator has a power level of 100, and all other users have a power level of 0. The level required to send a certain event is governed by events, state_default and events_default. If an event type is specified in events, then the user must have at least the level specified in order to send that event. If the event type is not supplied, it defaults to events_default for Message Events and state_default for State Events. If there is no state_default in the m.room.power_levels event, the state_default is 50. If there is no events_default in the m.room.power_levels event, the events_default is 0. If the room contains no m.room.power_levels event, both the state_default and events_default are 0. The power level required to invite a user to the room, kick a user from the room, ban a user from the room, or redact an event, is defined by invite, kick, ban, and redact, respectively. Each of these levels defaults to 50 if they are not specified in the m.room.power_levels event, or if the room contains no m.room.power_levels event."
      } ]
    },
    "RoomRedaction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "reason" : {
            "type" : "string",
            "description" : "The reason for the redaction, if any."
          }
        },
        "description" : "Events can be redacted by either room or server admins. Redacting an event means that all keys not required by the protocol are stripped off, allowing admins to remove offensive or illegal content that may have been attached to any event. This cannot be undone, allowing server owners to physically delete the offending data. There is also a concept of a moderator hiding a message event, which can be undone, but cannot be applied to state events. The event that has been redacted is specified in the redacts event level key."
      } ]
    },
    "RoomServerAcl" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "allow" : {
            "type" : "array",
            "description" : "The server names to allow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided, effectively disallowing every server.",
            "items" : {
              "type" : "string"
            }
          },
          "deny" : {
            "type" : "array",
            "description" : "The server names to disallow in the room, excluding any port information. Wildcards may be used to cover a wider range of hosts, where * matches zero or more characters and ? matches exactly one character. This defaults to an empty list when not provided.",
            "items" : {
              "type" : "string"
            }
          },
          "allow_ip_literals" : {
            "type" : "boolean",
            "description" : "True to allow server names that are IP address literals. False to deny. Defaults to true if missing or otherwise not a boolean. This is strongly recommended to be set to false as servers running with IP literal names are strongly discouraged in order to require legitimate homeservers to be backed by a valid registered domain name."
          }
        },
        "description" : "An event to indicate which servers are permitted to participate in the room. Server ACLs may allow or deny groups of hosts."
      } ]
    },
    "RoomThirdPartyInvite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "display_name", "key_validity_url", "public_key" ],
        "properties" : {
          "display_name" : {
            "type" : "string",
            "description" : "A user-readable string which represents the user who has been invited. This should not contain the user's third party ID, as otherwise when the invite is accepted it would leak the association between the matrix ID and the third party ID."
          },
          "key_validity_url" : {
            "type" : "string",
            "description" : "A URL which can be fetched, with querystring public_key=public_key, to validate whether the key has been revoked. The URL must return a JSON object containing a boolean property named 'valid'."
          },
          "public_key" : {
            "type" : "string",
            "description" : "A base64-encoded ed25519 key with which token must be signed (though a signature from any entry in public_keys is also sufficient). This exists for backwards compatibility."
          },
          "public_keys" : {
            "type" : "array",
            "description" : "Keys with which the token may be signed.",
            "items" : {
              "$ref" : "#/definitions/PublicKeys"
            }
          }
        },
        "description" : "Acts as an m.room.member invite event, where there isn't a target user_id to invite. This event contains a token and a public key whose private key must be used to sign the token. Any user who can present that signature may use this invitation to join the target room."
      } ]
    },
    "RoomTopic" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "topic" ],
        "properties" : {
          "topic" : {
            "type" : "string",
            "description" : "The topic text"
          }
        },
        "description" : "A topic is a short message detailing what is currently being discussed in the room. It can also be used as a way to display extra information about the room, which may not be suitable for the room name. The room topic can also be set when creating a room using /createRoom with the topic key."
      } ]
    },
    "Signed" : {
      "type" : "object",
      "required" : [ "mxid", "signatures", "token" ],
      "properties" : {
        "mxid" : {
          "type" : "string",
          "description" : "The invited matrix user ID. Must be equal to the user_id property of the event."
        },
        "token" : {
          "type" : "string",
          "description" : "The token property of the containing third_party_invite object."
        },
        "signatures" : {
          "type" : "object",
          "description" : "A single signature from the verifying server, in the format specified by the Signing Events section of the server-server API.",
          "additionalProperties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "description" : "Signed part of the invitation request."
    },
    "Sticker" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "body", "info", "url" ],
        "properties" : {
          "body" : {
            "type" : "string",
            "description" : "A textual representation or associated description of the sticker image. This could be the alt text of the original image, or a message to accompany and further describe the sticker."
          },
          "info" : {
            "description" : "Metadata about the image referred to in url including a thumbnail representation.",
            "$ref" : "#/definitions/ImageInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the sticker image. This must be a valid mxc:// URI."
          }
        },
        "description" : "This message represents a single sticker image."
      } ]
    },
    "StrippedState" : {
      "type" : "object",
      "required" : [ "content", "sender", "state_key", "type" ],
      "properties" : {
        "content" : {
          "description" : "The content for the event.",
          "$ref" : "#/definitions/EventContent"
        },
        "type" : {
          "type" : "string",
          "description" : "The type for the event."
        },
        "sender" : {
          "type" : "string",
          "description" : "The sender for the event."
        },
        "state_key" : {
          "type" : "string",
          "description" : "The state_key for the event."
        }
      },
      "description" : "Provides information on a subset of state events such as the room name."
    },
    "Tag" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "properties" : {
          "tags" : {
            "type" : "object",
            "description" : "The tags on the room and their contents.",
            "additionalProperties" : {
              "$ref" : "#/definitions/TagInfo"
            }
          }
        },
        "description" : "Informs the client of tags on a room."
      } ]
    },
    "TagInfo" : {
      "type" : "object",
      "properties" : {
        "order" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "A number in a range [0,1] describing a relative position of the room under the given tag."
        }
      },
      "description" : "Tag info."
    },
    "Text" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The format used in the ``formatted_body``. Currently only ``org.matrix.custom.html`` is supported."
          },
          "formatted_body" : {
            "type" : "string",
            "description" : "The formatted version of the ``body``. This is required if ``format`` is specified."
          }
        },
        "description" : "This message is the most basic message and is used to represent text."
      } ]
    },
    "ThumbnailInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Thumbnail info."
    },
    "Typing" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EventContent"
      }, {
        "type" : "object",
        "required" : [ "user_ids" ],
        "properties" : {
          "user_ids" : {
            "type" : "array",
            "description" : "The list of user IDs typing in this room, if any.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "description" : "Informs the client of the list of users currently typing."
      } ]
    },
    "Video" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoomMessage"
      }, {
        "type" : "object",
        "required" : [ "url" ],
        "properties" : {
          "info" : {
            "description" : "Metadata about the video clip referred to in url.",
            "$ref" : "#/definitions/VideoInfo"
          },
          "url" : {
            "type" : "string",
            "description" : "The URL to the video clip."
          },
          "file" : {
            "description" : "Required if the file is encrypted. Information on the encrypted file, as specified in End-to-end encryption.",
            "$ref" : "#/definitions/EncryptedFile"
          }
        },
        "description" : "This message represents a single video clip."
      } ]
    },
    "VideoInfo" : {
      "type" : "object",
      "properties" : {
        "mimetype" : {
          "type" : "string",
          "description" : "The mimetype of the image, e.g. image/jpeg."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Size of the image in bytes."
        },
        "duration" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The duration of the video in milliseconds."
        },
        "thumbnail_url" : {
          "type" : "string",
          "description" : "The URL to a thumbnail of the image."
        },
        "thumbnail_file" : {
          "$ref" : "#/definitions/EncryptedFile"
        },
        "thumbnail_info" : {
          "description" : "Metadata about the image referred to in thumbnail_url.",
          "$ref" : "#/definitions/ThumbnailInfo"
        },
        "h" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display height of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        },
        "w" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "The intended display width of the image in pixels. This may differ from the intrinsic dimensions of the image file."
        }
      },
      "description" : "Video info."
    }
  }
}